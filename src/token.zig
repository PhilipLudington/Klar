pub const Token = struct {
    kind: Kind,
    loc: Loc,

    pub const Loc = struct {
        start: usize,
        end: usize,
        line: u32,
        column: u32,
    };

    pub const Kind = enum {
        // Literals
        int_literal,
        float_literal,
        string_literal,
        char_literal,
        true_,
        false_,

        // Identifier
        identifier,

        // Keywords
        fn_,
        let,
        var_,
        struct_,
        enum_,
        trait,
        impl,
        if_,
        else_,
        match,
        for_,
        while_,
        loop,
        return_,
        break_,
        continue_,
        pub_,
        mut,
        async_,
        await_,
        unsafe_,
        import,
        module,
        as,
        in,
        is,
        and_,
        or_,
        not,
        comptime_,
        where,
        dyn,
        type_,
        const_,
        static,
        self,
        self_type,
        ref,
        inout,

        // Operators
        plus,
        minus,
        star,
        slash,
        percent,
        plus_wrap,
        minus_wrap,
        star_wrap,
        plus_sat,
        minus_sat,
        star_sat,
        eq,
        eq_eq,
        not_eq,
        lt,
        gt,
        lt_eq,
        gt_eq,
        amp,
        pipe,
        caret,
        tilde,
        lt_lt,
        gt_gt,
        question,
        bang,
        question_question,
        dot,
        dot_dot,
        dot_dot_eq,
        arrow,
        fat_arrow,
        colon,
        colon_colon,
        at, // @ for builtin functions

        // Compound assignment
        plus_eq,
        minus_eq,
        star_eq,
        slash_eq,
        percent_eq,

        // Delimiters
        l_paren,
        r_paren,
        l_bracket,
        r_bracket,
        l_brace,
        r_brace,
        comma,
        semicolon,
        newline,

        // Special
        eof,
        invalid,

        pub fn lexeme(self: Kind) ?[]const u8 {
            return switch (self) {
                .fn_ => "fn",
                .let => "let",
                .var_ => "var",
                .struct_ => "struct",
                .enum_ => "enum",
                .trait => "trait",
                .impl => "impl",
                .if_ => "if",
                .else_ => "else",
                .match => "match",
                .for_ => "for",
                .while_ => "while",
                .loop => "loop",
                .return_ => "return",
                .break_ => "break",
                .continue_ => "continue",
                .pub_ => "pub",
                .mut => "mut",
                .async_ => "async",
                .await_ => "await",
                .unsafe_ => "unsafe",
                .import => "import",
                .module => "module",
                .as => "as",
                .in => "in",
                .is => "is",
                .and_ => "and",
                .or_ => "or",
                .not => "not",
                .true_ => "true",
                .false_ => "false",
                .comptime_ => "comptime",
                .where => "where",
                .dyn => "dyn",
                .type_ => "type",
                .const_ => "const",
                .static => "static",
                .self => "self",
                .self_type => "Self",
                .ref => "ref",
                .inout => "inout",
                .plus => "+",
                .minus => "-",
                .star => "*",
                .slash => "/",
                .percent => "%",
                .plus_wrap => "+%",
                .minus_wrap => "-%",
                .star_wrap => "*%",
                .plus_sat => "+|",
                .minus_sat => "-|",
                .star_sat => "*|",
                .eq => "=",
                .eq_eq => "==",
                .not_eq => "!=",
                .lt => "<",
                .gt => ">",
                .lt_eq => "<=",
                .gt_eq => ">=",
                .amp => "&",
                .pipe => "|",
                .caret => "^",
                .tilde => "~",
                .lt_lt => "<<",
                .gt_gt => ">>",
                .question => "?",
                .bang => "!",
                .question_question => "??",
                .dot => ".",
                .dot_dot => "..",
                .dot_dot_eq => "..=",
                .arrow => "->",
                .fat_arrow => "=>",
                .colon => ":",
                .colon_colon => "::",
                .at => "@",
                .plus_eq => "+=",
                .minus_eq => "-=",
                .star_eq => "*=",
                .slash_eq => "/=",
                .percent_eq => "%=",
                .l_paren => "(",
                .r_paren => ")",
                .l_bracket => "[",
                .r_bracket => "]",
                .l_brace => "{",
                .r_brace => "}",
                .comma => ",",
                .semicolon => ";",
                .newline => "\\n",
                .eof => "EOF",
                .invalid => null,
                .int_literal, .float_literal, .string_literal, .char_literal, .identifier => null,
            };
        }

        pub fn isKeyword(self: Kind) bool {
            return switch (self) {
                .fn_, .let, .var_, .struct_, .enum_, .trait, .impl, .if_, .else_, .match, .for_, .while_, .loop, .return_, .break_, .continue_, .pub_, .mut, .async_, .await_, .unsafe_, .import, .module, .as, .in, .is, .and_, .or_, .not, .true_, .false_, .comptime_, .where, .dyn, .type_, .const_, .static, .self, .self_type, .ref, .inout => true,
                else => false,
            };
        }
    };

    /// Get the source text for this token
    pub fn text(self: Token, source: []const u8) []const u8 {
        return source[self.loc.start..self.loc.end];
    }
};
