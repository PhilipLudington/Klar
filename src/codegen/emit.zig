//! AST to LLVM IR emission.
//!
//! Translates typed AST to LLVM IR for native code generation.

const std = @import("std");
const builtin = @import("builtin");
const version = @import("../version.zig");
const Allocator = std.mem.Allocator;
const ast = @import("../ast.zig");
const types = @import("../types.zig");
const checker_mod = @import("../checker.zig");
const TypeChecker = checker_mod.TypeChecker;
const llvm = @import("llvm.zig");
const target = @import("target.zig");
const layout = @import("layout.zig");

/// Errors that can occur during IR emission.
pub const EmitError = error{
    OutOfMemory,
    UnsupportedFeature,
    InvalidAST,
    LLVMError,
};

/// LLVM IR emitter.
pub const Emitter = struct {
    allocator: Allocator,
    ctx: llvm.Context,
    module: llvm.Module,
    builder: llvm.Builder,
    current_function: ?llvm.ValueRef,

    /// Target platform information.
    platform: target.Platform,
    /// ABI information for struct passing/returning.
    abi: target.ABI,
    /// Calling convention for the target.
    calling_convention: target.CallingConvention,

    /// Named values in current scope (locals, params).
    named_values: std.StringHashMap(LocalValue),

    /// Track whether we've seen a terminator in the current block.
    has_terminator: bool,

    /// Stack of loop contexts for break/continue.
    loop_stack: std.ArrayListUnmanaged(LoopContext),

    /// Stack of scopes for automatic drop insertion.
    scope_stack: std.ArrayListUnmanaged(ScopeInfo),

    /// Current function's return type info (for optional wrapping).
    current_return_type: ?ReturnTypeInfo,

    /// Cached overflow intrinsic IDs.
    sadd_overflow_id: ?c_uint,
    ssub_overflow_id: ?c_uint,
    smul_overflow_id: ?c_uint,
    uadd_overflow_id: ?c_uint,
    usub_overflow_id: ?c_uint,
    umul_overflow_id: ?c_uint,

    /// Cache of LLVM struct types by name.
    struct_types: std.StringHashMap(StructTypeInfo),
    /// Layout calculator for composite types.
    layout_calc: layout.LayoutCalculator,
    /// Counter for generating unique closure names.
    closure_counter: u32 = 0,
    /// Cache of generated closure types.
    closure_types: std.StringHashMap(ClosureTypeInfo),

    // --- Debug info fields ---
    /// Debug info builder (null if debug info is disabled).
    di_builder: ?llvm.DIBuilder,
    /// Compile unit metadata (root of debug info).
    di_compile_unit: ?llvm.MetadataRef,
    /// Current file metadata.
    di_file: ?llvm.MetadataRef,
    /// Current scope for debug locations.
    di_scope: ?llvm.MetadataRef,
    /// Source filename for error location tracking (set when debug info is initialized).
    /// Null-terminated for use with LLVM APIs.
    source_filename: ?[:0]const u8,

    /// Reference to type checker for call resolution (generic functions).
    type_checker: ?*const TypeChecker,

    /// Expected type context for expression emission (set during var declarations).
    /// Used by Ok/Err constructors to infer Result types from annotations.
    expected_type: ?types.Type,

    /// Current function's return type as Klar type (for expected_type in returns).
    current_return_klar_type: ?types.Type,

    /// Cache of allocated mangled enum names (for cleanup).
    mangled_enum_names: std.ArrayListUnmanaged([]const u8),

    /// Sret (struct return) pointer for the current function.
    /// Set when the function uses sret calling convention for returning aggregates.
    current_sret_ptr: ?llvm.ValueRef,

    /// Cached sret attribute kind ID (lazily initialized).
    sret_attr_kind: ?c_uint,

    /// Set of function names that use sret calling convention.
    /// Used to detect sret at call sites.
    sret_functions: std.StringHashMap(llvm.TypeRef),

    /// Set of extern function declarations for FFI.
    extern_functions: std.StringHashMap(ExternFnInfo),

    /// True if main() takes [String] args (needs wrapper generation).
    main_takes_args: bool = false,

    // --- Type declarations (must come after all fields in Zig 0.15+) ---

    /// Info for ABI-lowered parameter (struct -> integer conversion)
    const AbiLoweredParam = struct {
        struct_type: llvm.TypeRef,
        int_type: llvm.TypeRef,
    };

    const ExternFnInfo = struct {
        func: llvm.ValueRef,
        is_variadic: bool,
        /// For ABI lowering: if the function returns a struct that's lowered to an integer,
        /// this holds the original struct type so we can convert the return value.
        abi_lowered_return_type: ?llvm.TypeRef = null,
        /// For ABI lowering: tracks which parameters are structs lowered to integers.
        /// Index i contains both struct and int types if parameter i was lowered.
        abi_lowered_param_types: ?[]const ?AbiLoweredParam = null,
        /// Bitmask of out parameters (index i is out if bit i is set).
        out_params: u64 = 0,
        /// Types for out parameters (index i contains LLVM type if param i is out).
        out_param_types: ?[]const ?llvm.TypeRef = null,
    };

    const ReturnTypeInfo = struct {
        llvm_type: llvm.TypeRef,
        is_optional: bool,
        is_result: bool,
        inner_type: ?llvm.TypeRef, // Non-null if is_optional (the T in Optional[T])
        ok_type: ?llvm.TypeRef, // Non-null if is_result (the T in Result[T, E])
        err_type: ?llvm.TypeRef, // Non-null if is_result (the E in Result[T, E])
    };

    const StructTypeInfo = struct {
        llvm_type: llvm.TypeRef,
        field_indices: []const u32,
        field_names: []const []const u8,
    };

    const LocalValue = struct {
        value: llvm.ValueRef,
        is_alloca: bool,
        ty: llvm.TypeRef,
        is_signed: bool,
        /// For struct variables, the name of the struct type for field resolution.
        struct_type_name: ?[]const u8 = null,
        /// For Rc[T] or Arc[T], the inner type that can be dereferenced.
        inner_type: ?llvm.TypeRef = null,
        /// True if this is an Arc type (uses atomic operations).
        is_arc: bool = false,
        /// For closure variables, the return type of the closure function.
        /// This is needed because we can't determine the return type from the closure struct type alone.
        closure_return_type: ?llvm.TypeRef = null,
        /// For closure variables, the parameter types of the closure function.
        closure_param_types: ?[]const llvm.TypeRef = null,
        /// True if this is a primitive string type.
        is_string: bool = false,
        /// True if this is a heap-allocated String type.
        is_string_data: bool = false,
        /// True if this is an array or slice type.
        is_array: bool = false,
        /// For fixed-size arrays, the size. Null for slices.
        array_size: ?usize = null,
        /// For arrays/slices, the element type.
        array_element_type: ?types.Type = null,
        /// True if this is a reference parameter (&T or &mut T).
        /// The alloca contains a pointer to the struct, not the struct itself.
        is_reference: bool = false,
        /// For reference params, the LLVM type of the pointed-to struct.
        reference_inner_type: ?llvm.TypeRef = null,
        /// For List[T] types, the element type.
        list_element_type: ?types.Type = null,
        /// True if this is a Map type.
        is_map: bool = false,
        /// For Map[K,V] types, the key type.
        map_key_type: ?types.Type = null,
        /// For Map[K,V] types, the value type.
        map_value_type: ?types.Type = null,
        /// True if this is a Set type.
        is_set: bool = false,
        /// For Set[T] types, the element type.
        set_element_type: ?types.Type = null,
        /// True if this is a File type (FILE* handle).
        is_file: bool = false,
        /// True if this is a Stdout type (FILE* handle).
        is_stdout: bool = false,
        /// True if this is a Stderr type (FILE* handle).
        is_stderr: bool = false,
        /// True if this is a Stdin type (FILE* handle).
        is_stdin: bool = false,
        /// True if this is a BufReader type.
        is_buf_reader: bool = false,
        /// For BufReader[R], the inner reader type.
        buf_reader_inner_type: ?types.Type = null,
        /// True if this is a BufWriter type.
        is_buf_writer: bool = false,
        /// For BufWriter[W], the inner writer type.
        buf_writer_inner_type: ?types.Type = null,
        /// Full semantic type for pattern matching (Result, Optional, etc.)
        semantic_type: ?types.Type = null,
    };

    const LoopContext = struct {
        continue_block: llvm.BasicBlockRef,
        break_block: llvm.BasicBlockRef,
    };

    /// Info about a variable that needs to be dropped at scope exit.
    const DroppableVar = struct {
        name: []const u8,
        alloca: llvm.ValueRef,
        inner_type: llvm.TypeRef,
        /// True if this is an Rc/Arc type (needs ref-counted drop).
        is_rc: bool,
        /// True if this is an Arc type (uses atomic operations).
        is_arc: bool = false,
        /// True if this is a BufWriter type (needs flush on drop).
        is_buf_writer: bool = false,
        /// True if this is a CStrOwned type (needs free on drop).
        is_cstr_owned: bool = false,
    };

    /// Info about a scope for drop tracking.
    const ScopeInfo = struct {
        /// Variables declared in this scope that need dropping.
        droppables: std.ArrayListUnmanaged(DroppableVar),
        /// True if this scope is a loop body (break/continue need drops).
        is_loop: bool,
    };

    /// Info about a generated closure type.
    const ClosureTypeInfo = struct {
        struct_type: llvm.TypeRef,
        fn_ptr_type: llvm.TypeRef,
        lifted_fn: llvm.ValueRef,
        capture_names: []const []const u8,
    };

    pub fn init(allocator: Allocator, module_name: [:0]const u8) Emitter {
        const ctx = llvm.Context.create();
        const module = llvm.Module.create(module_name, ctx);
        const builder = llvm.Builder.create(ctx);

        // Initialize platform and ABI info
        const platform = target.Platform.current();
        const abi = target.ABI.init(platform);
        const calling_convention = target.CallingConvention.forPlatform(platform);

        // Set target triple on the module for proper code generation
        const triple = target.getDefaultTriple();
        module.setTarget(triple);

        return .{
            .allocator = allocator,
            .ctx = ctx,
            .module = module,
            .builder = builder,
            .current_function = null,
            .platform = platform,
            .abi = abi,
            .calling_convention = calling_convention,
            .named_values = std.StringHashMap(LocalValue).init(allocator),
            .has_terminator = false,
            .loop_stack = .{},
            .scope_stack = .{},
            .current_return_type = null,
            .sadd_overflow_id = null,
            .ssub_overflow_id = null,
            .smul_overflow_id = null,
            .uadd_overflow_id = null,
            .usub_overflow_id = null,
            .umul_overflow_id = null,
            .struct_types = std.StringHashMap(StructTypeInfo).init(allocator),
            .layout_calc = layout.LayoutCalculator.init(allocator, platform),
            .closure_counter = 0,
            .closure_types = std.StringHashMap(ClosureTypeInfo).init(allocator),
            .di_builder = null,
            .di_compile_unit = null,
            .di_file = null,
            .di_scope = null,
            .source_filename = null,
            .type_checker = null,
            .expected_type = null,
            .current_return_klar_type = null,
            .mangled_enum_names = .{},
            .current_sret_ptr = null,
            .sret_attr_kind = null,
            .sret_functions = std.StringHashMap(llvm.TypeRef).init(allocator),
            .extern_functions = std.StringHashMap(ExternFnInfo).init(allocator),
        };
    }

    /// Create an alloca in the function's entry block.
    /// This ensures allocas don't grow the stack when placed in loops.
    /// LLVM's mem2reg optimization only works on allocas in the entry block.
    fn buildEntryBlockAlloca(self: *Emitter, ty: llvm.TypeRef, name: [:0]const u8) llvm.ValueRef {
        const func = self.current_function orelse {
            // Fallback: create alloca at current position if no function context
            return self.builder.buildAlloca(ty, name);
        };

        // Get the entry block of the current function
        const entry_block = llvm.c.LLVMGetFirstBasicBlock(func);
        if (entry_block == null) {
            // Fallback: create alloca at current position if no entry block
            return self.builder.buildAlloca(ty, name);
        }

        // Save the current insert point
        const current_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Position at the start of the entry block (before any instructions)
        const first_instr = llvm.c.LLVMGetFirstInstruction(entry_block);
        if (first_instr != null) {
            llvm.c.LLVMPositionBuilderBefore(self.builder.ref, first_instr);
        } else {
            self.builder.positionAtEnd(entry_block);
        }

        // Create the alloca in the entry block
        const alloca = self.builder.buildAlloca(ty, name);

        // Restore the original insert point
        if (current_block != null) {
            self.builder.positionAtEnd(current_block);
        }

        return alloca;
    }

    /// Initialize debug info for the module.
    pub fn initDebugInfo(self: *Emitter, filename: []const u8, directory: []const u8) void {
        const di_builder = llvm.DIBuilder.create(self.module);

        // Create the file
        const di_file = di_builder.createFile(filename, directory);

        // Create the compile unit
        // Use C99 as the language since DWARF doesn't have a Klar entry
        const di_compile_unit = di_builder.createCompileUnit(
            llvm.c.LLVMDWARFSourceLanguageC99,
            di_file,
            version.producer,
            false, // not optimized
            "", // flags
            0, // runtime version
            "", // split name
            llvm.c.LLVMDWARFEmissionFull,
            0, // DWO id
            false, // split debug inlining
            false, // debug info for profiling
            "", // sysroot
            "", // SDK
        );

        self.di_builder = di_builder;
        self.di_compile_unit = di_compile_unit;
        self.di_file = di_file;
        self.di_scope = di_compile_unit;
        // Allocate a null-terminated copy for use with LLVM string APIs
        self.source_filename = self.allocator.dupeZ(u8, filename) catch null;
    }

    /// Finalize debug info. Must be called before module verification.
    pub fn finalizeDebugInfo(self: *Emitter) void {
        if (self.di_builder) |di_builder| {
            di_builder.finalize();
        }
    }

    /// Set the type checker reference for call resolution.
    /// Must be called before emitModule if you want generic function calls to be resolved.
    pub fn setTypeChecker(self: *Emitter, checker: *const TypeChecker) void {
        self.type_checker = checker;
    }

    pub fn deinit(self: *Emitter) void {
        // Dispose debug info builder first
        if (self.di_builder) |di_builder| {
            di_builder.dispose();
        }
        // Free allocated source filename
        if (self.source_filename) |filename| {
            self.allocator.free(filename);
        }
        self.loop_stack.deinit(self.allocator);
        // Clean up any remaining scopes (shouldn't normally have any)
        for (self.scope_stack.items) |*scope| {
            scope.droppables.deinit(self.allocator);
        }
        self.scope_stack.deinit(self.allocator);
        self.named_values.deinit();
        // Free struct type info allocations
        var it = self.struct_types.valueIterator();
        while (it.next()) |info| {
            self.allocator.free(info.field_indices);
            self.allocator.free(info.field_names);
        }
        self.struct_types.deinit();
        // Free closure type info allocations
        var cit = self.closure_types.valueIterator();
        while (cit.next()) |info| {
            self.allocator.free(info.capture_names);
        }
        self.closure_types.deinit();
        // Free allocated mangled enum names
        for (self.mangled_enum_names.items) |name| {
            self.allocator.free(name);
        }
        self.mangled_enum_names.deinit(self.allocator);
        // Free sret function name allocations
        var sret_it = self.sret_functions.keyIterator();
        while (sret_it.next()) |key| {
            self.allocator.free(key.*);
        }
        self.sret_functions.deinit();
        // Free extern function allocations
        var extern_it = self.extern_functions.iterator();
        while (extern_it.next()) |entry| {
            self.allocator.free(entry.key_ptr.*);
            // Free allocated slices in the value
            if (entry.value_ptr.abi_lowered_param_types) |slice| {
                self.allocator.free(slice);
            }
            if (entry.value_ptr.out_param_types) |slice| {
                self.allocator.free(slice);
            }
        }
        self.extern_functions.deinit();
        self.layout_calc.deinit();
        self.builder.dispose();
        self.module.dispose();
        self.ctx.dispose();
    }

    /// Emit a complete module.
    pub fn emitModule(self: *Emitter, module: ast.Module) EmitError!void {
        // First pass: collect struct declarations for field name resolution
        for (module.declarations) |decl| {
            switch (decl) {
                .struct_decl => |s| try self.registerStructDecl(s),
                else => {},
            }
        }

        // Second pass: declare all functions (including methods from impl blocks)
        for (module.declarations) |decl| {
            switch (decl) {
                .function => |f| try self.declareFunction(f),
                .impl_decl => |i| try self.declareImplMethods(i),
                .extern_block => |b| {
                    for (b.functions) |f| {
                        try self.declareExternFunction(f);
                    }
                },
                else => {},
            }
        }

        // Third pass: emit function bodies (including methods from impl blocks)
        for (module.declarations) |decl| {
            switch (decl) {
                .function => |f| {
                    if (f.body != null) {
                        try self.emitFunction(f);
                    }
                },
                .impl_decl => |i| try self.emitImplMethods(i),
                else => {},
            }
        }

        // Fourth pass: generate main wrapper if main takes args
        if (self.main_takes_args) {
            try self.emitMainArgsWrapper();
        }
    }

    /// Generate a C-style main(argc, argv) wrapper that converts args to [String].
    fn emitMainArgsWrapper(self: *Emitter) EmitError!void {
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const string_struct_type = self.getStringStructType();

        // Slice struct type: { ptr, i64 len }
        var slice_fields = [_]llvm.TypeRef{ ptr_type, i64_type };
        const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);

        // Generate the args conversion functions inline
        const from_argv_fn = try self.emitArgsFromArgvFn(slice_type, string_struct_type);
        const free_fn = try self.emitArgsFreeeFn(slice_type, string_struct_type);

        // Get reference to _klar_user_main(args: { ptr, i64 }) -> i32
        const user_main_fn = self.module.getNamedFunction("_klar_user_main") orelse return EmitError.InvalidAST;

        // Create main(argc: i32, argv: ptr) -> i32
        var main_params = [_]llvm.TypeRef{ i32_type, ptr_type };
        const main_fn_type = llvm.Types.function(i32_type, &main_params, false);
        const main_fn = llvm.addFunction(self.module, "main", main_fn_type);

        // Create entry block
        const entry_block = llvm.appendBasicBlock(self.ctx, main_fn, "entry");
        self.builder.positionAtEnd(entry_block);

        // Get argc and argv parameters
        const argc = llvm.c.LLVMGetParam(main_fn, 0);
        const argv = llvm.c.LLVMGetParam(main_fn, 1);

        // Call _klar_args_from_argv(argc, argv) -> { ptr, i64 }
        var from_argv_params = [_]llvm.TypeRef{ i32_type, ptr_type };
        const from_argv_fn_type = llvm.Types.function(slice_type, &from_argv_params, false);
        var from_argv_args = [_]llvm.ValueRef{ argc, argv };
        const args_slice = self.builder.buildCall(
            from_argv_fn_type,
            from_argv_fn,
            &from_argv_args,
            "args",
        );

        // Call _klar_user_main(args) -> i32
        var user_main_args = [_]llvm.ValueRef{args_slice};
        const user_main_fn_type = llvm.Types.function(i32_type, &[_]llvm.TypeRef{slice_type}, false);
        const result = self.builder.buildCall(
            user_main_fn_type,
            user_main_fn,
            &user_main_args,
            "result",
        );

        // Call _klar_args_free(args)
        var free_params = [_]llvm.TypeRef{slice_type};
        const free_fn_type = llvm.Types.function(llvm.Types.void_(self.ctx), &free_params, false);
        var free_args = [_]llvm.ValueRef{args_slice};
        _ = self.builder.buildCall(
            free_fn_type,
            free_fn,
            &free_args,
            "",
        );

        // Return the result
        _ = self.builder.buildRet(result);
    }

    /// Generate _klar_args_from_argv function that converts argc/argv to [String].
    fn emitArgsFromArgvFn(self: *Emitter, slice_type: llvm.TypeRef, string_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Declare external C functions
        const strlen_fn = self.getOrCreateStrlenFn();
        const malloc_fn = self.getOrCreateMallocFn();
        const memcpy_fn = self.getOrCreateMemcpyFn();

        // Create function: { ptr, i64 } _klar_args_from_argv(i32 argc, ptr argv)
        var params = [_]llvm.TypeRef{ i32_type, ptr_type };
        const fn_type = llvm.Types.function(slice_type, &params, false);
        const func = llvm.addFunction(self.module, "_klar_args_from_argv", fn_type);

        // Create blocks
        const entry_block = llvm.appendBasicBlock(self.ctx, func, "entry");
        const check_block = llvm.appendBasicBlock(self.ctx, func, "check");
        const loop_block = llvm.appendBasicBlock(self.ctx, func, "loop");
        const done_block = llvm.appendBasicBlock(self.ctx, func, "done");

        // Entry: check if argc <= 0 (no args at all)
        // We include all of argv[0..argc] in the args slice.
        // For 'klar run': argv = [source_path, arg1, ...], args = [source_path, arg1, ...]
        // For standalone: argv = [binary_path, arg1, ...], args = [binary_path, arg1, ...]
        // args[0] is the "program identifier" (source path or binary path).
        self.builder.positionAtEnd(entry_block);
        const argc = llvm.c.LLVMGetParam(func, 0);
        const argv = llvm.c.LLVMGetParam(func, 1);
        const argc_i64 = self.builder.buildSExt(argc, i64_type, "argc64");
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntSLE, argc, llvm.Const.int32(self.ctx, 0), "is_empty");
        _ = self.builder.buildCondBr(is_empty, done_block, check_block);

        // Check block: allocate array of String structs for argc elements
        self.builder.positionAtEnd(check_block);
        // String struct is { ptr, i32, i32 } = 8 + 4 + 4 = 16 bytes on 64-bit
        const string_size_actual = llvm.Const.int64(self.ctx, 16);
        const array_size = self.builder.buildMul(argc_i64, string_size_actual, "array_size");
        var malloc_args = [_]llvm.ValueRef{array_size};
        const array_ptr = self.builder.buildCall(
            llvm.Types.function(ptr_type, &[_]llvm.TypeRef{i64_type}, false),
            malloc_fn,
            &malloc_args,
            "strings",
        );

        // Initialize loop counter
        const i_ptr = self.builder.buildAlloca(i64_type, "i");
        _ = self.builder.buildStore(llvm.Const.int64(self.ctx, 0), i_ptr);
        _ = self.builder.buildBr(loop_block);

        // Loop block: convert each argv[i] to String
        self.builder.positionAtEnd(loop_block);
        const i_val = self.builder.buildLoad(i64_type, i_ptr, "i");

        // Get argv[i] (include all arguments starting from argv[0])
        const argv_i_ptr = self.builder.buildGEP(ptr_type, argv, &[_]llvm.ValueRef{i_val}, "argv_i_ptr");
        const c_str = self.builder.buildLoad(ptr_type, argv_i_ptr, "c_str");

        // strlen(c_str)
        var strlen_args = [_]llvm.ValueRef{c_str};
        const str_len = self.builder.buildCall(
            llvm.Types.function(i64_type, &[_]llvm.TypeRef{ptr_type}, false),
            strlen_fn,
            &strlen_args,
            "str_len",
        );

        // malloc(str_len) for string data
        var str_malloc_args = [_]llvm.ValueRef{str_len};
        const str_ptr = self.builder.buildCall(
            llvm.Types.function(ptr_type, &[_]llvm.TypeRef{i64_type}, false),
            malloc_fn,
            &str_malloc_args,
            "str_ptr",
        );

        // memcpy(str_ptr, c_str, str_len)
        var memcpy_args = [_]llvm.ValueRef{ str_ptr, c_str, str_len };
        _ = self.builder.buildCall(
            llvm.Types.function(ptr_type, &[_]llvm.TypeRef{ ptr_type, ptr_type, i64_type }, false),
            memcpy_fn,
            &memcpy_args,
            "",
        );

        // Get pointer to array[i] (String struct)
        const string_i_ptr = self.builder.buildGEP(string_type, array_ptr, &[_]llvm.ValueRef{i_val}, "string_i");

        // Store String fields: { ptr, len, capacity }
        const ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_i_ptr, 0, "ptr_field");
        _ = self.builder.buildStore(str_ptr, ptr_field);

        const len_i32 = self.builder.buildTrunc(str_len, i32_type, "len32");
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_i_ptr, 1, "len_field");
        _ = self.builder.buildStore(len_i32, len_field);

        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_i_ptr, 2, "cap_field");
        _ = self.builder.buildStore(len_i32, cap_field);

        // Increment i
        const i_next = self.builder.buildAdd(i_val, llvm.Const.int64(self.ctx, 1), "i_next");
        _ = self.builder.buildStore(i_next, i_ptr);

        // Check if i < argc (loop over all args including argv[0])
        const loop_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, i_next, argc_i64, "loop_cond");
        _ = self.builder.buildCondBr(loop_cond, loop_block, done_block);

        // Done block: build and return slice struct
        self.builder.positionAtEnd(done_block);
        const result_ptr_phi = llvm.c.LLVMBuildPhi(self.builder.ref, ptr_type, "result_ptr");
        const result_len_phi = llvm.c.LLVMBuildPhi(self.builder.ref, i64_type, "result_len");

        // Add phi incoming values
        var entry_values = [_]llvm.ValueRef{ llvm.c.LLVMConstNull(ptr_type), llvm.Const.int64(self.ctx, 0) };
        var entry_blocks = [_]llvm.BasicBlockRef{entry_block};
        llvm.c.LLVMAddIncoming(result_ptr_phi, &entry_values[0], &entry_blocks, 1);
        llvm.c.LLVMAddIncoming(result_len_phi, &entry_values[1], &entry_blocks, 1);

        var loop_values = [_]llvm.ValueRef{ array_ptr, argc_i64 };
        var loop_blocks = [_]llvm.BasicBlockRef{loop_block};
        llvm.c.LLVMAddIncoming(result_ptr_phi, &loop_values[0], &loop_blocks, 1);
        llvm.c.LLVMAddIncoming(result_len_phi, &loop_values[1], &loop_blocks, 1);

        // Build slice struct
        const result_alloca = self.builder.buildAlloca(slice_type, "result");
        const slice_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, result_alloca, 0, "slice_ptr");
        _ = self.builder.buildStore(result_ptr_phi, slice_ptr_field);
        const slice_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, result_alloca, 1, "slice_len");
        _ = self.builder.buildStore(result_len_phi, slice_len_field);

        const result = self.builder.buildLoad(slice_type, result_alloca, "slice_result");
        _ = self.builder.buildRet(result);

        return func;
    }

    /// Generate _klar_args_free function that frees a [String] slice.
    fn emitArgsFreeeFn(self: *Emitter, slice_type: llvm.TypeRef, string_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        const free_fn = self.getOrCreateFreeFn();

        // Create function: void _klar_args_free({ ptr, i64 } args)
        var params = [_]llvm.TypeRef{slice_type};
        const fn_type = llvm.Types.function(llvm.Types.void_(self.ctx), &params, false);
        const func = llvm.addFunction(self.module, "_klar_args_free", fn_type);

        // Create blocks
        const entry_block = llvm.appendBasicBlock(self.ctx, func, "entry");
        const check_block = llvm.appendBasicBlock(self.ctx, func, "check");
        const loop_block = llvm.appendBasicBlock(self.ctx, func, "loop");
        const free_array_block = llvm.appendBasicBlock(self.ctx, func, "free_array");
        const done_block = llvm.appendBasicBlock(self.ctx, func, "done");

        // Entry: extract slice fields
        self.builder.positionAtEnd(entry_block);
        const args = llvm.c.LLVMGetParam(func, 0);
        const array_ptr = llvm.c.LLVMBuildExtractValue(self.builder.ref, args, 0, "array_ptr");
        const len = llvm.c.LLVMBuildExtractValue(self.builder.ref, args, 1, "len");

        // Check if ptr is null or len <= 0
        const is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, array_ptr, llvm.c.LLVMConstNull(ptr_type), "is_null");
        const len_zero = self.builder.buildICmp(llvm.c.LLVMIntSLE, len, llvm.Const.int64(self.ctx, 0), "len_zero");
        const skip_free = self.builder.buildOr(is_null, len_zero, "skip_free");
        _ = self.builder.buildCondBr(skip_free, done_block, check_block);

        // Check block: initialize loop
        self.builder.positionAtEnd(check_block);
        const i_ptr = self.builder.buildAlloca(i64_type, "i");
        _ = self.builder.buildStore(llvm.Const.int64(self.ctx, 0), i_ptr);
        _ = self.builder.buildBr(loop_block);

        // Loop block: free each string's data
        self.builder.positionAtEnd(loop_block);
        const i_val = self.builder.buildLoad(i64_type, i_ptr, "i");

        // Get array[i].ptr
        const string_i_ptr = self.builder.buildGEP(string_type, array_ptr, &[_]llvm.ValueRef{i_val}, "string_i");
        const str_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_i_ptr, 0, "str_ptr_field");
        const str_ptr = self.builder.buildLoad(ptr_type, str_ptr_field, "str_ptr");

        // free(str_ptr) if not null
        const str_is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, str_ptr, llvm.c.LLVMConstNull(ptr_type), "str_null");
        const free_str_block = llvm.appendBasicBlock(self.ctx, func, "free_str");
        const next_iter_block = llvm.appendBasicBlock(self.ctx, func, "next_iter");
        _ = self.builder.buildCondBr(str_is_null, next_iter_block, free_str_block);

        self.builder.positionAtEnd(free_str_block);
        var free_str_args = [_]llvm.ValueRef{str_ptr};
        _ = self.builder.buildCall(
            llvm.Types.function(llvm.Types.void_(self.ctx), &[_]llvm.TypeRef{ptr_type}, false),
            free_fn,
            &free_str_args,
            "",
        );
        _ = self.builder.buildBr(next_iter_block);

        // Next iteration
        self.builder.positionAtEnd(next_iter_block);
        const i_next = self.builder.buildAdd(i_val, llvm.Const.int64(self.ctx, 1), "i_next");
        _ = self.builder.buildStore(i_next, i_ptr);
        const loop_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, i_next, len, "loop_cond");
        _ = self.builder.buildCondBr(loop_cond, loop_block, free_array_block);

        // Free array block
        self.builder.positionAtEnd(free_array_block);
        var free_array_args = [_]llvm.ValueRef{array_ptr};
        _ = self.builder.buildCall(
            llvm.Types.function(llvm.Types.void_(self.ctx), &[_]llvm.TypeRef{ptr_type}, false),
            free_fn,
            &free_array_args,
            "",
        );
        _ = self.builder.buildBr(done_block);

        // Done block
        self.builder.positionAtEnd(done_block);
        _ = self.builder.buildRetVoid();

        return func;
    }

    /// Get or create malloc declaration.
    fn getOrCreateMallocFn(self: *Emitter) llvm.ValueRef {
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, "malloc")) |func| {
            return func;
        }
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var params = [_]llvm.TypeRef{i64_type};
        const fn_type = llvm.Types.function(ptr_type, &params, false);
        return llvm.addFunction(self.module, "malloc", fn_type);
    }

    /// Get or create strlen declaration.
    fn getOrCreateStrlenFn(self: *Emitter) llvm.ValueRef {
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, "strlen")) |func| {
            return func;
        }
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var params = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.Types.function(i64_type, &params, false);
        return llvm.addFunction(self.module, "strlen", fn_type);
    }

    /// Get or create memcpy declaration.
    fn getOrCreateMemcpyFn(self: *Emitter) llvm.ValueRef {
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, "memcpy")) |func| {
            return func;
        }
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var params = [_]llvm.TypeRef{ ptr_type, ptr_type, i64_type };
        const fn_type = llvm.Types.function(ptr_type, &params, false);
        return llvm.addFunction(self.module, "memcpy", fn_type);
    }

    /// Get or create free declaration.
    fn getOrCreateFreeFn(self: *Emitter) llvm.ValueRef {
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, "free")) |func| {
            return func;
        }
        const ptr_type = llvm.Types.pointer(self.ctx);
        var params = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.Types.function(llvm.Types.void_(self.ctx), &params, false);
        return llvm.addFunction(self.module, "free", fn_type);
    }

    /// Get or create snprintf declaration.
    /// int snprintf(char *str, size_t size, const char *format, ...)
    fn getOrCreateSnprintfFn(self: *Emitter) llvm.ValueRef {
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, "snprintf")) |func| {
            return func;
        }
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var params = [_]llvm.TypeRef{ ptr_type, i64_type, ptr_type };
        // variadic = true (1)
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &params, 3, 1);
        return llvm.c.LLVMAddFunction(self.module.ref, "snprintf", fn_type);
    }

    /// Register a struct declaration for later field name resolution.
    fn registerStructDecl(self: *Emitter, struct_decl: *ast.StructDecl) EmitError!void {
        // Skip if already registered
        if (self.struct_types.contains(struct_decl.name)) {
            return;
        }

        // Use getOrCreateStructType to register the struct with field names
        // For packed extern structs, LLVM struct should be packed (no padding)
        _ = try self.getOrCreateStructType(struct_decl.name, struct_decl.fields, struct_decl.is_packed);
    }

    /// Register all struct declarations from a module.
    /// This should be called early, before monomorphized function declarations,
    /// so that struct types are available when building function signatures.
    pub fn registerAllStructDecls(self: *Emitter, module: ast.Module) EmitError!void {
        for (module.declarations) |decl| {
            switch (decl) {
                .struct_decl => |s| try self.registerStructDecl(s),
                else => {},
            }
        }
    }

    fn declareFunction(self: *Emitter, func: *ast.FunctionDecl) EmitError!void {
        // Skip generic functions - they are handled via monomorphization
        if (func.type_params.len > 0) {
            return;
        }

        // Check if this is main(args: [String]) - needs special handling
        const is_main_with_args = std.mem.eql(u8, func.name, "main") and
            func.params.len == 1 and
            self.isStringSliceTypeExpr(func.params[0].type_);

        if (is_main_with_args) {
            self.main_takes_args = true;
        }

        // Check if return type requires sret calling convention
        const needs_sret = if (func.return_type) |rt| self.requiresSretForTypeExpr(rt) else false;
        const return_llvm_type = if (func.return_type) |rt|
            try self.typeExprToLLVM(rt)
        else
            llvm.Types.void_(self.ctx);

        // Build parameter types
        var param_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer param_types.deinit(self.allocator);

        // If sret is needed, add pointer parameter as first param
        if (needs_sret) {
            param_types.append(self.allocator, llvm.Types.pointer(self.ctx)) catch return EmitError.OutOfMemory;
        }

        for (func.params) |param| {
            const param_ty = try self.typeExprToLLVM(param.type_);
            param_types.append(self.allocator, param_ty) catch return EmitError.OutOfMemory;
        }

        // Get return type - void if using sret
        const return_type = if (needs_sret) llvm.Types.void_(self.ctx) else return_llvm_type;

        const fn_type = llvm.Types.function(return_type, param_types.items, false);

        // Use _klar_user_main for main(args: [String]), otherwise use the function name
        const func_name = if (is_main_with_args) "_klar_user_main" else func.name;
        const name = self.allocator.dupeZ(u8, func_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(name);
        const llvm_func = llvm.addFunction(self.module, name, fn_type);

        // Add sret attribute to first parameter if needed
        if (needs_sret) {
            const sret_kind = self.getSretAttrKind();
            const sret_attr = llvm.createTypeAttribute(self.ctx, sret_kind, return_llvm_type);
            llvm.addAttributeAtIndex(llvm_func, 1, sret_attr); // Index 1 = first param

            // Register this function as using sret so call sites can handle it
            const name_copy = self.allocator.dupe(u8, func.name) catch return EmitError.OutOfMemory;
            self.sret_functions.put(name_copy, return_llvm_type) catch return EmitError.OutOfMemory;
        }

        // Set the calling convention for proper ABI compliance
        llvm.setFunctionCallConv(llvm_func, self.calling_convention.toLLVM());
    }

    /// Declare an external C function.
    /// Extern functions use C calling convention and may be variadic.
    /// Applies ABI lowering for struct returns - small structs are returned in registers.
    fn declareExternFunction(self: *Emitter, func: *ast.FunctionDecl) EmitError!void {
        // Extern functions cannot be generic
        if (func.type_params.len > 0) {
            return EmitError.InvalidAST;
        }

        // Build return type, with ABI lowering for structs
        var abi_lowered_return_type: ?llvm.TypeRef = null;
        const return_llvm_type = if (func.return_type) |rt| blk: {
            const original_type = try self.typeExprToLLVM(rt);

            // Check if this is a struct type that needs ABI lowering
            // Look up the struct by name and calculate size
            if (llvm.getTypeKind(original_type) == llvm.c.LLVMStructTypeKind) {
                // Calculate struct size using the layout calculator
                // Get the struct name from the type expression
                const struct_size: usize = if (self.type_checker) |tc| size_blk: {
                    const type_name: ?[]const u8 = switch (rt) {
                        .named => |n| n.name,
                        else => null,
                    };
                    if (type_name) |name| {
                        if (tc.lookupSymbol(name)) |sym| {
                            if (sym.type_ == .struct_) {
                                const type_layout = self.layout_calc.getTypeLayout(sym.type_);
                                break :size_blk type_layout.size;
                            }
                        }
                    }
                    break :size_blk 0;
                } else 0;

                // On most platforms, small structs (≤ 8 bytes) are returned as integers
                // For arm64-apple and System V x86_64, structs up to 16 bytes can use registers,
                // but for simplicity we treat ≤8 bytes as i64 (single register)
                if (struct_size <= 8 and struct_size > 0) {
                    // Save the original struct type for conversion at call sites
                    abi_lowered_return_type = original_type;

                    // Return as integer type matching the struct size
                    break :blk if (struct_size <= 1)
                        llvm.Types.int8(self.ctx)
                    else if (struct_size <= 2)
                        llvm.Types.int16(self.ctx)
                    else if (struct_size <= 4)
                        llvm.Types.int32(self.ctx)
                    else
                        llvm.Types.int64(self.ctx);
                }
            }
            break :blk original_type;
        } else llvm.Types.void_(self.ctx);

        // Build parameter types with ABI lowering for small structs
        var param_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer param_types.deinit(self.allocator);

        // Track which parameters need ABI lowering (struct -> integer)
        var abi_lowered_params = std.ArrayListUnmanaged(?AbiLoweredParam){};
        defer abi_lowered_params.deinit(self.allocator);

        // Track out parameters
        var out_params: u64 = 0;
        var out_param_types = std.ArrayListUnmanaged(?llvm.TypeRef){};
        defer out_param_types.deinit(self.allocator);

        for (func.params, 0..) |param, i| {
            // For out parameters, we pass a pointer to the type
            if (param.is_out) {
                const out_type = try self.typeExprToLLVM(param.type_);
                param_types.append(self.allocator, llvm.Types.pointer(self.ctx)) catch return EmitError.OutOfMemory;
                abi_lowered_params.append(self.allocator, null) catch return EmitError.OutOfMemory;
                out_param_types.append(self.allocator, out_type) catch return EmitError.OutOfMemory;
                if (i < 64) {
                    out_params |= (@as(u64, 1) << @intCast(i));
                }
            } else {
                out_param_types.append(self.allocator, null) catch return EmitError.OutOfMemory;
                const original_type = try self.typeExprToLLVM(param.type_);

                // Check if this is a struct type that needs ABI lowering
                if (llvm.getTypeKind(original_type) == llvm.c.LLVMStructTypeKind) {
                    // Calculate struct size
                    const struct_size: usize = if (self.type_checker) |tc| size_blk: {
                        const type_name: ?[]const u8 = switch (param.type_) {
                            .named => |n| n.name,
                            else => null,
                        };
                        if (type_name) |pname| {
                            if (tc.lookupSymbol(pname)) |sym| {
                                if (sym.type_ == .struct_) {
                                    const type_layout = self.layout_calc.getTypeLayout(sym.type_);
                                    break :size_blk type_layout.size;
                                }
                            }
                        }
                        break :size_blk 0;
                    } else 0;

                    // On most platforms, small structs (≤ 8 bytes) are passed as integers
                    if (struct_size <= 8 and struct_size > 0) {
                        // Use integer type matching the struct size
                        const lowered_type = if (struct_size <= 1)
                            llvm.Types.int8(self.ctx)
                        else if (struct_size <= 2)
                            llvm.Types.int16(self.ctx)
                        else if (struct_size <= 4)
                            llvm.Types.int32(self.ctx)
                        else
                            llvm.Types.int64(self.ctx);

                        // Save both types for conversion at call sites
                        abi_lowered_params.append(self.allocator, .{
                            .struct_type = original_type,
                            .int_type = lowered_type,
                        }) catch return EmitError.OutOfMemory;

                        param_types.append(self.allocator, lowered_type) catch return EmitError.OutOfMemory;
                    } else {
                        // Large structs are passed as-is (or by pointer depending on ABI)
                        param_types.append(self.allocator, original_type) catch return EmitError.OutOfMemory;
                        abi_lowered_params.append(self.allocator, null) catch return EmitError.OutOfMemory;
                    }
                } else {
                    param_types.append(self.allocator, original_type) catch return EmitError.OutOfMemory;
                    abi_lowered_params.append(self.allocator, null) catch return EmitError.OutOfMemory;
                }
            }
        }

        // Create function type (variadic if func.is_variadic)
        const fn_type = llvm.Types.function(return_llvm_type, param_types.items, func.is_variadic);

        // Add the function declaration to the module
        const name = self.allocator.dupeZ(u8, func.name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(name);
        const llvm_func = llvm.addFunction(self.module, name, fn_type);

        // Use C calling convention for extern functions
        llvm.setFunctionCallConv(llvm_func, 0); // 0 = C calling convention (ccc)

        // Store ABI lowered param info if any params were lowered
        var has_lowered_params = false;
        for (abi_lowered_params.items) |item| {
            if (item != null) {
                has_lowered_params = true;
                break;
            }
        }

        // Check if any out parameters
        var has_out_params = false;
        for (out_param_types.items) |item| {
            if (item != null) {
                has_out_params = true;
                break;
            }
        }

        // Store the function for extern function tracking
        const name_copy = self.allocator.dupe(u8, func.name) catch return EmitError.OutOfMemory;
        self.extern_functions.put(name_copy, .{
            .func = llvm_func,
            .is_variadic = func.is_variadic,
            .abi_lowered_return_type = abi_lowered_return_type,
            .abi_lowered_param_types = if (has_lowered_params)
                (self.allocator.dupe(?AbiLoweredParam, abi_lowered_params.items) catch null)
            else
                null,
            .out_params = out_params,
            .out_param_types = if (has_out_params)
                (self.allocator.dupe(?llvm.TypeRef, out_param_types.items) catch null)
            else
                null,
        }) catch return EmitError.OutOfMemory;
    }

    /// Check if a type expression is [String] (slice of String).
    fn isStringSliceTypeExpr(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        if (type_expr == .slice) {
            const element = type_expr.slice.element;
            if (element == .named) {
                return std.mem.eql(u8, element.named.name, "String");
            }
        }
        return false;
    }

    /// Declare methods from an impl block.
    /// Methods are named StructName_methodName for non-generic structs.
    fn declareImplMethods(self: *Emitter, impl_decl: *ast.ImplDecl) EmitError!void {
        // Skip generic impl blocks - they are handled via monomorphization
        if (impl_decl.type_params.len > 0) {
            return;
        }

        // Get the struct name from the target type
        const struct_name = switch (impl_decl.target_type) {
            .named => |n| n.name,
            .generic_apply => return, // Generic applications are handled via monomorphization
            else => return EmitError.InvalidAST,
        };

        for (impl_decl.methods) |method| {
            // Build the mangled method name: StructName_methodName
            var name_buf = std.ArrayListUnmanaged(u8){};
            defer name_buf.deinit(self.allocator);
            name_buf.appendSlice(self.allocator, struct_name) catch return EmitError.OutOfMemory;
            name_buf.append(self.allocator, '_') catch return EmitError.OutOfMemory;
            name_buf.appendSlice(self.allocator, method.name) catch return EmitError.OutOfMemory;

            const mangled_name = self.allocator.dupeZ(u8, name_buf.items) catch return EmitError.OutOfMemory;
            defer self.allocator.free(mangled_name);

            // Build parameter types
            var param_types = std.ArrayListUnmanaged(llvm.TypeRef){};
            defer param_types.deinit(self.allocator);

            for (method.params) |param| {
                const param_ty = try self.typeExprToLLVM(param.type_);
                param_types.append(self.allocator, param_ty) catch return EmitError.OutOfMemory;
            }

            // Get return type
            const return_type = if (method.return_type) |rt|
                try self.typeExprToLLVM(rt)
            else
                llvm.Types.void_(self.ctx);

            const fn_type = llvm.Types.function(return_type, param_types.items, false);
            const llvm_func = llvm.addFunction(self.module, mangled_name, fn_type);

            // Set the calling convention
            llvm.setFunctionCallConv(llvm_func, self.calling_convention.toLLVM());
        }
    }

    /// Emit method bodies from an impl block.
    fn emitImplMethods(self: *Emitter, impl_decl: *ast.ImplDecl) EmitError!void {
        // Skip generic impl blocks - they are handled via monomorphization
        if (impl_decl.type_params.len > 0) {
            return;
        }

        // Get the struct name from the target type
        const struct_name = switch (impl_decl.target_type) {
            .named => |n| n.name,
            .generic_apply => return,
            else => return EmitError.InvalidAST,
        };

        for (impl_decl.methods) |method| {
            if (method.body == null) continue;

            // Build the mangled method name
            var name_buf = std.ArrayListUnmanaged(u8){};
            defer name_buf.deinit(self.allocator);
            name_buf.appendSlice(self.allocator, struct_name) catch return EmitError.OutOfMemory;
            name_buf.append(self.allocator, '_') catch return EmitError.OutOfMemory;
            name_buf.appendSlice(self.allocator, method.name) catch return EmitError.OutOfMemory;

            const mangled_name = self.allocator.dupeZ(u8, name_buf.items) catch return EmitError.OutOfMemory;
            defer self.allocator.free(mangled_name);

            // Get the declared function
            const function = self.module.getNamedFunction(mangled_name) orelse return EmitError.InvalidAST;
            self.current_function = function;

            // Set up return type info
            if (method.return_type) |rt| {
                const llvm_rt = try self.typeExprToLLVM(rt);
                const is_opt = rt == .optional or (rt == .generic_apply and
                    rt.generic_apply.base == .named and
                    std.mem.eql(u8, rt.generic_apply.base.named.name, "Option"));
                // Check for Result[T, E] which is parsed as generic_apply
                const is_res = rt == .result or (rt == .generic_apply and
                    rt.generic_apply.base == .named and
                    std.mem.eql(u8, rt.generic_apply.base.named.name, "Result"));

                // Extract inner types based on representation
                var inner_type: ?llvm.TypeRef = null;
                var ok_type: ?llvm.TypeRef = null;
                var err_type: ?llvm.TypeRef = null;

                if (is_opt) {
                    if (rt == .optional) {
                        inner_type = try self.typeExprToLLVM(rt.optional.inner);
                    } else if (rt == .generic_apply and rt.generic_apply.args.len >= 1) {
                        inner_type = try self.typeExprToLLVM(rt.generic_apply.args[0]);
                    }
                }
                if (is_res) {
                    if (rt == .result) {
                        ok_type = try self.typeExprToLLVM(rt.result.ok_type);
                        err_type = try self.typeExprToLLVM(rt.result.err_type);
                    } else if (rt == .generic_apply and rt.generic_apply.args.len >= 2) {
                        ok_type = try self.typeExprToLLVM(rt.generic_apply.args[0]);
                        err_type = try self.typeExprToLLVM(rt.generic_apply.args[1]);
                    }
                }

                self.current_return_type = .{
                    .llvm_type = llvm_rt,
                    .is_optional = is_opt,
                    .is_result = is_res,
                    .inner_type = inner_type,
                    .ok_type = ok_type,
                    .err_type = err_type,
                };
                self.current_return_klar_type = self.resolveExpectedType(rt);
            } else {
                self.current_return_type = null;
                self.current_return_klar_type = null;
            }
            defer self.current_return_type = null;
            defer self.current_return_klar_type = null;

            // Create entry block
            const entry = llvm.appendBasicBlock(self.ctx, function, "entry");
            self.builder.positionAtEnd(entry);
            self.has_terminator = false;

            // Clear named values for the new function
            self.named_values.clearRetainingCapacity();

            // Add parameters to named values
            for (method.params, 0..) |param, i| {
                const param_value = llvm.getParam(function, @intCast(i));
                const param_ty = try self.typeExprToLLVM(param.type_);

                const param_name = self.allocator.dupeZ(u8, param.name) catch return EmitError.OutOfMemory;
                defer self.allocator.free(param_name);

                const alloca = self.builder.buildAlloca(param_ty, param_name);
                _ = self.builder.buildStore(param_value, alloca);

                // Determine if parameter is signed
                const is_signed = self.isTypeExprSigned(param.type_);

                // For struct type parameters, record the struct type name for field resolution
                // For reference parameters (&Self or &mut Self), extract the inner struct name
                const param_struct_name: ?[]const u8 = switch (param.type_) {
                    .named => |n| n.name,
                    .reference => |ref| blk: {
                        // For self parameter, use the impl block's struct name
                        if (std.mem.eql(u8, param.name, "self")) {
                            break :blk struct_name;
                        }
                        // For other reference params, try to get inner type name
                        break :blk switch (ref.inner) {
                            .named => |n| n.name,
                            else => null,
                        };
                    },
                    else => null,
                };

                // Check if this is a reference parameter
                const is_ref = param.type_ == .reference;
                const ref_inner_type: ?llvm.TypeRef = if (is_ref) blk: {
                    // For self parameter, use the struct type from struct_name directly
                    // This handles the case where the type is "Self" which isn't a registered type
                    if (std.mem.eql(u8, param.name, "self")) {
                        if (self.struct_types.get(struct_name)) |struct_info| {
                            break :blk struct_info.llvm_type;
                        }
                    }
                    break :blk try self.typeExprToLLVM(param.type_.reference.inner);
                } else null;

                // Check if this is an array type parameter (for field access on array elements)
                const is_array = param.type_ == .array or param.type_ == .slice;
                const array_info = self.getArrayTypeInfo(param.type_);

                self.named_values.put(param.name, .{
                    .value = alloca,
                    .is_alloca = true,
                    .ty = param_ty,
                    .is_signed = is_signed,
                    .struct_type_name = param_struct_name,
                    .is_reference = is_ref,
                    .reference_inner_type = ref_inner_type,
                    .is_array = is_array,
                    .array_size = if (array_info) |ai| ai.size else null,
                    .array_element_type = if (array_info) |ai| ai.element_type else null,
                }) catch return EmitError.OutOfMemory;
            }

            // Emit function body
            try self.pushScope(false);

            const result = try self.emitBlock(method.body.?);

            // Handle return
            if (!self.has_terminator) {
                if (method.return_type == null) {
                    self.emitDropsForReturn();
                    _ = self.builder.buildRetVoid();
                } else if (result) |val| {
                    if (self.current_return_type) |rt_info| {
                        if (rt_info.is_optional) {
                            self.emitDropsForReturn();
                            const wrapped = self.emitSome(val, rt_info.inner_type.?);
                            _ = self.builder.buildRet(wrapped);
                        } else {
                            self.emitDropsForReturn();
                            _ = self.builder.buildRet(val);
                        }
                    } else {
                        self.emitDropsForReturn();
                        _ = self.builder.buildRet(val);
                    }
                } else if (self.current_return_type) |rt_info| {
                    if (rt_info.is_optional) {
                        // Return None for optional type with no value
                        self.emitDropsForReturn();
                        const none_val = self.emitNone(rt_info.llvm_type);
                        _ = self.builder.buildRet(none_val);
                    } else {
                        self.emitDropsForReturn();
                        _ = self.builder.buildRetVoid();
                    }
                } else {
                    self.emitDropsForReturn();
                    _ = self.builder.buildRetVoid();
                }
            }

            self.popScope();
        }

        self.current_function = null;
    }

    fn emitFunction(self: *Emitter, func: *ast.FunctionDecl) EmitError!void {
        // Skip generic functions - they are handled via monomorphization
        if (func.type_params.len > 0) {
            return;
        }

        // Check if this is main(args: [String]) - look up _klar_user_main instead
        const is_main_with_args = std.mem.eql(u8, func.name, "main") and
            func.params.len == 1 and
            self.isStringSliceTypeExpr(func.params[0].type_);

        const func_name = if (is_main_with_args) "_klar_user_main" else func.name;
        const name = self.allocator.dupeZ(u8, func_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(name);

        // Get or create function
        const function = self.module.getNamedFunction(name) orelse return EmitError.InvalidAST;
        self.current_function = function;

        // Set up return type info
        if (func.return_type) |rt| {
            const llvm_rt = try self.typeExprToLLVM(rt);
            const is_opt = rt == .optional or (rt == .generic_apply and
                rt.generic_apply.base == .named and
                std.mem.eql(u8, rt.generic_apply.base.named.name, "Option"));
            // Check for Result[T, E] which is parsed as generic_apply
            const is_res = rt == .result or (rt == .generic_apply and
                rt.generic_apply.base == .named and
                std.mem.eql(u8, rt.generic_apply.base.named.name, "Result"));

            // Extract inner types based on representation
            var inner_type: ?llvm.TypeRef = null;
            var ok_type: ?llvm.TypeRef = null;
            var err_type: ?llvm.TypeRef = null;

            if (is_opt) {
                if (rt == .optional) {
                    inner_type = try self.typeExprToLLVM(rt.optional.inner);
                } else if (rt == .generic_apply and rt.generic_apply.args.len >= 1) {
                    inner_type = try self.typeExprToLLVM(rt.generic_apply.args[0]);
                }
            }
            if (is_res) {
                if (rt == .result) {
                    ok_type = try self.typeExprToLLVM(rt.result.ok_type);
                    err_type = try self.typeExprToLLVM(rt.result.err_type);
                } else if (rt == .generic_apply and rt.generic_apply.args.len >= 2) {
                    ok_type = try self.typeExprToLLVM(rt.generic_apply.args[0]);
                    err_type = try self.typeExprToLLVM(rt.generic_apply.args[1]);
                }
            }

            self.current_return_type = .{
                .llvm_type = llvm_rt,
                .is_optional = is_opt,
                .is_result = is_res,
                .inner_type = inner_type,
                .ok_type = ok_type,
                .err_type = err_type,
            };
            self.current_return_klar_type = self.resolveExpectedType(rt);
        } else {
            self.current_return_type = null;
            self.current_return_klar_type = null;
        }
        defer self.current_return_type = null;
        defer self.current_return_klar_type = null;

        // Create debug info for function if enabled
        if (self.di_builder) |di_builder| {
            if (self.di_file) |di_file| {
                // Create subroutine type (empty for now - just void return for simplicity)
                const subroutine_type = di_builder.createSubroutineType(
                    di_file,
                    &.{}, // empty param types
                    llvm.c.LLVMDIFlagZero,
                );

                // Get line number from function span
                const line_no: c_uint = @intCast(func.span.line);

                // Create function debug info
                const subprogram = di_builder.createFunction(
                    self.di_compile_unit.?, // scope (compile unit)
                    func.name, // name
                    func.name, // linkage name
                    di_file, // file
                    line_no, // line number
                    subroutine_type, // type
                    false, // is local
                    true, // is definition
                    line_no, // scope line
                    llvm.c.LLVMDIFlagZero, // flags
                    false, // is optimized
                );

                // Attach subprogram to function
                llvm.setSubprogram(function, subprogram);

                // Set as current scope for debug locations
                self.di_scope = subprogram;
            }
        }

        // Create entry block
        const entry = llvm.appendBasicBlock(self.ctx, function, "entry");
        self.builder.positionAtEnd(entry);
        self.has_terminator = false;

        // Set debug location for entry block if debug info enabled
        if (self.di_builder != null) {
            if (self.di_scope) |scope| {
                const loc = llvm.createDebugLocation(
                    self.ctx,
                    @intCast(func.span.line),
                    @intCast(func.span.column),
                    scope,
                    null,
                );
                llvm.setCurrentDebugLocation(self.builder, loc);
            }
        }

        // Clear named values for new scope
        self.named_values.clearRetainingCapacity();

        // Check if return type requires sret calling convention
        const needs_sret = if (func.return_type) |rt| self.requiresSretForTypeExpr(rt) else false;

        // Handle sret parameter if needed
        // First LLVM param is the sret pointer, user params start at index 1
        const param_offset: u32 = if (needs_sret) 1 else 0;
        if (needs_sret) {
            self.current_sret_ptr = llvm.getParam(function, 0);
        } else {
            self.current_sret_ptr = null;
        }
        defer self.current_sret_ptr = null;

        // Add parameters to named values
        for (func.params, 0..) |param, i| {
            const param_value = llvm.getParam(function, @intCast(i + param_offset));
            const param_ty = try self.typeExprToLLVM(param.type_);

            // Allocate stack space for parameter
            const param_name = self.allocator.dupeZ(u8, param.name) catch return EmitError.OutOfMemory;
            defer self.allocator.free(param_name);

            const alloca = self.builder.buildAlloca(param_ty, param_name);
            _ = self.builder.buildStore(param_value, alloca);

            const is_signed = self.isTypeSigned(param.type_);

            // For struct type parameters, record the struct type name for field resolution
            // For reference parameters, we need to track that the alloca contains a pointer
            const param_struct_name: ?[]const u8 = switch (param.type_) {
                .named => |n| n.name,
                .reference => |ref| switch (ref.inner) {
                    .named => |n| n.name,
                    else => null,
                },
                else => null,
            };

            // Check if this is a reference parameter
            const is_ref = param.type_ == .reference;
            const ref_inner_type: ?llvm.TypeRef = if (is_ref) blk: {
                // Get the LLVM type for the pointed-to struct
                break :blk try self.typeExprToLLVM(param.type_.reference.inner);
            } else null;

            // Check if this is an array type parameter (for field access on array elements)
            const is_array = param.type_ == .array or param.type_ == .slice;
            const array_info = self.getArrayTypeInfo(param.type_);

            // Check if this is a string type parameter
            const is_string = self.isTypeString(param.type_);

            self.named_values.put(param.name, .{
                .value = alloca,
                .is_alloca = true,
                .ty = param_ty,
                .is_signed = is_signed,
                .struct_type_name = param_struct_name,
                .is_reference = is_ref,
                .reference_inner_type = ref_inner_type,
                .is_array = is_array,
                .array_size = if (array_info) |ai| ai.size else null,
                .array_element_type = if (array_info) |ai| ai.element_type else null,
                .is_string = is_string,
            }) catch return EmitError.OutOfMemory;
        }

        // Emit function body
        if (func.body) |body| {
            // Push function scope for drop tracking
            try self.pushScope(false);

            const result = try self.emitBlock(body);

            // If block has a value and we haven't terminated, return it
            if (!self.has_terminator) {
                if (func.return_type == null) {
                    // Void function - always emit void return, ignore any expression value
                    // (e.g., if-without-else returns a placeholder that we discard)
                    self.emitDropsForReturn();
                    _ = self.builder.buildRetVoid();
                } else if (result) |val| {
                    // Handle sret: store to sret pointer and return void
                    if (self.current_sret_ptr) |sret_ptr| {
                        self.emitDropsForReturn();
                        _ = self.builder.buildStore(val, sret_ptr);
                        _ = self.builder.buildRetVoid();
                    } else if (self.current_return_type) |rt_info| {
                        // If return type is optional and value isn't already optional, wrap in Some
                        if (rt_info.is_optional) {
                            const val_type = llvm.typeOf(val);
                            const val_kind = llvm.getTypeKind(val_type);
                            // Check if value is already an optional (struct with our layout)
                            if (val_kind != llvm.c.LLVMStructTypeKind or
                                llvm.c.LLVMCountStructElementTypes(val_type) != 2)
                            {
                                // Not an optional, wrap in Some
                                self.emitDropsForReturn();
                                const some_val = self.emitSome(val, rt_info.inner_type.?);
                                _ = self.builder.buildRet(some_val);
                                self.popScope();
                                self.current_function = null;
                                return;
                            }
                        }
                        self.emitDropsForReturn();
                        _ = self.builder.buildRet(val);
                    } else {
                        self.emitDropsForReturn();
                        _ = self.builder.buildRet(val);
                    }
                } else if (self.current_return_type) |rt_info| {
                    if (rt_info.is_optional) {
                        // Return None for optional type with no value
                        self.emitDropsForReturn();
                        const none_val = self.emitNone(rt_info.llvm_type);
                        if (self.current_sret_ptr) |sret_ptr| {
                            _ = self.builder.buildStore(none_val, sret_ptr);
                            _ = self.builder.buildRetVoid();
                        } else {
                            _ = self.builder.buildRet(none_val);
                        }
                    } else {
                        self.emitDropsForReturn();
                        _ = self.builder.buildRetVoid();
                    }
                } else {
                    // Return type specified but no value - emit void return
                    self.emitDropsForReturn();
                    _ = self.builder.buildRetVoid();
                }
            }

            // Pop the function scope - just cleanup, drops already emitted
            // Note: when we reach here from the non-terminator path, drops were emitted by emitDropsForReturn
            // When we reach here from the terminator path (has_terminator), drops were emitted by the statement
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        self.current_function = null;
    }

    fn emitBlock(self: *Emitter, block: *ast.Block) EmitError!?llvm.ValueRef {
        // Emit statements
        for (block.statements) |stmt| {
            try self.emitStmt(stmt);
            if (self.has_terminator) {
                // Don't emit unreachable code after terminators
                return null;
            }
        }

        // Return final expression value if present
        if (block.final_expr) |expr| {
            return try self.emitExpr(expr);
        }

        return null;
    }

    fn emitStmt(self: *Emitter, stmt: ast.Stmt) EmitError!void {
        switch (stmt) {
            .let_decl => |decl| {
                // Set expected type context from annotation for constructors like Ok/Err
                const prev_expected = self.expected_type;
                self.expected_type = self.resolveExpectedType(decl.type_);
                defer self.expected_type = prev_expected;

                // Check if this is a slice type with an array literal value
                // In this case, we need to convert the array to a slice
                const is_slice_decl = decl.type_ == .slice;
                const is_array_literal_value = decl.value == .array_literal;

                // Determine the LLVM type for the alloca
                // Prefer using the declared type annotation for accurate types
                // This is important for method calls like char.to_string() which return different
                // types than might be inferred from the LLVM representation alone
                const ty = blk: {
                    // Try to use type annotation first
                    const llvm_ty = self.typeExprToLLVM(decl.type_) catch null;
                    if (llvm_ty) |t| break :blk t;
                    // Fall back to inference from expression
                    break :blk try self.inferExprType(decl.value);
                };

                const name = self.allocator.dupeZ(u8, decl.name) catch return EmitError.OutOfMemory;
                defer self.allocator.free(name);
                // Create alloca in entry block to prevent stack growth in loops
                const alloca = self.buildEntryBlockAlloca(ty, name);

                // Check for large @repeat - use direct initialization to avoid stack overflow
                if (self.tryGetLargeRepeatInfo(decl.value)) |repeat_info| {
                    // Initialize directly into the alloca without intermediate load/store
                    try self.emitRepeatInto(repeat_info, alloca);
                } else if (is_slice_decl and is_array_literal_value) {
                    // Convert array literal to slice: create array alloca, then build slice struct
                    const arr_lit = decl.value.array_literal;
                    const array_value = try self.emitExpr(decl.value);
                    const array_type = llvm.typeOf(array_value);

                    // Store the array in an alloca so we can get a pointer to it
                    const array_alloca = self.builder.buildAlloca(array_type, "arr.storage");
                    _ = self.builder.buildStore(array_value, array_alloca);

                    // Convert to slice and store in the slice alloca
                    const slice_value = self.convertArrayToSlice(array_alloca, arr_lit.elements.len);
                    _ = self.builder.buildStore(slice_value, alloca);
                } else {
                    // Normal path: emit value and store
                    const value = try self.emitExpr(decl.value);
                    _ = self.builder.buildStore(value, alloca);
                }
                const is_signed = self.isTypeSigned(decl.type_);
                // Extract struct type name - try expression first, then type annotation
                const struct_type_name = self.getStructTypeName(decl.value) orelse
                    self.getStructTypeNameFromAnnotation(decl.type_);
                // For Rc/Arc types, track the inner type for dereferencing
                const inner_type = self.tryGetRcInnerType(decl.value);
                const is_arc = self.isArcType(decl.value);
                // For closure types, extract return type and param types from annotation
                const closure_info = self.tryGetClosureTypeInfo(decl.type_);
                // Check if this is a string type
                const is_string = self.isTypeString(decl.type_);
                // Check if this is a heap-allocated String type
                const is_string_data = self.isTypeStringData(decl.type_);
                // Check if this is an array or slice type
                const is_array = self.isTypeArray(decl.type_);
                const array_info = self.getArrayTypeInfo(decl.type_);
                // Check if this is a List type
                const list_element_type = self.getListTypeInfo(decl.type_);
                // Check if this is a Map type
                const map_info = self.getMapTypeInfo(decl.type_);
                // Check if this is a Set type
                const set_info = self.getSetTypeInfo(decl.type_);
                // Check if this is an I/O type
                const is_file_let = self.isTypeFile(decl.type_);
                const is_stdout_let = self.isTypeStdout(decl.type_);
                const is_stderr_let = self.isTypeStderr(decl.type_);
                const is_stdin_let = self.isTypeStdin(decl.type_);
                // Check if this is a buffered I/O type
                const is_buf_reader_let = self.isTypeBufReader(decl.type_);
                const is_buf_writer_let = self.isTypeBufWriter(decl.type_);
                // Check if this is a CStrOwned type (needs free on drop)
                const is_cstr_owned_let = self.isTypeCstrOwned(decl.type_);
                // Resolve semantic type for pattern matching (Result, Optional, etc.)
                const semantic_type = self.resolveTypeExprDirect(decl.type_);
                self.named_values.put(decl.name, .{
                    .value = alloca,
                    .is_alloca = true,
                    .ty = ty,
                    .is_signed = is_signed,
                    .struct_type_name = struct_type_name,
                    .inner_type = inner_type,
                    .is_arc = is_arc,
                    .closure_return_type = if (closure_info) |ci| ci.return_type else null,
                    .closure_param_types = if (closure_info) |ci| ci.param_types else null,
                    .is_string = is_string,
                    .is_string_data = is_string_data,
                    .is_array = is_array,
                    .array_size = if (array_info) |ai| ai.size else null,
                    .array_element_type = if (array_info) |ai| ai.element_type else null,
                    .list_element_type = list_element_type,
                    .is_map = map_info != null,
                    .map_key_type = if (map_info) |mi| mi.key_type else null,
                    .map_value_type = if (map_info) |mi| mi.value_type else null,
                    .is_set = set_info != null,
                    .set_element_type = set_info,
                    .is_file = is_file_let,
                    .is_stdout = is_stdout_let,
                    .is_stderr = is_stderr_let,
                    .is_stdin = is_stdin_let,
                    .is_buf_reader = is_buf_reader_let,
                    .is_buf_writer = is_buf_writer_let,
                    .semantic_type = semantic_type,
                }) catch return EmitError.OutOfMemory;

                // Register Rc/Arc variables for automatic dropping
                if (inner_type) |it| {
                    try self.registerDroppable(decl.name, alloca, it, true, is_arc);
                }

                // Register BufWriter variables for automatic flushing on drop
                if (is_buf_writer_let) {
                    try self.registerBufWriterDroppable(decl.name, alloca);
                }

                // Register CStrOwned variables for automatic free on drop
                if (is_cstr_owned_let) {
                    try self.registerCstrOwnedDroppable(decl.name, alloca);
                }
            },
            .var_decl => |decl| {
                // Set expected type context from annotation for constructors like Ok/Err
                const prev_expected = self.expected_type;
                self.expected_type = self.resolveExpectedType(decl.type_);
                defer self.expected_type = prev_expected;

                // Check if this is a slice type with an array literal value
                // In this case, we need to convert the array to a slice
                const is_slice_decl = decl.type_ == .slice;
                const is_array_literal_value = decl.value == .array_literal;

                // Determine the LLVM type for the alloca
                // For slice types, use the declared slice type (not the array literal type)
                const ty = if (is_slice_decl)
                    try self.typeExprToLLVM(decl.type_)
                else
                    try self.inferExprType(decl.value);

                const name = self.allocator.dupeZ(u8, decl.name) catch return EmitError.OutOfMemory;
                defer self.allocator.free(name);
                // Create alloca in entry block to prevent stack growth in loops
                const alloca = self.buildEntryBlockAlloca(ty, name);

                // Check for large @repeat - use direct initialization to avoid stack overflow
                if (self.tryGetLargeRepeatInfo(decl.value)) |repeat_info| {
                    // Initialize directly into the alloca without intermediate load/store
                    try self.emitRepeatInto(repeat_info, alloca);
                } else if (is_slice_decl and is_array_literal_value) {
                    // Convert array literal to slice: create array alloca, then build slice struct
                    const arr_lit = decl.value.array_literal;
                    const array_value = try self.emitExpr(decl.value);
                    const array_type = llvm.typeOf(array_value);

                    // Store the array in an alloca so we can get a pointer to it
                    const array_alloca = self.builder.buildAlloca(array_type, "arr.storage");
                    _ = self.builder.buildStore(array_value, array_alloca);

                    // Convert to slice and store in the slice alloca
                    const slice_value = self.convertArrayToSlice(array_alloca, arr_lit.elements.len);
                    _ = self.builder.buildStore(slice_value, alloca);
                } else {
                    // Normal path: emit value and store
                    const value = try self.emitExpr(decl.value);
                    _ = self.builder.buildStore(value, alloca);
                }
                const is_signed = self.isTypeSigned(decl.type_);
                // Extract struct type name - try expression first, then type annotation
                const struct_type_name = self.getStructTypeName(decl.value) orelse
                    self.getStructTypeNameFromAnnotation(decl.type_);
                // For Rc/Arc types, track the inner type for dereferencing
                const inner_type = self.tryGetRcInnerType(decl.value);
                const is_arc = self.isArcType(decl.value);
                // For closure types, extract return type and param types from annotation
                const closure_info = self.tryGetClosureTypeInfo(decl.type_);
                // Check if this is a string type
                const is_string = self.isTypeString(decl.type_);
                // Check if this is a heap-allocated String type
                const is_string_data = self.isTypeStringData(decl.type_);
                // Check if this is an array or slice type
                const is_array = self.isTypeArray(decl.type_);
                const array_info = self.getArrayTypeInfo(decl.type_);
                // Check if this is a List type
                const list_element_type = self.getListTypeInfo(decl.type_);
                // Check if this is a Map type
                const map_info = self.getMapTypeInfo(decl.type_);
                // Check if this is a Set type
                const set_info = self.getSetTypeInfo(decl.type_);
                // Check if this is an I/O type
                const is_file = self.isTypeFile(decl.type_);
                const is_stdout = self.isTypeStdout(decl.type_);
                const is_stderr = self.isTypeStderr(decl.type_);
                const is_stdin = self.isTypeStdin(decl.type_);
                // Check if this is a buffered I/O type
                const is_buf_reader = self.isTypeBufReader(decl.type_);
                const is_buf_writer = self.isTypeBufWriter(decl.type_);
                // Check if this is a CStrOwned type (needs free on drop)
                const is_cstr_owned = self.isTypeCstrOwned(decl.type_);
                // Resolve semantic type for pattern matching (Result, Optional, etc.)
                const semantic_type = self.resolveTypeExprDirect(decl.type_);
                self.named_values.put(decl.name, .{
                    .value = alloca,
                    .is_alloca = true,
                    .ty = ty,
                    .is_signed = is_signed,
                    .struct_type_name = struct_type_name,
                    .inner_type = inner_type,
                    .is_arc = is_arc,
                    .closure_return_type = if (closure_info) |ci| ci.return_type else null,
                    .closure_param_types = if (closure_info) |ci| ci.param_types else null,
                    .is_string = is_string,
                    .is_string_data = is_string_data,
                    .is_array = is_array,
                    .array_size = if (array_info) |ai| ai.size else null,
                    .array_element_type = if (array_info) |ai| ai.element_type else null,
                    .list_element_type = list_element_type,
                    .is_map = map_info != null,
                    .map_key_type = if (map_info) |mi| mi.key_type else null,
                    .map_value_type = if (map_info) |mi| mi.value_type else null,
                    .is_set = set_info != null,
                    .set_element_type = set_info,
                    .is_file = is_file,
                    .is_stdout = is_stdout,
                    .is_stderr = is_stderr,
                    .is_stdin = is_stdin,
                    .is_buf_reader = is_buf_reader,
                    .is_buf_writer = is_buf_writer,
                    .semantic_type = semantic_type,
                }) catch return EmitError.OutOfMemory;

                // Register Rc/Arc variables for automatic dropping
                if (inner_type) |it| {
                    try self.registerDroppable(decl.name, alloca, it, true, is_arc);
                }

                // Register BufWriter variables for automatic flushing on drop
                if (is_buf_writer) {
                    try self.registerBufWriterDroppable(decl.name, alloca);
                }

                // Register CStrOwned variables for automatic free on drop
                if (is_cstr_owned) {
                    try self.registerCstrOwnedDroppable(decl.name, alloca);
                }
            },
            .return_stmt => |ret| {
                // Emit drops for all variables before returning
                self.emitDropsForReturn();

                if (ret.value) |val| {
                    // Set expected type from return type for Ok/Err inference
                    const prev_expected = self.expected_type;
                    self.expected_type = self.current_return_klar_type;
                    defer self.expected_type = prev_expected;

                    var result = try self.emitExpr(val);
                    // If return type is optional, wrap value in Some if needed
                    if (self.current_return_type) |rt_info| {
                        if (rt_info.is_optional) {
                            const val_type = llvm.typeOf(result);
                            const val_kind = llvm.getTypeKind(val_type);
                            // Check if value is already an optional (struct with our layout)
                            if (val_kind != llvm.c.LLVMStructTypeKind or
                                llvm.c.LLVMCountStructElementTypes(val_type) != 2)
                            {
                                // Not an optional, wrap in Some
                                result = self.emitSome(result, rt_info.inner_type.?);
                            }
                        }
                    }
                    // If using sret, store to sret pointer and return void
                    if (self.current_sret_ptr) |sret_ptr| {
                        _ = self.builder.buildStore(result, sret_ptr);
                        _ = self.builder.buildRetVoid();
                    } else {
                        _ = self.builder.buildRet(result);
                    }
                } else {
                    // Return with no value
                    if (self.current_return_type) |rt_info| {
                        if (rt_info.is_optional) {
                            // Return None for optional type
                            const none_val = self.emitNone(rt_info.llvm_type);
                            if (self.current_sret_ptr) |sret_ptr| {
                                _ = self.builder.buildStore(none_val, sret_ptr);
                                _ = self.builder.buildRetVoid();
                            } else {
                                _ = self.builder.buildRet(none_val);
                            }
                        } else {
                            _ = self.builder.buildRetVoid();
                        }
                    } else {
                        _ = self.builder.buildRetVoid();
                    }
                }
                self.has_terminator = true;
            },
            .expr_stmt => |expr_stmt| {
                _ = try self.emitExpr(expr_stmt.expr);
            },
            .assignment => |assign| {
                // Handle assignment statements (legacy path - parser now uses binary with .assign op)
                const value = try self.emitExpr(assign.value);
                switch (assign.target) {
                    .identifier => |id| {
                        if (self.named_values.get(id.name)) |local| {
                            if (local.is_alloca) {
                                _ = self.builder.buildStore(value, local.value);
                            }
                        }
                    },
                    else => {},
                }
            },
            .while_loop => |loop| {
                try self.emitWhileLoop(loop);
            },
            .for_loop => |loop| {
                try self.emitForLoop(loop);
            },
            .loop_stmt => |loop| {
                try self.emitInfiniteLoop(loop);
            },
            .break_stmt => {
                try self.emitBreak();
            },
            .continue_stmt => {
                try self.emitContinue();
            },
            .if_stmt => |if_stmt| {
                try self.emitIfStmt(if_stmt);
            },
            .match_stmt => |match_stmt| {
                try self.emitMatchStmt(match_stmt);
            },
        }
    }

    fn emitWhileLoop(self: *Emitter, loop: *ast.WhileLoop) EmitError!void {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Create blocks
        const cond_bb = llvm.appendBasicBlock(self.ctx, func, "while.cond");
        const body_bb = llvm.appendBasicBlock(self.ctx, func, "while.body");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "while.end");

        // Push loop context for break/continue
        self.loop_stack.append(self.allocator, .{
            .continue_block = cond_bb,
            .break_block = end_bb,
        }) catch return EmitError.OutOfMemory;
        defer _ = self.loop_stack.pop();

        // Branch to condition
        _ = self.builder.buildBr(cond_bb);

        // Emit condition
        self.builder.positionAtEnd(cond_bb);
        const cond = try self.emitExpr(loop.condition);
        _ = self.builder.buildCondBr(cond, body_bb, end_bb);

        // Emit body with loop scope for drop tracking
        self.builder.positionAtEnd(body_bb);
        self.has_terminator = false;
        try self.pushScope(true); // is_loop = true
        _ = try self.emitBlock(loop.body);
        if (!self.has_terminator) {
            // Emit drops for variables declared in this iteration before looping back
            self.popScope();
            _ = self.builder.buildBr(cond_bb);
        } else {
            // Terminator already emitted (break/continue/return)
            // Drops were already emitted by the terminator, just clean up scope without emitting
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        // Continue after loop
        self.builder.positionAtEnd(end_bb);
        self.has_terminator = false;
    }

    fn emitForLoop(self: *Emitter, loop: *ast.ForLoop) EmitError!void {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Check for Map iteration with tuple pattern: for (k, v) in map { ... }
        if (loop.pattern == .tuple_pattern) {
            if (self.isMapExpr(loop.iterable)) {
                try self.emitForLoopMap(func, loop.pattern.tuple_pattern, loop.iterable, loop.body);
                return;
            }
            return EmitError.UnsupportedFeature; // Tuple patterns only for Map for now
        }

        // Get the binding name from the pattern
        const binding_name = switch (loop.pattern) {
            .binding => |b| b.name,
            else => return EmitError.UnsupportedFeature, // Only simple bindings for now
        };

        // Check if iterable is a range literal (fast path) or Range[T] type (iterator protocol)
        switch (loop.iterable) {
            .range => |range| {
                // Fast path for range literals: for i in start..end { body }
                try self.emitForLoopRangeLiteral(func, binding_name, range, loop.body);
            },
            else => {
                // Check if the iterable is a Range[T] type (e.g., a variable of type Range[i32])
                if (self.isRangeExpr(loop.iterable)) {
                    try self.emitForLoopRangeIterator(func, binding_name, loop.iterable, loop.body);
                } else if (self.isSliceExpr(loop.iterable)) {
                    // Slice iteration: for x in slice { body }
                    try self.emitForLoopSlice(func, binding_name, loop.iterable, loop.body);
                } else if (self.isArrayExpr(loop.iterable)) {
                    // Fixed array iteration: for x in arr { body }
                    try self.emitForLoopArray(func, binding_name, loop.iterable, loop.body);
                } else if (self.isListExpr(loop.iterable)) {
                    // List iteration: for x in list { body }
                    try self.emitForLoopList(func, binding_name, loop.iterable, loop.body);
                } else if (self.isSetExpr(loop.iterable)) {
                    // Set iteration: for x in set { body }
                    try self.emitForLoopSet(func, binding_name, loop.iterable, loop.body);
                } else {
                    return EmitError.UnsupportedFeature;
                }
            },
        }
    }

    /// Emit for-loop for range literals using direct index iteration (fast path).
    fn emitForLoopRangeLiteral(
        self: *Emitter,
        func: llvm.ValueRef,
        binding_name: []const u8,
        range: *ast.Range,
        body: *ast.Block,
    ) EmitError!void {
        // For range literals: for i in start..end { body }
        // We emit this as:
        //   %i = alloca i32
        //   store start, %i
        //   br cond
        // cond:
        //   %cur = load %i
        //   %cmp = icmp slt %cur, end
        //   br %cmp, body, end
        // body:
        //   ... loop body ...
        //   %next = add %cur, 1
        //   store %next, %i
        //   br cond
        // end:

        // Range can have optional start/end; default start to 0
        const start_val = if (range.start) |s|
            try self.emitExpr(s)
        else
            llvm.Const.int32(self.ctx, 0);
        const end_val = if (range.end) |e|
            try self.emitExpr(e)
        else
            return EmitError.UnsupportedFeature; // End is required for for loops
        const iter_ty = llvm.Types.int32(self.ctx);

        // Allocate loop variable
        const var_name = self.allocator.dupeZ(u8, binding_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(var_name);
        const iter_alloca = self.builder.buildAlloca(iter_ty, var_name);
        _ = self.builder.buildStore(start_val, iter_alloca);

        // Add loop variable to scope
        self.named_values.put(binding_name, .{
            .value = iter_alloca,
            .is_alloca = true,
            .ty = iter_ty,
            .is_signed = true,
        }) catch return EmitError.OutOfMemory;

        // Create blocks
        const cond_bb = llvm.appendBasicBlock(self.ctx, func, "for.cond");
        const body_bb = llvm.appendBasicBlock(self.ctx, func, "for.body");
        const incr_bb = llvm.appendBasicBlock(self.ctx, func, "for.incr");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "for.end");

        // Push loop context (continue goes to increment, break goes to end)
        self.loop_stack.append(self.allocator, .{
            .continue_block = incr_bb,
            .break_block = end_bb,
        }) catch return EmitError.OutOfMemory;
        defer _ = self.loop_stack.pop();

        // Branch to condition
        _ = self.builder.buildBr(cond_bb);

        // Emit condition: i < end (or i <= end for inclusive)
        self.builder.positionAtEnd(cond_bb);
        const cur_val = self.builder.buildLoad(iter_ty, iter_alloca, "for.cur");
        const cmp = if (range.inclusive)
            self.builder.buildICmp(llvm.c.LLVMIntSLE, cur_val, end_val, "for.cmp")
        else
            self.builder.buildICmp(llvm.c.LLVMIntSLT, cur_val, end_val, "for.cmp");
        _ = self.builder.buildCondBr(cmp, body_bb, end_bb);

        // Emit body with loop scope for drop tracking
        self.builder.positionAtEnd(body_bb);
        self.has_terminator = false;
        try self.pushScope(true); // is_loop = true
        _ = try self.emitBlock(body);
        if (!self.has_terminator) {
            // Emit drops for variables declared in this iteration before continuing
            self.popScope();
            _ = self.builder.buildBr(incr_bb);
        } else {
            // Terminator already emitted (break/continue/return)
            // Drops were already emitted by the terminator, just clean up scope without emitting
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        // Emit increment
        self.builder.positionAtEnd(incr_bb);
        const cur_val2 = self.builder.buildLoad(iter_ty, iter_alloca, "for.cur2");
        const one = llvm.Const.int32(self.ctx, 1);
        const next_val = self.builder.buildAdd(cur_val2, one, "for.next");
        _ = self.builder.buildStore(next_val, iter_alloca);
        _ = self.builder.buildBr(cond_bb);

        // Continue after loop
        self.builder.positionAtEnd(end_bb);
        self.has_terminator = false;

        // Remove loop variable from scope
        _ = self.named_values.remove(binding_name);
    }

    /// Emit for-loop for Range[T] types using the iterator protocol.
    fn emitForLoopRangeIterator(
        self: *Emitter,
        func: llvm.ValueRef,
        binding_name: []const u8,
        iterable: ast.Expr,
        body: *ast.Block,
    ) EmitError!void {
        // For Range[T] iteration via iterator protocol:
        //   var iter = iterable  (or use iterable directly if already a mutable alloca)
        //   loop:
        //     let maybe = iter.next()
        //     if maybe.is_none() { break }
        //     let x = maybe!
        //     ... body ...
        //   end:

        const i32_type = llvm.Types.int32(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);

        // Build range struct type
        var range_fields = [_]llvm.TypeRef{
            i32_type, // start
            i32_type, // end
            i32_type, // current
            i1_type, // inclusive
        };
        const range_ty = llvm.Types.struct_(self.ctx, &range_fields, false);

        // Build Optional[i32] type: { i1 tag, i32 value }
        var opt_fields = [_]llvm.TypeRef{ i1_type, i32_type };
        const opt_ty = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Get pointer to the range (we need to mutate it via .next())
        const range_ptr = try self.getAddressOfRange(iterable, range_ty);

        // Allocate loop variable (element from iterator)
        const var_name = self.allocator.dupeZ(u8, binding_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(var_name);
        const elem_alloca = self.builder.buildAlloca(i32_type, var_name);

        // Add loop variable to scope
        self.named_values.put(binding_name, .{
            .value = elem_alloca,
            .is_alloca = true,
            .ty = i32_type,
            .is_signed = true,
        }) catch return EmitError.OutOfMemory;

        // Create blocks
        const loop_bb = llvm.appendBasicBlock(self.ctx, func, "foriter.loop");
        const body_bb = llvm.appendBasicBlock(self.ctx, func, "foriter.body");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "foriter.end");

        // Push loop context (continue goes to loop header, break goes to end)
        self.loop_stack.append(self.allocator, .{
            .continue_block = loop_bb,
            .break_block = end_bb,
        }) catch return EmitError.OutOfMemory;
        defer _ = self.loop_stack.pop();

        // Branch to loop
        _ = self.builder.buildBr(loop_bb);

        // Loop: call .next() and check for None
        self.builder.positionAtEnd(loop_bb);
        const maybe_val = try self.emitRangeNext(range_ptr);

        // Extract tag (is_some)
        const tag_alloca = self.builder.buildAlloca(opt_ty, "maybe.tmp");
        _ = self.builder.buildStore(maybe_val, tag_alloca);
        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_ty, tag_alloca, 0, "tag.ptr");
        const is_some = self.builder.buildLoad(i1_type, tag_ptr, "is_some");

        // Branch: if is_some goto body, else goto end
        _ = self.builder.buildCondBr(is_some, body_bb, end_bb);

        // Body: extract value and run body
        self.builder.positionAtEnd(body_bb);
        self.has_terminator = false;

        // Extract the value from Some
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_ty, tag_alloca, 1, "val.ptr");
        const elem_val = self.builder.buildLoad(i32_type, val_ptr, "elem");
        _ = self.builder.buildStore(elem_val, elem_alloca);

        // Emit body with loop scope for drop tracking
        try self.pushScope(true); // is_loop = true
        _ = try self.emitBlock(body);
        if (!self.has_terminator) {
            // Emit drops for variables declared in this iteration before continuing
            self.popScope();
            _ = self.builder.buildBr(loop_bb);
        } else {
            // Terminator already emitted (break/continue/return)
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        // Continue after loop
        self.builder.positionAtEnd(end_bb);
        self.has_terminator = false;

        // Remove loop variable from scope
        _ = self.named_values.remove(binding_name);
    }

    /// Get address of a Range expression. If it's an identifier, return its alloca.
    /// If it's a range literal, allocate it and return the alloca.
    fn getAddressOfRange(self: *Emitter, expr: ast.Expr, range_ty: llvm.TypeRef) EmitError!llvm.ValueRef {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.is_alloca) {
                        return local.value;
                    }
                }
                return EmitError.InvalidAST;
            },
            .range => {
                // Emit the range and store it in an alloca
                const range_val = try self.emitExpr(expr);
                const alloca = self.builder.buildAlloca(range_ty, "range.iter");
                _ = self.builder.buildStore(range_val, alloca);
                return alloca;
            },
            else => return EmitError.InvalidAST,
        }
    }

    /// Emit for-loop for arrays using direct index iteration.
    fn emitForLoopArray(
        self: *Emitter,
        func: llvm.ValueRef,
        binding_name: []const u8,
        iterable: ast.Expr,
        body: *ast.Block,
    ) EmitError!void {
        // For array iteration: for x in arr { body }
        // We emit this as:
        //   %idx = alloca i32
        //   store 0, %idx
        //   br cond
        // cond:
        //   %cur = load %idx
        //   %cmp = icmp slt %cur, len
        //   br %cmp, body, end
        // body:
        //   %elem_ptr = gep arr, 0, %cur
        //   %elem = load %elem_ptr
        //   ... loop body using %elem as binding ...
        //   %next = add %cur, 1
        //   store %next, %idx
        //   br cond
        // end:

        // Get the array pointer and its type
        const array_info = try self.getArrayInfo(iterable);
        const array_ptr = array_info.ptr;
        const array_type = array_info.ty;
        const array_len = array_info.len;
        const elem_type = llvm.c.LLVMGetElementType(array_type);

        const i32_type = llvm.Types.int32(self.ctx);

        // Allocate index counter
        const idx_alloca = self.builder.buildAlloca(i32_type, "for.idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);

        // Allocate loop variable (element binding)
        const var_name = self.allocator.dupeZ(u8, binding_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(var_name);
        const elem_alloca = self.builder.buildAlloca(elem_type, var_name);

        // Determine if element type is signed (for integer types)
        const is_signed = self.isSignedType(elem_type);

        // Add loop variable to scope
        self.named_values.put(binding_name, .{
            .value = elem_alloca,
            .is_alloca = true,
            .ty = elem_type,
            .is_signed = is_signed,
        }) catch return EmitError.OutOfMemory;

        // Create blocks
        const cond_bb = llvm.appendBasicBlock(self.ctx, func, "forarr.cond");
        const body_bb = llvm.appendBasicBlock(self.ctx, func, "forarr.body");
        const incr_bb = llvm.appendBasicBlock(self.ctx, func, "forarr.incr");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "forarr.end");

        // Push loop context (continue goes to increment, break goes to end)
        self.loop_stack.append(self.allocator, .{
            .continue_block = incr_bb,
            .break_block = end_bb,
        }) catch return EmitError.OutOfMemory;
        defer _ = self.loop_stack.pop();

        // Branch to condition
        _ = self.builder.buildBr(cond_bb);

        // Emit condition: idx < len
        self.builder.positionAtEnd(cond_bb);
        const cur_idx = self.builder.buildLoad(i32_type, idx_alloca, "for.idx.cur");
        const len_val = llvm.Const.int32(self.ctx, @intCast(array_len));
        const cmp = self.builder.buildICmp(llvm.c.LLVMIntSLT, cur_idx, len_val, "for.cmp");
        _ = self.builder.buildCondBr(cmp, body_bb, end_bb);

        // Emit body
        self.builder.positionAtEnd(body_bb);
        self.has_terminator = false;

        // Load current element and store to binding
        var indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            cur_idx,
        };
        const elem_ptr = self.builder.buildGEP(array_type, array_ptr, &indices, "elem.ptr");
        const elem_val = self.builder.buildLoad(elem_type, elem_ptr, "elem.val");
        _ = self.builder.buildStore(elem_val, elem_alloca);

        // Emit body with loop scope for drop tracking
        try self.pushScope(true); // is_loop = true
        _ = try self.emitBlock(body);
        if (!self.has_terminator) {
            // Emit drops for variables declared in this iteration before continuing
            self.popScope();
            _ = self.builder.buildBr(incr_bb);
        } else {
            // Terminator already emitted (break/continue/return)
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        // Emit increment
        self.builder.positionAtEnd(incr_bb);
        const cur_idx2 = self.builder.buildLoad(i32_type, idx_alloca, "for.idx.cur2");
        const one = llvm.Const.int32(self.ctx, 1);
        const next_idx = self.builder.buildAdd(cur_idx2, one, "for.idx.next");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = self.builder.buildBr(cond_bb);

        // Continue after loop
        self.builder.positionAtEnd(end_bb);
        self.has_terminator = false;

        // Remove loop variable from scope
        _ = self.named_values.remove(binding_name);
    }

    /// Emit for-loop for slice types (dynamic arrays) using index iteration.
    /// Slice layout: { ptr: *T, len: i64 }
    fn emitForLoopSlice(
        self: *Emitter,
        func: llvm.ValueRef,
        binding_name: []const u8,
        iterable: ast.Expr,
        body: *ast.Block,
    ) EmitError!void {
        // Get the slice alloca and element type
        const slice_info = try self.getSliceInfo(iterable);
        const slice_alloca = slice_info.alloca;
        const element_llvm_type = slice_info.element_type;

        const i64_type = llvm.Types.int64(self.ctx);
        const slice_type = self.getSliceStructType();

        // Allocate index counter (use i64 to match slice length type)
        const idx_alloca = self.builder.buildAlloca(i64_type, "forslice.idx");
        _ = self.builder.buildStore(llvm.Const.int64(self.ctx, 0), idx_alloca);

        // Allocate loop variable (element binding)
        const var_name = self.allocator.dupeZ(u8, binding_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(var_name);
        const elem_alloca = self.builder.buildAlloca(element_llvm_type, var_name);

        // Determine if element type is signed (for integer types)
        const is_signed = self.isSignedType(element_llvm_type);

        // Add loop variable to scope
        self.named_values.put(binding_name, .{
            .value = elem_alloca,
            .is_alloca = true,
            .ty = element_llvm_type,
            .is_signed = is_signed,
        }) catch return EmitError.OutOfMemory;

        // Create blocks
        const cond_bb = llvm.appendBasicBlock(self.ctx, func, "forslice.cond");
        const body_bb = llvm.appendBasicBlock(self.ctx, func, "forslice.body");
        const incr_bb = llvm.appendBasicBlock(self.ctx, func, "forslice.incr");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "forslice.end");

        // Push loop context (continue goes to increment, break goes to end)
        self.loop_stack.append(self.allocator, .{
            .continue_block = incr_bb,
            .break_block = end_bb,
        }) catch return EmitError.OutOfMemory;
        defer _ = self.loop_stack.pop();

        // Branch to condition
        _ = self.builder.buildBr(cond_bb);

        // Emit condition: idx < len
        self.builder.positionAtEnd(cond_bb);
        const cur_idx = self.builder.buildLoad(i64_type, idx_alloca, "forslice.idx.cur");
        // Load length from slice struct (field 1)
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, slice_alloca, 1, "forslice.len_ptr");
        const slice_len = self.builder.buildLoad(i64_type, len_ptr, "forslice.len");
        const cmp = self.builder.buildICmp(llvm.c.LLVMIntSLT, cur_idx, slice_len, "forslice.cmp");
        _ = self.builder.buildCondBr(cmp, body_bb, end_bb);

        // Emit body
        self.builder.positionAtEnd(body_bb);
        self.has_terminator = false;

        // Load data pointer from slice struct (field 0)
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, slice_alloca, 0, "forslice.ptr_ptr");
        const data_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), ptr_ptr, "forslice.data_ptr");

        // Load current element: data_ptr[idx]
        var gep_indices = [_]llvm.ValueRef{cur_idx};
        const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, element_llvm_type, data_ptr, &gep_indices, 1, "forslice.elem.ptr");
        const elem_val = self.builder.buildLoad(element_llvm_type, elem_ptr, "forslice.elem.val");
        _ = self.builder.buildStore(elem_val, elem_alloca);

        // Emit body with loop scope for drop tracking
        try self.pushScope(true); // is_loop = true
        _ = try self.emitBlock(body);
        if (!self.has_terminator) {
            // Emit drops for variables declared in this iteration before continuing
            self.popScope();
            _ = self.builder.buildBr(incr_bb);
        } else {
            // Terminator already emitted (break/continue/return)
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        // Emit increment
        self.builder.positionAtEnd(incr_bb);
        const cur_idx2 = self.builder.buildLoad(i64_type, idx_alloca, "forslice.idx.cur2");
        const one = llvm.Const.int64(self.ctx, 1);
        const next_idx = self.builder.buildAdd(cur_idx2, one, "forslice.idx.next");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = self.builder.buildBr(cond_bb);

        // Continue after loop
        self.builder.positionAtEnd(end_bb);
        self.has_terminator = false;

        // Remove loop variable from scope
        _ = self.named_values.remove(binding_name);
    }

    /// Emit for-loop for List[T] types using index iteration.
    /// List layout: { ptr: *T, len: i32, capacity: i32 }
    fn emitForLoopList(
        self: *Emitter,
        func: llvm.ValueRef,
        binding_name: []const u8,
        iterable: ast.Expr,
        body: *ast.Block,
    ) EmitError!void {
        // Get the list alloca and element type
        const list_info = try self.getListInfo(iterable);
        const list_alloca = list_info.alloca;
        const element_type = list_info.element_type;
        const element_llvm_type = self.typeToLLVM(element_type);

        const i32_type = llvm.Types.int32(self.ctx);
        const list_type = self.getListStructType();

        // Allocate index counter
        const idx_alloca = self.builder.buildAlloca(i32_type, "forlist.idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);

        // Allocate loop variable (element binding)
        const var_name = self.allocator.dupeZ(u8, binding_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(var_name);
        const elem_alloca = self.builder.buildAlloca(element_llvm_type, var_name);

        // Determine if element type is signed (for integer types)
        const is_signed = self.isSignedType(element_llvm_type);

        // Add loop variable to scope
        self.named_values.put(binding_name, .{
            .value = elem_alloca,
            .is_alloca = true,
            .ty = element_llvm_type,
            .is_signed = is_signed,
        }) catch return EmitError.OutOfMemory;

        // Create blocks
        const cond_bb = llvm.appendBasicBlock(self.ctx, func, "forlist.cond");
        const body_bb = llvm.appendBasicBlock(self.ctx, func, "forlist.body");
        const incr_bb = llvm.appendBasicBlock(self.ctx, func, "forlist.incr");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "forlist.end");

        // Push loop context (continue goes to increment, break goes to end)
        self.loop_stack.append(self.allocator, .{
            .continue_block = incr_bb,
            .break_block = end_bb,
        }) catch return EmitError.OutOfMemory;
        defer _ = self.loop_stack.pop();

        // Branch to condition
        _ = self.builder.buildBr(cond_bb);

        // Emit condition: idx < len
        self.builder.positionAtEnd(cond_bb);
        const cur_idx = self.builder.buildLoad(i32_type, idx_alloca, "forlist.idx.cur");
        // Load current length from list (it may change during iteration, but we snapshot it)
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 1, "forlist.len_ptr");
        const list_len = self.builder.buildLoad(i32_type, len_ptr, "forlist.len");
        const cmp = self.builder.buildICmp(llvm.c.LLVMIntSLT, cur_idx, list_len, "forlist.cmp");
        _ = self.builder.buildCondBr(cmp, body_bb, end_bb);

        // Emit body
        self.builder.positionAtEnd(body_bb);
        self.has_terminator = false;

        // Load data pointer from list
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 0, "forlist.ptr_ptr");
        const data_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), ptr_ptr, "forlist.data_ptr");

        // Load current element: data_ptr[idx]
        var gep_indices = [_]llvm.ValueRef{cur_idx};
        const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, element_llvm_type, data_ptr, &gep_indices, 1, "forlist.elem.ptr");
        const elem_val = self.builder.buildLoad(element_llvm_type, elem_ptr, "forlist.elem.val");
        _ = self.builder.buildStore(elem_val, elem_alloca);

        // Emit body with loop scope for drop tracking
        try self.pushScope(true); // is_loop = true
        _ = try self.emitBlock(body);
        if (!self.has_terminator) {
            // Emit drops for variables declared in this iteration before continuing
            self.popScope();
            _ = self.builder.buildBr(incr_bb);
        } else {
            // Terminator already emitted (break/continue/return)
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        // Emit increment
        self.builder.positionAtEnd(incr_bb);
        const cur_idx2 = self.builder.buildLoad(i32_type, idx_alloca, "forlist.idx.cur2");
        const one = llvm.Const.int32(self.ctx, 1);
        const next_idx = self.builder.buildAdd(cur_idx2, one, "forlist.idx.next");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = self.builder.buildBr(cond_bb);

        // Continue after loop
        self.builder.positionAtEnd(end_bb);
        self.has_terminator = false;

        // Remove loop variable from scope
        _ = self.named_values.remove(binding_name);
    }

    /// Get information about a slice expression: its alloca pointer and element type.
    const SliceInfo = struct {
        alloca: llvm.ValueRef,
        element_type: llvm.TypeRef,
    };

    fn getSliceInfo(self: *Emitter, expr: ast.Expr) EmitError!SliceInfo {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    // Check if this is a slice (array without fixed size)
                    if (local.is_array and local.array_size == null) {
                        // Get element type from stored type info
                        if (local.array_element_type) |elem_type| {
                            return SliceInfo{
                                .alloca = local.value,
                                .element_type = self.typeToLLVM(elem_type),
                            };
                        }
                        // Fallback: try to infer element type
                        // For char slices (from string.chars()), element is i32 (char)
                        return SliceInfo{
                            .alloca = local.value,
                            .element_type = llvm.Types.int32(self.ctx),
                        };
                    }
                }
            },
            else => {},
        }
        // Fallback: use type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .slice) {
                const slice_val = try self.emitExpr(expr);
                return SliceInfo{
                    .alloca = slice_val,
                    .element_type = self.typeToLLVM(expr_type.slice.element),
                };
            }
        }
        return EmitError.InvalidAST;
    }

    /// Get information about a List expression: its alloca pointer and element type.
    const ListInfo = struct {
        alloca: llvm.ValueRef,
        element_type: types.Type,
    };

    fn getListInfo(self: *Emitter, expr: ast.Expr) EmitError!ListInfo {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.list_element_type) |elem_type| {
                        return ListInfo{
                            .alloca = local.value,
                            .element_type = elem_type,
                        };
                    }
                }
            },
            else => {},
        }
        // Fallback: use type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .list) {
                // Emit the expression and hope it's an alloca
                const list_val = try self.emitExpr(expr);
                return ListInfo{
                    .alloca = list_val,
                    .element_type = expr_type.list.element,
                };
            }
        }
        return EmitError.InvalidAST;
    }

    /// Emit for-loop for Set[T] types using index iteration over entries.
    /// Set layout: { entries: *Entry, len: i32, capacity: i32, tombstone_count: i32 }
    /// Entry layout: { state: i8, cached_hash: i32, element: T }
    /// State: 0=EMPTY, 1=OCCUPIED, 2=TOMBSTONE
    fn emitForLoopSet(
        self: *Emitter,
        func: llvm.ValueRef,
        binding_name: []const u8,
        iterable: ast.Expr,
        body: *ast.Block,
    ) EmitError!void {
        // Get the set alloca and element type
        const set_info = try self.getSetInfo(iterable);
        const set_alloca = set_info.alloca;
        const element_type = set_info.element_type;
        const element_llvm_type = self.typeToLLVM(element_type);

        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const set_type = self.getSetStructType();
        const entry_type = self.getSetEntryType(element_llvm_type);

        // Allocate index counter (iterates over capacity, not len)
        const idx_alloca = self.builder.buildAlloca(i32_type, "forset.idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);

        // Allocate loop variable (element binding)
        const var_name = self.allocator.dupeZ(u8, binding_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(var_name);
        const elem_alloca = self.builder.buildAlloca(element_llvm_type, var_name);

        // Determine if element type is signed (for integer types)
        const is_signed = self.isSignedType(element_llvm_type);

        // Add loop variable to scope
        self.named_values.put(binding_name, .{
            .value = elem_alloca,
            .is_alloca = true,
            .ty = element_llvm_type,
            .is_signed = is_signed,
        }) catch return EmitError.OutOfMemory;

        // Create blocks
        const cond_bb = llvm.appendBasicBlock(self.ctx, func, "forset.cond");
        const check_bb = llvm.appendBasicBlock(self.ctx, func, "forset.check");
        const body_bb = llvm.appendBasicBlock(self.ctx, func, "forset.body");
        const incr_bb = llvm.appendBasicBlock(self.ctx, func, "forset.incr");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "forset.end");

        // Push loop context (continue goes to increment, break goes to end)
        self.loop_stack.append(self.allocator, .{
            .continue_block = incr_bb,
            .break_block = end_bb,
        }) catch return EmitError.OutOfMemory;
        defer _ = self.loop_stack.pop();

        // Branch to condition
        _ = self.builder.buildBr(cond_bb);

        // Emit condition: idx < capacity
        self.builder.positionAtEnd(cond_bb);
        const cur_idx = self.builder.buildLoad(i32_type, idx_alloca, "forset.idx.cur");
        // Load capacity from set (field index 2)
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_alloca, 2, "forset.cap_ptr");
        const set_cap = self.builder.buildLoad(i32_type, cap_ptr, "forset.cap");
        const cmp = self.builder.buildICmp(llvm.c.LLVMIntSLT, cur_idx, set_cap, "forset.cmp");
        _ = self.builder.buildCondBr(cmp, check_bb, end_bb);

        // Check if current entry is OCCUPIED (state == 1)
        self.builder.positionAtEnd(check_bb);
        const cur_idx2 = self.builder.buildLoad(i32_type, idx_alloca, "forset.idx.cur2");

        // Load entries pointer from set (field index 0)
        const entries_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_alloca, 0, "forset.entries_ptr_ptr");
        const entries_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), entries_ptr_ptr, "forset.entries_ptr");

        // Get pointer to current entry: entries[idx]
        var gep_indices_entry = [_]llvm.ValueRef{cur_idx2};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr, &gep_indices_entry, 1, "forset.entry.ptr");

        // Load state from entry (field index 0)
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "forset.state.ptr");
        const state_val = self.builder.buildLoad(i8_type, state_ptr, "forset.state");

        // Check if state == 1 (OCCUPIED)
        const occupied = llvm.Const.int8(self.ctx, 1);
        const is_occupied = self.builder.buildICmp(llvm.c.LLVMIntEQ, state_val, occupied, "forset.is_occupied");
        _ = self.builder.buildCondBr(is_occupied, body_bb, incr_bb);

        // Emit body
        self.builder.positionAtEnd(body_bb);
        self.has_terminator = false;

        // Load element from entry (field index 2)
        const elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "forset.elem.ptr");
        const elem_val = self.builder.buildLoad(element_llvm_type, elem_ptr, "forset.elem.val");
        _ = self.builder.buildStore(elem_val, elem_alloca);

        // Emit body with loop scope for drop tracking
        try self.pushScope(true); // is_loop = true
        _ = try self.emitBlock(body);
        if (!self.has_terminator) {
            // Emit drops for variables declared in this iteration before continuing
            self.popScope();
            _ = self.builder.buildBr(incr_bb);
        } else {
            // Terminator already emitted (break/continue/return)
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        // Emit increment
        self.builder.positionAtEnd(incr_bb);
        const cur_idx3 = self.builder.buildLoad(i32_type, idx_alloca, "forset.idx.cur3");
        const one = llvm.Const.int32(self.ctx, 1);
        const next_idx = self.builder.buildAdd(cur_idx3, one, "forset.idx.next");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = self.builder.buildBr(cond_bb);

        // Continue after loop
        self.builder.positionAtEnd(end_bb);
        self.has_terminator = false;

        // Remove loop variable from scope
        _ = self.named_values.remove(binding_name);
    }

    /// Get information about a Set expression: its alloca pointer and element type.
    const SetInfo = struct {
        alloca: llvm.ValueRef,
        element_type: types.Type,
    };

    fn getSetInfo(self: *Emitter, expr: ast.Expr) EmitError!SetInfo {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.set_element_type) |elem_type| {
                        return SetInfo{
                            .alloca = local.value,
                            .element_type = elem_type,
                        };
                    }
                }
            },
            else => {},
        }
        // Fallback: use type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .set) {
                // Emit the expression and hope it's an alloca
                const set_val = try self.emitExpr(expr);
                return SetInfo{
                    .alloca = set_val,
                    .element_type = expr_type.set.element,
                };
            }
        }
        return EmitError.InvalidAST;
    }

    /// Get information about a Map expression: its alloca pointer, key type, and value type.
    const MapInfo = struct {
        alloca: llvm.ValueRef,
        key_type: types.Type,
        value_type: types.Type,
    };

    fn getMapInfo(self: *Emitter, expr: ast.Expr) EmitError!MapInfo {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.map_key_type != null and local.map_value_type != null) {
                        return MapInfo{
                            .alloca = local.value,
                            .key_type = local.map_key_type.?,
                            .value_type = local.map_value_type.?,
                        };
                    }
                }
            },
            else => {},
        }
        // Fallback: use type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .map) {
                // Emit the expression and hope it's an alloca
                const map_val = try self.emitExpr(expr);
                return MapInfo{
                    .alloca = map_val,
                    .key_type = expr_type.map.key,
                    .value_type = expr_type.map.value,
                };
            }
        }
        return EmitError.InvalidAST;
    }

    /// Emit for-loop over Map[K,V] with tuple pattern: for (k, v) in map { body }
    fn emitForLoopMap(
        self: *Emitter,
        func: llvm.ValueRef,
        tuple_pattern: *ast.TuplePattern,
        iterable: ast.Expr,
        body: *ast.Block,
    ) EmitError!void {
        // Tuple pattern must have exactly 2 elements: (key, value)
        if (tuple_pattern.elements.len != 2) {
            return EmitError.UnsupportedFeature;
        }

        // Get binding names from tuple pattern elements
        const key_binding = switch (tuple_pattern.elements[0]) {
            .binding => |b| b.name,
            else => return EmitError.UnsupportedFeature,
        };
        const value_binding = switch (tuple_pattern.elements[1]) {
            .binding => |b| b.name,
            else => return EmitError.UnsupportedFeature,
        };

        // Get the map alloca and key/value types
        const map_info = try self.getMapInfo(iterable);
        const map_alloca = map_info.alloca;
        const key_type = map_info.key_type;
        const value_type = map_info.value_type;
        const key_llvm_type = self.typeToLLVM(key_type);
        const value_llvm_type = self.typeToLLVM(value_type);

        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const map_type = self.getMapStructType();
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);

        // Allocate index counter (iterates over capacity, not len)
        const idx_alloca = self.builder.buildAlloca(i32_type, "formap.idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);

        // Allocate loop variables (key and value bindings)
        const key_var_name = self.allocator.dupeZ(u8, key_binding) catch return EmitError.OutOfMemory;
        defer self.allocator.free(key_var_name);
        const key_alloca = self.builder.buildAlloca(key_llvm_type, key_var_name);

        const value_var_name = self.allocator.dupeZ(u8, value_binding) catch return EmitError.OutOfMemory;
        defer self.allocator.free(value_var_name);
        const value_alloca = self.builder.buildAlloca(value_llvm_type, value_var_name);

        // Determine if types are signed
        const key_is_signed = self.isSignedType(key_llvm_type);
        const value_is_signed = self.isSignedType(value_llvm_type);

        // Add loop variables to scope
        self.named_values.put(key_binding, .{
            .value = key_alloca,
            .is_alloca = true,
            .ty = key_llvm_type,
            .is_signed = key_is_signed,
        }) catch return EmitError.OutOfMemory;

        self.named_values.put(value_binding, .{
            .value = value_alloca,
            .is_alloca = true,
            .ty = value_llvm_type,
            .is_signed = value_is_signed,
        }) catch return EmitError.OutOfMemory;

        // Create blocks
        const cond_bb = llvm.appendBasicBlock(self.ctx, func, "formap.cond");
        const check_bb = llvm.appendBasicBlock(self.ctx, func, "formap.check");
        const body_bb = llvm.appendBasicBlock(self.ctx, func, "formap.body");
        const incr_bb = llvm.appendBasicBlock(self.ctx, func, "formap.incr");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "formap.end");

        // Push loop context (continue goes to increment, break goes to end)
        self.loop_stack.append(self.allocator, .{
            .continue_block = incr_bb,
            .break_block = end_bb,
        }) catch return EmitError.OutOfMemory;
        defer _ = self.loop_stack.pop();

        // Branch to condition
        _ = self.builder.buildBr(cond_bb);

        // Emit condition: idx < capacity
        self.builder.positionAtEnd(cond_bb);
        const cur_idx = self.builder.buildLoad(i32_type, idx_alloca, "formap.idx.cur");
        // Load capacity from map (field index 2)
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_alloca, 2, "formap.cap_ptr");
        const map_cap = self.builder.buildLoad(i32_type, cap_ptr, "formap.cap");
        const cmp = self.builder.buildICmp(llvm.c.LLVMIntSLT, cur_idx, map_cap, "formap.cmp");
        _ = self.builder.buildCondBr(cmp, check_bb, end_bb);

        // Check if current entry is OCCUPIED (state == 1)
        self.builder.positionAtEnd(check_bb);
        const cur_idx2 = self.builder.buildLoad(i32_type, idx_alloca, "formap.idx.cur2");

        // Load entries pointer from map (field index 0)
        const entries_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_alloca, 0, "formap.entries_ptr_ptr");
        const entries_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), entries_ptr_ptr, "formap.entries_ptr");

        // Get pointer to current entry: entries[idx]
        var gep_indices_entry = [_]llvm.ValueRef{cur_idx2};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr, &gep_indices_entry, 1, "formap.entry.ptr");

        // Load state from entry (field index 0)
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "formap.state.ptr");
        const state_val = self.builder.buildLoad(i8_type, state_ptr, "formap.state");

        // Check if state == 1 (OCCUPIED)
        const occupied = llvm.Const.int8(self.ctx, 1);
        const is_occupied = self.builder.buildICmp(llvm.c.LLVMIntEQ, state_val, occupied, "formap.is_occupied");
        _ = self.builder.buildCondBr(is_occupied, body_bb, incr_bb);

        // Emit body
        self.builder.positionAtEnd(body_bb);
        self.has_terminator = false;

        // Load key from entry (field index 2)
        const key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "formap.key.ptr");
        const key_val = self.builder.buildLoad(key_llvm_type, key_ptr, "formap.key.val");
        _ = self.builder.buildStore(key_val, key_alloca);

        // Load value from entry (field index 3)
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "formap.val.ptr");
        const val_val = self.builder.buildLoad(value_llvm_type, val_ptr, "formap.val.val");
        _ = self.builder.buildStore(val_val, value_alloca);

        // Emit body with loop scope for drop tracking
        try self.pushScope(true); // is_loop = true
        _ = try self.emitBlock(body);
        if (!self.has_terminator) {
            // Emit drops for variables declared in this iteration before continuing
            self.popScope();
            _ = self.builder.buildBr(incr_bb);
        } else {
            // Terminator already emitted (break/continue/return)
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        // Emit increment
        self.builder.positionAtEnd(incr_bb);
        const cur_idx3 = self.builder.buildLoad(i32_type, idx_alloca, "formap.idx.cur3");
        const one = llvm.Const.int32(self.ctx, 1);
        const next_idx = self.builder.buildAdd(cur_idx3, one, "formap.idx.next");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = self.builder.buildBr(cond_bb);

        // Continue after loop
        self.builder.positionAtEnd(end_bb);
        self.has_terminator = false;

        // Remove loop variables from scope
        _ = self.named_values.remove(key_binding);
        _ = self.named_values.remove(value_binding);
    }

    /// Get information about an array expression: its alloca pointer, LLVM type, and length.
    const ArrayInfo = struct {
        ptr: llvm.ValueRef,
        ty: llvm.TypeRef,
        len: u64,
    };

    fn getArrayInfo(self: *Emitter, expr: ast.Expr) EmitError!ArrayInfo {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.is_alloca and local.is_array) {
                        // For arrays, local.ty is the LLVM array type
                        const array_type = local.ty;
                        const array_len = if (local.array_size) |sz| sz else llvm.Types.getArrayLength(array_type);
                        return ArrayInfo{
                            .ptr = local.value,
                            .ty = array_type,
                            .len = array_len,
                        };
                    }
                }
                return EmitError.InvalidAST;
            },
            .array_literal => |arr| {
                // Emit the array literal and store it in an alloca
                const array_val = try self.emitExpr(expr);
                const array_type = llvm.typeOf(array_val);
                const array_len = arr.elements.len;
                const alloca = self.builder.buildAlloca(array_type, "arr.iter");
                _ = self.builder.buildStore(array_val, alloca);
                return ArrayInfo{
                    .ptr = alloca,
                    .ty = array_type,
                    .len = array_len,
                };
            },
            else => return EmitError.InvalidAST,
        }
    }

    /// Check if an LLVM type is a signed integer type.
    fn isSignedType(self: *Emitter, ty: llvm.TypeRef) bool {
        _ = self;
        // In LLVM, integer signedness is determined by the operations, not the type.
        // We default to signed for integer types used in loops.
        const kind = llvm.getTypeKind(ty);
        return kind == llvm.c.LLVMIntegerTypeKind;
    }

    fn emitInfiniteLoop(self: *Emitter, loop: *ast.LoopStmt) EmitError!void {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Create blocks
        const body_bb = llvm.appendBasicBlock(self.ctx, func, "loop.body");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "loop.end");

        // Push loop context
        self.loop_stack.append(self.allocator, .{
            .continue_block = body_bb,
            .break_block = end_bb,
        }) catch return EmitError.OutOfMemory;
        defer _ = self.loop_stack.pop();

        // Branch to body
        _ = self.builder.buildBr(body_bb);

        // Emit body with loop scope for drop tracking
        self.builder.positionAtEnd(body_bb);
        self.has_terminator = false;
        try self.pushScope(true); // is_loop = true
        _ = try self.emitBlock(loop.body);
        if (!self.has_terminator) {
            // Emit drops for variables declared in this iteration before looping
            self.popScope();
            _ = self.builder.buildBr(body_bb);
        } else {
            // Terminator already emitted (break/continue/return)
            // Drops were already emitted by the terminator, just clean up scope without emitting
            if (self.scope_stack.pop()) |scope| {
                var s = scope;
                s.droppables.deinit(self.allocator);
            }
        }

        // Continue after loop
        self.builder.positionAtEnd(end_bb);
        self.has_terminator = false;
    }

    fn emitBreak(self: *Emitter) EmitError!void {
        if (self.loop_stack.items.len == 0) {
            return EmitError.InvalidAST; // break outside of loop
        }
        // Emit drops for all scopes until we reach the loop scope
        self.emitDropsForLoopExit();
        const loop_ctx = self.loop_stack.items[self.loop_stack.items.len - 1];
        _ = self.builder.buildBr(loop_ctx.break_block);
        self.has_terminator = true;
    }

    fn emitContinue(self: *Emitter) EmitError!void {
        if (self.loop_stack.items.len == 0) {
            return EmitError.InvalidAST; // continue outside of loop
        }
        // Emit drops for all scopes until we reach the loop scope
        self.emitDropsForLoopExit();
        const loop_ctx = self.loop_stack.items[self.loop_stack.items.len - 1];
        _ = self.builder.buildBr(loop_ctx.continue_block);
        self.has_terminator = true;
    }

    fn emitExpr(self: *Emitter, expr: ast.Expr) EmitError!llvm.ValueRef {
        return switch (expr) {
            .literal => |lit| self.emitLiteral(lit),
            .identifier => |id| self.emitIdentifier(id),
            .binary => |bin| try self.emitBinary(bin),
            .unary => |un| try self.emitUnary(un),
            .call => |call| try self.emitCall(call),
            .block => |blk| blk: {
                // Push scope for drop tracking - variables in the block will be dropped at block end
                try self.pushScope(false);
                const result = try self.emitBlock(blk);
                // Pop scope and emit drops for variables declared in this block
                self.popScope();
                break :blk result orelse llvm.Const.int32(self.ctx, 0);
            },
            .grouped => |g| try self.emitExpr(g.expr),
            // Composite types
            .struct_literal => |s| try self.emitStructLiteral(s),
            .array_literal => |a| try self.emitArrayLiteral(a),
            .tuple_literal => |t| try self.emitTupleLiteral(t),
            .field => |f| try self.emitFieldAccess(f),
            .index => |i| try self.emitIndexAccess(i),
            .postfix => |p| try self.emitPostfix(p),
            .method_call => |m| try self.emitMethodCall(m),
            .closure => |c| try self.emitClosure(c),
            .type_cast => |tc| try self.emitTypeCast(tc),
            .enum_literal => |e| try self.emitEnumLiteral(e),
            .interpolated_string => |is| try self.emitInterpolatedString(is),
            // Comptime expressions
            .builtin_call => |bc| try self.emitBuiltinCall(bc),
            .comptime_block => |cb| try self.emitComptimeBlock(cb),
            // Unsafe block - safety checked at type-check time, emit like normal block
            .unsafe_block => |ub| blk: {
                try self.pushScope(false);
                const result = try self.emitBlock(ub.body);
                self.popScope();
                break :blk result orelse llvm.Const.int32(self.ctx, 0);
            },
            // Range expression
            .range => |r| try self.emitRangeLiteral(r),
            // Out argument - handled specially in emitCall, should not be encountered here
            .out_arg => return EmitError.InvalidAST,
        };
    }

    fn emitLiteral(self: *Emitter, lit: ast.Literal) llvm.ValueRef {
        return switch (lit.kind) {
            .int => |v| blk: {
                // Check if we have an expected type that requires a specific width
                if (self.expected_type) |expected| {
                    if (expected == .primitive) {
                        const prim = expected.primitive;
                        // Use the expected type's width for the literal
                        switch (prim) {
                            .i8_ => break :blk llvm.Const.int(llvm.Types.int8(self.ctx), @intCast(v), true),
                            .i16_ => break :blk llvm.Const.int(llvm.Types.int16(self.ctx), @intCast(v), true),
                            .i32_ => break :blk llvm.Const.int32(self.ctx, @intCast(v)),
                            .i64_ => break :blk llvm.Const.int64(self.ctx, @intCast(v)),
                            .i128_ => break :blk llvm.Const.int(llvm.Types.int128(self.ctx), @intCast(v), true),
                            .isize_ => break :blk llvm.Const.int64(self.ctx, @intCast(v)),
                            .u8_ => break :blk llvm.Const.int(llvm.Types.int8(self.ctx), @intCast(v), false),
                            .u16_ => break :blk llvm.Const.int(llvm.Types.int16(self.ctx), @intCast(v), false),
                            .u32_ => break :blk llvm.Const.int(llvm.Types.int32(self.ctx), @intCast(v), false),
                            .u64_ => break :blk llvm.Const.int64(self.ctx, @intCast(v)),
                            .u128_ => break :blk llvm.Const.int(llvm.Types.int128(self.ctx), @intCast(v), false),
                            .usize_ => break :blk llvm.Const.int64(self.ctx, @intCast(v)),
                            else => {},
                        }
                    }
                }
                // Default: determine appropriate type based on value
                if (v >= std.math.minInt(i32) and v <= std.math.maxInt(i32)) {
                    break :blk llvm.Const.int32(self.ctx, @intCast(v));
                } else {
                    break :blk llvm.Const.int64(self.ctx, @intCast(v));
                }
            },
            .float => |v| llvm.Const.float64(self.ctx, v),
            .bool_ => |v| llvm.Const.int1(self.ctx, v),
            .char => |v| llvm.Const.int(llvm.Types.int32(self.ctx), v, false),
            .string => |s| blk: {
                // Create a null-terminated string and get a pointer to it
                const str_z = self.allocator.dupeZ(u8, s) catch return llvm.Const.int32(self.ctx, 0);
                defer self.allocator.free(str_z);
                break :blk self.builder.buildGlobalStringPtr(str_z, "str");
            },
        };
    }

    /// Emit a range literal (e.g., 0..10 or 0..=10)
    /// Range layout: { start: T, end: T, current: T, inclusive: i1 }
    fn emitRangeLiteral(self: *Emitter, range: *ast.Range) EmitError!llvm.ValueRef {
        // Determine element type from start or end expression, default to i32
        const elem_ty = llvm.Types.int32(self.ctx);

        // Get start value (default to 0 if not specified)
        const start_val = if (range.start) |s|
            try self.emitExpr(s)
        else
            llvm.Const.int32(self.ctx, 0);

        // Get end value (required)
        const end_val = if (range.end) |e|
            try self.emitExpr(e)
        else
            return EmitError.UnsupportedFeature;

        // Create the Range struct type
        var fields = [_]llvm.TypeRef{
            elem_ty, // start
            elem_ty, // end
            elem_ty, // current
            llvm.Types.int1(self.ctx), // inclusive
        };
        const range_ty = llvm.Types.struct_(self.ctx, &fields, false);

        // Allocate space for the range struct
        const range_alloca = self.builder.buildAlloca(range_ty, "range.tmp");

        // Store start
        const start_gep = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_alloca, 0, "range.start.ptr");
        _ = self.builder.buildStore(start_val, start_gep);

        // Store end
        const end_gep = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_alloca, 1, "range.end.ptr");
        _ = self.builder.buildStore(end_val, end_gep);

        // Store current (initially same as start)
        const current_gep = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_alloca, 2, "range.current.ptr");
        _ = self.builder.buildStore(start_val, current_gep);

        // Store inclusive flag
        const inclusive_gep = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_alloca, 3, "range.inclusive.ptr");
        const inclusive_val = llvm.Const.int1(self.ctx, range.inclusive);
        _ = self.builder.buildStore(inclusive_val, inclusive_gep);

        // Load and return the range struct
        return self.builder.buildLoad(range_ty, range_alloca, "range");
    }

    fn emitIdentifier(self: *Emitter, id: ast.Identifier) llvm.ValueRef {
        if (self.named_values.get(id.name)) |local| {
            if (local.is_alloca) {
                const name = self.allocator.dupeZ(u8, id.name) catch
                    return llvm.Const.int32(self.ctx, 0);
                defer self.allocator.free(name);
                return self.builder.buildLoad(local.ty, local.value, name);
            }
            return local.value;
        }
        // Check if this is a module-level constant
        if (self.type_checker) |tc| {
            if (tc.getConstantValue(id.name)) |cv| {
                return self.emitComptimeValue(cv) catch return llvm.Const.int32(self.ctx, 0);
            }
        }
        // Variable not found - return placeholder
        return llvm.Const.int32(self.ctx, 0);
    }

    fn emitBinary(self: *Emitter, bin: *ast.Binary) EmitError!llvm.ValueRef {
        // Short-circuit evaluation for logical operators
        if (bin.op == .and_ or bin.op == .or_) {
            return self.emitLogicalBinary(bin);
        }

        // Handle assignment operators
        if (bin.op == .assign or bin.op == .add_assign or bin.op == .sub_assign or
            bin.op == .mul_assign or bin.op == .div_assign or bin.op == .mod_assign)
        {
            return self.emitAssignment(bin);
        }

        // Handle null coalescing (short-circuit evaluation)
        if (bin.op == .null_coalesce) {
            return self.emitNullCoalesce(bin);
        }

        var lhs = try self.emitExpr(bin.left);
        var rhs = try self.emitExpr(bin.right);

        // Check if either operand is floating-point
        const lhs_ty = llvm.typeOf(lhs);
        const rhs_ty = llvm.typeOf(rhs);
        const lhs_is_float = llvm.getTypeKind(lhs_ty) == llvm.c.LLVMFloatTypeKind or
            llvm.getTypeKind(lhs_ty) == llvm.c.LLVMDoubleTypeKind;
        const rhs_is_float = llvm.getTypeKind(rhs_ty) == llvm.c.LLVMFloatTypeKind or
            llvm.getTypeKind(rhs_ty) == llvm.c.LLVMDoubleTypeKind;
        const is_float = lhs_is_float or rhs_is_float;

        // Check if both operands are pointers (strings)
        const lhs_is_ptr = llvm.getTypeKind(lhs_ty) == llvm.c.LLVMPointerTypeKind;
        const rhs_is_ptr = llvm.getTypeKind(rhs_ty) == llvm.c.LLVMPointerTypeKind;
        const is_string = lhs_is_ptr and rhs_is_ptr;

        // If mixed types, promote integer to float
        if (is_float and !lhs_is_float) {
            // lhs is int, rhs is float - convert lhs to float
            lhs = self.builder.buildSIToFP(lhs, rhs_ty, "promote_lhs");
        } else if (is_float and !rhs_is_float) {
            // lhs is float, rhs is int - convert rhs to float
            rhs = self.builder.buildSIToFP(rhs, lhs_ty, "promote_rhs");
        }

        return switch (bin.op) {
            // Standard arithmetic (with overflow checking for integers)
            .add => if (is_float)
                self.builder.buildFAdd(lhs, rhs, "faddtmp")
            else if (is_string)
                try self.emitStringConcatLiteral(lhs, rhs)
            else
                self.emitCheckedAdd(lhs, rhs, true),
            .sub => if (is_float)
                self.builder.buildFSub(lhs, rhs, "fsubtmp")
            else
                self.emitCheckedSub(lhs, rhs, true),
            .mul => if (is_float)
                self.builder.buildFMul(lhs, rhs, "fmultmp")
            else
                self.emitCheckedMul(lhs, rhs, true),
            .div => if (is_float)
                self.builder.buildFDiv(lhs, rhs, "fdivtmp")
            else
                self.builder.buildSDiv(lhs, rhs, "divtmp"),
            .mod => if (is_float)
                self.builder.buildFRem(lhs, rhs, "fremtmp")
            else
                self.builder.buildSRem(lhs, rhs, "modtmp"),

            // Wrapping arithmetic (no overflow check, wraps around)
            .add_wrap => self.builder.buildAdd(lhs, rhs, "addwrap"),
            .sub_wrap => self.builder.buildSub(lhs, rhs, "subwrap"),
            .mul_wrap => self.builder.buildMul(lhs, rhs, "mulwrap"),

            // Saturating arithmetic
            .add_sat => self.emitSaturatingAdd(lhs, rhs, true),
            .sub_sat => self.emitSaturatingSub(lhs, rhs, true),
            .mul_sat => self.emitSaturatingMul(lhs, rhs, true),

            // Comparison - use appropriate type
            .eq => if (is_float)
                self.builder.buildFCmp(llvm.c.LLVMRealOEQ, lhs, rhs, "feqtmp")
            else if (is_string)
                self.emitStringPtrEq(lhs, rhs)
            else
                self.builder.buildICmp(llvm.c.LLVMIntEQ, lhs, rhs, "eqtmp"),
            .not_eq => if (is_float)
                self.builder.buildFCmp(llvm.c.LLVMRealONE, lhs, rhs, "fnetmp")
            else if (is_string)
                self.emitStringPtrNeq(lhs, rhs)
            else
                self.builder.buildICmp(llvm.c.LLVMIntNE, lhs, rhs, "netmp"),
            .lt => if (is_float)
                self.builder.buildFCmp(llvm.c.LLVMRealOLT, lhs, rhs, "flttmp")
            else
                self.builder.buildICmp(llvm.c.LLVMIntSLT, lhs, rhs, "lttmp"),
            .gt => if (is_float)
                self.builder.buildFCmp(llvm.c.LLVMRealOGT, lhs, rhs, "fgttmp")
            else
                self.builder.buildICmp(llvm.c.LLVMIntSGT, lhs, rhs, "gttmp"),
            .lt_eq => if (is_float)
                self.builder.buildFCmp(llvm.c.LLVMRealOLE, lhs, rhs, "fletmp")
            else
                self.builder.buildICmp(llvm.c.LLVMIntSLE, lhs, rhs, "letmp"),
            .gt_eq => if (is_float)
                self.builder.buildFCmp(llvm.c.LLVMRealOGE, lhs, rhs, "fgetmp")
            else
                self.builder.buildICmp(llvm.c.LLVMIntSGE, lhs, rhs, "getmp"),

            // Bitwise
            .bit_and => self.builder.buildAnd(lhs, rhs, "andtmp"),
            .bit_or => self.builder.buildOr(lhs, rhs, "ortmp"),
            .bit_xor => self.builder.buildXor(lhs, rhs, "xortmp"),
            .shl => self.builder.buildShl(lhs, rhs, "shltmp"),
            .shr => self.builder.buildAShr(lhs, rhs, "shrtmp"),

            else => llvm.Const.int32(self.ctx, 0), // Placeholder
        };
    }

    /// Emit checked addition that traps on overflow.
    fn emitCheckedAdd(self: *Emitter, lhs: llvm.ValueRef, rhs: llvm.ValueRef, is_signed: bool) llvm.ValueRef {
        // For now, use simple wrapping add.
        // In production, this would use LLVM overflow intrinsics and trap on overflow.
        // TODO: implement proper overflow checking with intrinsics
        if (is_signed) {
            return self.builder.buildNSWAdd(lhs, rhs, "addtmp");
        } else {
            return self.builder.buildAdd(lhs, rhs, "addtmp");
        }
    }

    /// Emit checked subtraction that traps on overflow.
    fn emitCheckedSub(self: *Emitter, lhs: llvm.ValueRef, rhs: llvm.ValueRef, is_signed: bool) llvm.ValueRef {
        if (is_signed) {
            return self.builder.buildNSWSub(lhs, rhs, "subtmp");
        } else {
            return self.builder.buildSub(lhs, rhs, "subtmp");
        }
    }

    /// Emit checked multiplication that traps on overflow.
    fn emitCheckedMul(self: *Emitter, lhs: llvm.ValueRef, rhs: llvm.ValueRef, is_signed: bool) llvm.ValueRef {
        if (is_signed) {
            return self.builder.buildNSWMul(lhs, rhs, "multmp");
        } else {
            return self.builder.buildMul(lhs, rhs, "multmp");
        }
    }

    /// Emit saturating addition.
    fn emitSaturatingAdd(self: *Emitter, lhs: llvm.ValueRef, rhs: llvm.ValueRef, is_signed: bool) llvm.ValueRef {
        // For saturating arithmetic, we use LLVM's select instruction to clamp
        // This is a simplified implementation - proper saturation would use intrinsics
        _ = is_signed;
        // For now, just do regular add (TODO: proper saturation)
        return self.builder.buildAdd(lhs, rhs, "addsattmp");
    }

    /// Emit saturating subtraction.
    fn emitSaturatingSub(self: *Emitter, lhs: llvm.ValueRef, rhs: llvm.ValueRef, is_signed: bool) llvm.ValueRef {
        _ = is_signed;
        return self.builder.buildSub(lhs, rhs, "subsattmp");
    }

    /// Emit saturating multiplication.
    fn emitSaturatingMul(self: *Emitter, lhs: llvm.ValueRef, rhs: llvm.ValueRef, is_signed: bool) llvm.ValueRef {
        _ = is_signed;
        return self.builder.buildMul(lhs, rhs, "mulsattmp");
    }

    /// Emit string pointer equality comparison using strcmp.
    /// For binary == operator on char* strings.
    /// Returns true (i1) if strings are equal (strcmp returns 0).
    fn emitStringPtrEq(self: *Emitter, lhs: llvm.ValueRef, rhs: llvm.ValueRef) llvm.ValueRef {
        const strcmp_fn = self.getOrDeclareStrcmp();
        var args = [_]llvm.ValueRef{ lhs, rhs };
        const result = self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(strcmp_fn),
            strcmp_fn,
            &args,
            "strcmp.result",
        );
        // strcmp returns 0 if equal
        return self.builder.buildICmp(
            llvm.c.LLVMIntEQ,
            result,
            llvm.Const.int32(self.ctx, 0),
            "streq",
        );
    }

    /// Emit string pointer inequality comparison using strcmp.
    /// For binary != operator on char* strings.
    /// Returns true (i1) if strings are not equal (strcmp returns non-zero).
    fn emitStringPtrNeq(self: *Emitter, lhs: llvm.ValueRef, rhs: llvm.ValueRef) llvm.ValueRef {
        const strcmp_fn = self.getOrDeclareStrcmp();
        var args = [_]llvm.ValueRef{ lhs, rhs };
        const result = self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(strcmp_fn),
            strcmp_fn,
            &args,
            "strcmp.result",
        );
        // strcmp returns 0 if equal, so not-equal is result != 0
        return self.builder.buildICmp(
            llvm.c.LLVMIntNE,
            result,
            llvm.Const.int32(self.ctx, 0),
            "strneq",
        );
    }

    /// Emit string concatenation using the runtime function.
    /// For binary + operator on char* strings.
    /// Returns a new null-terminated string pointer.
    fn emitStringConcatLiteral(self: *Emitter, lhs: llvm.ValueRef, rhs: llvm.ValueRef) EmitError!llvm.ValueRef {
        const concat_fn = self.getOrDeclareStringConcatLiteral();
        var args = [_]llvm.ValueRef{ lhs, rhs };
        return self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(concat_fn),
            concat_fn,
            &args,
            "strconcat",
        );
    }

    /// Emit assignment (including compound assignment operators).
    fn emitAssignment(self: *Emitter, bin: *ast.Binary) EmitError!llvm.ValueRef {
        // Handle array index assignment: arr[i] = value
        if (bin.left == .index) {
            return self.emitIndexAssignment(bin);
        }

        // Handle struct field assignment: s.field = value
        if (bin.left == .field) {
            return self.emitFieldAssignment(bin);
        }

        // Handle deref assignment: *ptr = value
        if (bin.left == .unary) {
            const un = bin.left.unary;
            if (un.op == .deref) {
                return self.emitDerefAssignment(bin, un);
            }
        }

        // Get the target variable for simple identifier assignment
        const target_id = switch (bin.left) {
            .identifier => |id| id,
            else => return EmitError.UnsupportedFeature,
        };

        const local = self.named_values.get(target_id.name) orelse
            return EmitError.InvalidAST;

        if (!local.is_alloca) {
            return EmitError.InvalidAST; // Can only assign to allocas
        }

        // Evaluate the right-hand side
        const rhs = try self.emitExpr(bin.right);

        // For compound assignment, load current value and perform operation
        const value = switch (bin.op) {
            .assign => rhs,
            .add_assign => blk: {
                const lhs = self.builder.buildLoad(local.ty, local.value, "loadtmp");
                break :blk self.builder.buildAdd(lhs, rhs, "addtmp");
            },
            .sub_assign => blk: {
                const lhs = self.builder.buildLoad(local.ty, local.value, "loadtmp");
                break :blk self.builder.buildSub(lhs, rhs, "subtmp");
            },
            .mul_assign => blk: {
                const lhs = self.builder.buildLoad(local.ty, local.value, "loadtmp");
                break :blk self.builder.buildMul(lhs, rhs, "multmp");
            },
            .div_assign => blk: {
                const lhs = self.builder.buildLoad(local.ty, local.value, "loadtmp");
                break :blk self.builder.buildSDiv(lhs, rhs, "divtmp");
            },
            .mod_assign => blk: {
                const lhs = self.builder.buildLoad(local.ty, local.value, "loadtmp");
                break :blk self.builder.buildSRem(lhs, rhs, "modtmp");
            },
            else => return EmitError.InvalidAST,
        };

        // Store the result
        _ = self.builder.buildStore(value, local.value);

        // Return the stored value (assignments are expressions in Klar)
        return value;
    }

    /// Emit array index assignment: arr[i] = value
    fn emitIndexAssignment(self: *Emitter, bin: *ast.Binary) EmitError!llvm.ValueRef {
        const idx = bin.left.index;

        // For simple assignment, we need the array variable's alloca
        // The array must be a variable (identifier) for assignment to work
        const arr_id = switch (idx.object) {
            .identifier => |id| id,
            else => return EmitError.UnsupportedFeature, // Only support arr[i] = v, not (expr)[i] = v
        };

        const local = self.named_values.get(arr_id.name) orelse
            return EmitError.InvalidAST;

        if (!local.is_alloca) {
            return EmitError.InvalidAST; // Can only assign to allocas
        }

        // Get the array type from the alloca
        const arr_type = local.ty;
        const arr_type_kind = llvm.getTypeKind(arr_type);

        if (arr_type_kind != llvm.c.LLVMArrayTypeKind) {
            return EmitError.UnsupportedFeature; // Only support fixed-size arrays for now
        }

        // Emit the index expression
        const index_val = try self.emitExpr(idx.index);

        // Get array length for bounds checking
        const array_len = llvm.Types.getArrayLength(arr_type);
        const len_val = llvm.Const.int64(self.ctx, @intCast(array_len));

        // Zero-extend or sign-extend index to i64 for comparison
        const index_type = llvm.typeOf(index_val);
        const index_bits = llvm.c.LLVMGetIntTypeWidth(index_type);
        const i64_type = llvm.Types.int64(self.ctx);

        const index_i64 = if (index_bits < 64)
            self.builder.buildZExt(index_val, i64_type, "idx.ext")
        else if (index_bits > 64)
            self.builder.buildTrunc(index_val, i64_type, "idx.trunc")
        else
            index_val;

        // Bounds check: index < length (unsigned comparison)
        const in_bounds = self.builder.buildICmp(
            llvm.c.LLVMIntULT,
            index_i64,
            len_val,
            "bounds.check",
        );

        // Create blocks for bounds check
        const func = self.current_function orelse return EmitError.InvalidAST;
        const ok_block = llvm.appendBasicBlock(self.ctx, func, "bounds.ok");
        const fail_block = llvm.appendBasicBlock(self.ctx, func, "bounds.fail");

        // Branch based on bounds check
        _ = self.builder.buildCondBr(in_bounds, ok_block, fail_block);

        // Fail block: trap/unreachable
        self.builder.positionAtEnd(fail_block);
        _ = self.builder.buildUnreachable();

        // Continue in OK block
        self.builder.positionAtEnd(ok_block);

        // Evaluate the right-hand side
        const rhs = try self.emitExpr(bin.right);

        // GEP to get pointer to array element
        var indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            index_val,
        };
        const elem_ptr = self.builder.buildGEP(arr_type, local.value, &indices, "elem.ptr");

        // For compound assignment, need to load current value and operate
        const value = switch (bin.op) {
            .assign => rhs,
            .add_assign => blk: {
                const elem_type = llvm.c.LLVMGetElementType(arr_type);
                const lhs = self.builder.buildLoad(elem_type, elem_ptr, "loadtmp");
                break :blk self.builder.buildAdd(lhs, rhs, "addtmp");
            },
            .sub_assign => blk: {
                const elem_type = llvm.c.LLVMGetElementType(arr_type);
                const lhs = self.builder.buildLoad(elem_type, elem_ptr, "loadtmp");
                break :blk self.builder.buildSub(lhs, rhs, "subtmp");
            },
            .mul_assign => blk: {
                const elem_type = llvm.c.LLVMGetElementType(arr_type);
                const lhs = self.builder.buildLoad(elem_type, elem_ptr, "loadtmp");
                break :blk self.builder.buildMul(lhs, rhs, "multmp");
            },
            .div_assign => blk: {
                const elem_type = llvm.c.LLVMGetElementType(arr_type);
                const lhs = self.builder.buildLoad(elem_type, elem_ptr, "loadtmp");
                break :blk self.builder.buildSDiv(lhs, rhs, "divtmp");
            },
            .mod_assign => blk: {
                const elem_type = llvm.c.LLVMGetElementType(arr_type);
                const lhs = self.builder.buildLoad(elem_type, elem_ptr, "loadtmp");
                break :blk self.builder.buildSRem(lhs, rhs, "modtmp");
            },
            else => return EmitError.InvalidAST,
        };

        // Store the value to the element
        _ = self.builder.buildStore(value, elem_ptr);

        // Return the stored value
        return value;
    }

    /// Emit struct field assignment: s.field = value
    fn emitFieldAssignment(self: *Emitter, bin: *ast.Binary) EmitError!llvm.ValueRef {
        const field = bin.left.field;

        // The struct must be a variable (identifier) for assignment to work
        const struct_id = switch (field.object) {
            .identifier => |id| id,
            else => return EmitError.UnsupportedFeature,
        };

        const local = self.named_values.get(struct_id.name) orelse
            return EmitError.InvalidAST;

        if (!local.is_alloca) {
            return EmitError.InvalidAST;
        }

        // Get struct type info
        const struct_name = local.struct_type_name orelse return EmitError.InvalidAST;
        const struct_info = self.struct_types.get(struct_name) orelse return EmitError.InvalidAST;

        // Find the field index
        var field_idx: ?u32 = null;
        for (struct_info.field_names, 0..) |name, i| {
            if (std.mem.eql(u8, name, field.field_name)) {
                field_idx = @intCast(i);
                break;
            }
        }
        const idx = field_idx orelse return EmitError.InvalidAST;

        // Evaluate the right-hand side
        const rhs = try self.emitExpr(bin.right);

        // For reference parameters, load the pointer first, then GEP into it
        // For regular struct parameters, GEP directly from the alloca
        const base_ptr = if (local.is_reference)
            self.builder.buildLoad(local.ty, local.value, "ref.load")
        else
            local.value;

        const gep_type = if (local.is_reference)
            local.reference_inner_type.?
        else
            local.ty;

        // GEP to get pointer to struct field
        var indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, @intCast(idx)),
        };
        const field_ptr = self.builder.buildGEP(gep_type, base_ptr, &indices, "field.ptr");

        // For compound assignment, need to load current value and operate
        const field_type = llvm.c.LLVMStructGetTypeAtIndex(gep_type, idx);
        const value = switch (bin.op) {
            .assign => rhs,
            .add_assign => blk: {
                const lhs = self.builder.buildLoad(field_type, field_ptr, "loadtmp");
                break :blk self.builder.buildAdd(lhs, rhs, "addtmp");
            },
            .sub_assign => blk: {
                const lhs = self.builder.buildLoad(field_type, field_ptr, "loadtmp");
                break :blk self.builder.buildSub(lhs, rhs, "subtmp");
            },
            .mul_assign => blk: {
                const lhs = self.builder.buildLoad(field_type, field_ptr, "loadtmp");
                break :blk self.builder.buildMul(lhs, rhs, "multmp");
            },
            .div_assign => blk: {
                const lhs = self.builder.buildLoad(field_type, field_ptr, "loadtmp");
                break :blk self.builder.buildSDiv(lhs, rhs, "divtmp");
            },
            .mod_assign => blk: {
                const lhs = self.builder.buildLoad(field_type, field_ptr, "loadtmp");
                break :blk self.builder.buildSRem(lhs, rhs, "modtmp");
            },
            else => return EmitError.InvalidAST,
        };

        // Store the value to the field
        _ = self.builder.buildStore(value, field_ptr);

        // Return the stored value
        return value;
    }

    /// Emit deref assignment: *ptr = value
    fn emitDerefAssignment(self: *Emitter, bin: *ast.Binary, un: *ast.Unary) EmitError!llvm.ValueRef {
        // Get the pointer from the deref operand (which should be a reference/pointer)
        const ptr = try self.emitExpr(un.operand);

        // Evaluate the right-hand side
        const rhs = try self.emitExpr(bin.right);

        // For compound assignment, need to load current value and operate
        const ptr_elem_type = llvm.c.LLVMGetElementType(llvm.typeOf(ptr));
        const value = switch (bin.op) {
            .assign => rhs,
            .add_assign => blk: {
                const lhs = self.builder.buildLoad(ptr_elem_type, ptr, "loadtmp");
                break :blk self.builder.buildAdd(lhs, rhs, "addtmp");
            },
            .sub_assign => blk: {
                const lhs = self.builder.buildLoad(ptr_elem_type, ptr, "loadtmp");
                break :blk self.builder.buildSub(lhs, rhs, "subtmp");
            },
            .mul_assign => blk: {
                const lhs = self.builder.buildLoad(ptr_elem_type, ptr, "loadtmp");
                break :blk self.builder.buildMul(lhs, rhs, "multmp");
            },
            .div_assign => blk: {
                const lhs = self.builder.buildLoad(ptr_elem_type, ptr, "loadtmp");
                break :blk self.builder.buildSDiv(lhs, rhs, "divtmp");
            },
            .mod_assign => blk: {
                const lhs = self.builder.buildLoad(ptr_elem_type, ptr, "loadtmp");
                break :blk self.builder.buildSRem(lhs, rhs, "modtmp");
            },
            else => return EmitError.InvalidAST,
        };

        // Store the value through the pointer
        _ = self.builder.buildStore(value, ptr);

        // Return the stored value
        return value;
    }

    fn emitLogicalBinary(self: *Emitter, bin: *ast.Binary) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        if (bin.op == .and_) {
            // Short-circuit AND: if LHS is false, skip RHS
            const rhs_bb = llvm.appendBasicBlock(self.ctx, func, "and.rhs");
            const merge_bb = llvm.appendBasicBlock(self.ctx, func, "and.merge");

            const lhs = try self.emitExpr(bin.left);
            const lhs_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            _ = self.builder.buildCondBr(lhs, rhs_bb, merge_bb);

            self.builder.positionAtEnd(rhs_bb);
            const rhs = try self.emitExpr(bin.right);
            const rhs_end_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            _ = self.builder.buildBr(merge_bb);

            self.builder.positionAtEnd(merge_bb);
            const phi = self.builder.buildPhi(llvm.Types.int1(self.ctx), "and.result");
            const false_val = llvm.Const.int1(self.ctx, false);
            var incoming_vals = [_]llvm.ValueRef{ false_val, rhs };
            var incoming_blocks = [_]llvm.BasicBlockRef{ lhs_bb, rhs_end_bb };
            llvm.addIncoming(phi, &incoming_vals, &incoming_blocks);
            return phi;
        } else {
            // Short-circuit OR: if LHS is true, skip RHS
            const rhs_bb = llvm.appendBasicBlock(self.ctx, func, "or.rhs");
            const merge_bb = llvm.appendBasicBlock(self.ctx, func, "or.merge");

            const lhs = try self.emitExpr(bin.left);
            const lhs_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            _ = self.builder.buildCondBr(lhs, merge_bb, rhs_bb);

            self.builder.positionAtEnd(rhs_bb);
            const rhs = try self.emitExpr(bin.right);
            const rhs_end_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            _ = self.builder.buildBr(merge_bb);

            self.builder.positionAtEnd(merge_bb);
            const phi = self.builder.buildPhi(llvm.Types.int1(self.ctx), "or.result");
            const true_val = llvm.Const.int1(self.ctx, true);
            var incoming_vals = [_]llvm.ValueRef{ true_val, rhs };
            var incoming_blocks = [_]llvm.BasicBlockRef{ lhs_bb, rhs_end_bb };
            llvm.addIncoming(phi, &incoming_vals, &incoming_blocks);
            return phi;
        }
    }

    fn emitUnary(self: *Emitter, un: *ast.Unary) EmitError!llvm.ValueRef {
        return switch (un.op) {
            .negate => {
                const operand = try self.emitExpr(un.operand);
                const op_ty = llvm.typeOf(operand);
                const type_kind = llvm.getTypeKind(op_ty);
                if (type_kind == llvm.c.LLVMFloatTypeKind or type_kind == llvm.c.LLVMDoubleTypeKind) {
                    return self.builder.buildFNeg(operand, "fnegtmp");
                }
                return self.builder.buildNeg(operand, "negtmp");
            },
            .not => {
                const operand = try self.emitExpr(un.operand);
                return self.builder.buildNot(operand, "nottmp");
            },
            .deref => {
                // Dereference a pointer: load the value from the pointer
                const operand = try self.emitExpr(un.operand);

                // Try to get the inner type from the operand
                // First, check if operand is an identifier with a known inner type
                const inner_type: llvm.TypeRef = if (un.operand == .identifier) blk: {
                    const id = un.operand.identifier;
                    if (self.named_values.get(id.name)) |local| {
                        if (local.inner_type) |inner| {
                            break :blk inner;
                        }
                    }
                    // Fallback: try to infer from expression
                    break :blk try self.inferDerefType(un.operand);
                } else try self.inferDerefType(un.operand);

                return self.builder.buildLoad(inner_type, operand, "deref");
            },
            .ref => {
                // Taking address of a value - for lvalues, return the alloca pointer
                // For now, handle identifiers which have an alloca
                if (un.operand == .identifier) {
                    const id = un.operand.identifier;
                    if (self.named_values.get(id.name)) |local| {
                        if (local.is_alloca) {
                            // Return the pointer to the alloca (the address)
                            return local.value;
                        }
                    }
                }
                // Fallback: emit the operand as-is (may need refinement)
                return try self.emitExpr(un.operand);
            },
            .ref_mut => {
                // Mutable reference - same as immutable ref for now
                if (un.operand == .identifier) {
                    const id = un.operand.identifier;
                    if (self.named_values.get(id.name)) |local| {
                        if (local.is_alloca) {
                            return local.value;
                        }
                    }
                }
                return try self.emitExpr(un.operand);
            },
        };
    }

    fn emitTypeCast(self: *Emitter, cast: *ast.TypeCast) EmitError!llvm.ValueRef {
        const value = try self.emitExpr(cast.expr);
        const src_type = llvm.typeOf(value);
        const src_kind = llvm.getTypeKind(src_type);

        // Get target type name
        const target_type_name: []const u8 = switch (cast.target_type) {
            .named => |n| n.name,
            else => return value, // Non-named types pass through
        };

        // Get target LLVM type
        const dest_type = self.getTypeByName(target_type_name) orelse return value;
        const dest_kind = llvm.getTypeKind(dest_type);

        // Same type - no conversion needed
        if (src_type == dest_type) {
            return value;
        }

        // Integer to Float
        if ((src_kind == llvm.c.LLVMIntegerTypeKind) and
            (dest_kind == llvm.c.LLVMFloatTypeKind or dest_kind == llvm.c.LLVMDoubleTypeKind))
        {
            // Check if source is signed (i8, i16, i32, i64, isize) or unsigned (u8, u16, u32, u64, usize)
            const is_signed = self.isSignedIntType(cast.expr);
            if (is_signed) {
                return self.builder.buildSIToFP(value, dest_type, "sitofp");
            } else {
                return self.builder.buildUIToFP(value, dest_type, "uitofp");
            }
        }

        // Float to Integer
        if ((src_kind == llvm.c.LLVMFloatTypeKind or src_kind == llvm.c.LLVMDoubleTypeKind) and
            dest_kind == llvm.c.LLVMIntegerTypeKind)
        {
            const is_signed = self.isSignedTypeName(target_type_name);
            if (is_signed) {
                return self.builder.buildFPToSI(value, dest_type, "fptosi");
            } else {
                return self.builder.buildFPToUI(value, dest_type, "fptoui");
            }
        }

        // Float to Float (f32 <-> f64)
        if ((src_kind == llvm.c.LLVMFloatTypeKind or src_kind == llvm.c.LLVMDoubleTypeKind) and
            (dest_kind == llvm.c.LLVMFloatTypeKind or dest_kind == llvm.c.LLVMDoubleTypeKind))
        {
            const src_bits = if (src_kind == llvm.c.LLVMFloatTypeKind) @as(u32, 32) else @as(u32, 64);
            const dest_bits = if (dest_kind == llvm.c.LLVMFloatTypeKind) @as(u32, 32) else @as(u32, 64);

            if (dest_bits > src_bits) {
                return self.builder.buildFPExt(value, dest_type, "fpext");
            } else if (dest_bits < src_bits) {
                return self.builder.buildFPTrunc(value, dest_type, "fptrunc");
            }
            return value;
        }

        // Integer to Integer
        if (src_kind == llvm.c.LLVMIntegerTypeKind and dest_kind == llvm.c.LLVMIntegerTypeKind) {
            const src_bits = llvm.getIntTypeWidth(src_type);
            const dest_bits = llvm.getIntTypeWidth(dest_type);

            if (dest_bits > src_bits) {
                // Widening
                const is_signed = self.isSignedIntType(cast.expr);
                if (is_signed) {
                    return self.builder.buildSExt(value, dest_type, "sext");
                } else {
                    return self.builder.buildZExt(value, dest_type, "zext");
                }
            } else if (dest_bits < src_bits) {
                // Narrowing
                return self.builder.buildTrunc(value, dest_type, "trunc");
            }
            return value;
        }

        // Fallback: return value unchanged
        return value;
    }

    fn getTypeByName(self: *Emitter, name: []const u8) ?llvm.TypeRef {
        if (std.mem.eql(u8, name, "i8")) return llvm.Types.int8(self.ctx);
        if (std.mem.eql(u8, name, "i16")) return llvm.Types.int16(self.ctx);
        if (std.mem.eql(u8, name, "i32")) return llvm.Types.int32(self.ctx);
        if (std.mem.eql(u8, name, "i64")) return llvm.Types.int64(self.ctx);
        if (std.mem.eql(u8, name, "i128")) return llvm.Types.int128(self.ctx);
        if (std.mem.eql(u8, name, "isize")) return llvm.Types.int64(self.ctx); // Assume 64-bit
        if (std.mem.eql(u8, name, "u8")) return llvm.Types.int8(self.ctx);
        if (std.mem.eql(u8, name, "u16")) return llvm.Types.int16(self.ctx);
        if (std.mem.eql(u8, name, "u32")) return llvm.Types.int32(self.ctx);
        if (std.mem.eql(u8, name, "u64")) return llvm.Types.int64(self.ctx);
        if (std.mem.eql(u8, name, "u128")) return llvm.Types.int128(self.ctx);
        if (std.mem.eql(u8, name, "usize")) return llvm.Types.int64(self.ctx); // Assume 64-bit
        if (std.mem.eql(u8, name, "f32")) return llvm.Types.float32(self.ctx);
        if (std.mem.eql(u8, name, "f64")) return llvm.Types.float64(self.ctx);
        if (std.mem.eql(u8, name, "bool")) return llvm.Types.int1(self.ctx);
        return null;
    }

    fn isSignedTypeName(_: *Emitter, name: []const u8) bool {
        return std.mem.startsWith(u8, name, "i") and !std.mem.eql(u8, name, "isize") or
            std.mem.eql(u8, name, "isize");
    }

    fn isSignedIntType(self: *Emitter, expr: ast.Expr) bool {
        _ = self;
        // Try to determine signedness from expression
        // For literals, check if the value is negative
        if (expr == .literal) {
            const lit = expr.literal;
            if (lit.kind == .int) {
                // Negative values are definitely signed
                if (lit.kind.int < 0) return true;
                // Default: integers are signed (i32) in Klar
                return true;
            }
        }
        // For identifiers, we'd need type info from the checker
        // Default to signed for safety (i32 is the default int type)
        return true;
    }

    /// Infer the type that results from dereferencing an expression.
    /// Used when the inner type is not explicitly tracked.
    fn inferDerefType(self: *Emitter, expr: ast.Expr) EmitError!llvm.TypeRef {
        // For Rc[T] method calls, try to determine T
        if (expr == .method_call) {
            const method = expr.method_call;
            if (method.object == .identifier) {
                const obj_name = method.object.identifier.name;
                // Rc.new(value) - the inner type is the type of value
                if (std.mem.eql(u8, obj_name, "Rc") and std.mem.eql(u8, method.method_name, "new")) {
                    if (method.args.len > 0) {
                        return try self.inferExprType(method.args[0]);
                    }
                }
            }
            // clone() returns same Rc type, need to trace back
            if (std.mem.eql(u8, method.method_name, "clone")) {
                return try self.inferDerefType(method.object);
            }
        }

        // For identifiers, check the named_values for inner_type
        if (expr == .identifier) {
            const id = expr.identifier;
            if (self.named_values.get(id.name)) |local| {
                if (local.inner_type) |inner| {
                    return inner;
                }
            }
        }

        // Default to i32 if we can't infer
        return llvm.Types.int32(self.ctx);
    }

    /// Try to get the inner type of an Rc, Arc, or Cell expression.
    /// Returns null if the expression is not an Rc, Arc, or Cell type.
    fn tryGetRcInnerType(self: *Emitter, expr: ast.Expr) ?llvm.TypeRef {
        // Check for Rc.new(value), Arc.new(value), or Cell.new(value) - inner type is type of value
        if (expr == .method_call) {
            const method = expr.method_call;
            if (method.object == .identifier) {
                const obj_name = method.object.identifier.name;
                // Rc.new(value)
                if (std.mem.eql(u8, obj_name, "Rc") and std.mem.eql(u8, method.method_name, "new")) {
                    if (method.args.len > 0) {
                        return self.inferExprType(method.args[0]) catch null;
                    }
                }
                // Arc.new(value)
                if (std.mem.eql(u8, obj_name, "Arc") and std.mem.eql(u8, method.method_name, "new")) {
                    if (method.args.len > 0) {
                        return self.inferExprType(method.args[0]) catch null;
                    }
                }
                // Cell.new(value)
                if (std.mem.eql(u8, obj_name, "Cell") and std.mem.eql(u8, method.method_name, "new")) {
                    if (method.args.len > 0) {
                        return self.inferExprType(method.args[0]) catch null;
                    }
                }
            }
            // For clone(), the inner type is the same as the receiver's inner type
            if (std.mem.eql(u8, method.method_name, "clone")) {
                return self.tryGetRcInnerType(method.object);
            }
        }

        // Check for identifier that is already an Rc, Arc, or Cell
        if (expr == .identifier) {
            const id = expr.identifier;
            if (self.named_values.get(id.name)) |local| {
                return local.inner_type;
            }
        }

        return null;
    }

    /// Check if an expression represents an Arc type.
    fn isArcType(self: *Emitter, expr: ast.Expr) bool {
        if (expr == .method_call) {
            const method = expr.method_call;
            if (method.object == .identifier) {
                const obj_name = method.object.identifier.name;
                if (std.mem.eql(u8, obj_name, "Arc") and std.mem.eql(u8, method.method_name, "new")) {
                    return true;
                }
            }
            // For clone(), check the receiver
            if (std.mem.eql(u8, method.method_name, "clone")) {
                return self.isArcType(method.object);
            }
        }

        // Check for identifier that is already an Arc
        if (expr == .identifier) {
            const id = expr.identifier;
            if (self.named_values.get(id.name)) |local| {
                return local.is_arc;
            }
        }

        return false;
    }

    fn isRcType(self: *Emitter, expr: ast.Expr) bool {
        if (expr == .method_call) {
            const method = expr.method_call;
            if (method.object == .identifier) {
                const obj_name = method.object.identifier.name;
                if (std.mem.eql(u8, obj_name, "Rc") and std.mem.eql(u8, method.method_name, "new")) {
                    return true;
                }
            }
            // For clone(), check the receiver
            if (std.mem.eql(u8, method.method_name, "clone")) {
                return self.isRcType(method.object);
            }
        }

        // Check for identifier that is already an Rc (has inner_type but is not Arc)
        if (expr == .identifier) {
            const id = expr.identifier;
            if (self.named_values.get(id.name)) |local| {
                return local.inner_type != null and !local.is_arc;
            }
        }

        return false;
    }

    /// Information about a closure type extracted from its TypeExpr annotation.
    const ClosureTypeInfo2 = struct {
        return_type: llvm.TypeRef,
        param_types: ?[]const llvm.TypeRef,
    };

    /// Try to extract closure type information from a TypeExpr.
    /// Returns null if the type is not a function type.
    /// Note: The param_types slice is allocated from the emitter's allocator.
    /// The memory is intentionally not freed during the emitter's lifetime as a simplification.
    fn tryGetClosureTypeInfo(self: *Emitter, type_expr: ast.TypeExpr) ?ClosureTypeInfo2 {
        if (type_expr != .function) return null;

        const fn_type = type_expr.function;

        // Convert return type to LLVM
        const return_type = self.typeExprToLLVM(fn_type.return_type) catch return null;

        // For param types, we only need them if we're actually going to call the closure
        // with the typed call path. Since we primarily need the return type, and param
        // types can be inferred from the actual call arguments, we can skip allocating
        // param_types to avoid the memory management complexity.
        // The emitter will use null param_types and fall back to inferring from args.

        return ClosureTypeInfo2{
            .return_type = return_type,
            .param_types = null, // Simplified: param types inferred from call args
        };
    }

    fn emitCall(self: *Emitter, call: *ast.Call) EmitError!llvm.ValueRef {
        // Check if this is a comptime function call with a precomputed value
        if (self.type_checker) |tc| {
            if (tc.comptime_call_values.get(call)) |comptime_value| {
                // Emit the precomputed constant value
                return self.emitComptimeValue(comptime_value);
            }
        }

        // Check if callee is a direct function reference
        const func_name = switch (call.callee) {
            .identifier => |id| id.name,
            else => null,
        };

        // Check for builtin functions first
        if (func_name) |name| {
            if (std.mem.eql(u8, name, "print")) {
                return self.emitPrint(call.args, false);
            } else if (std.mem.eql(u8, name, "println")) {
                return self.emitPrint(call.args, true);
            } else if (std.mem.eql(u8, name, "readline")) {
                return self.emitReadline();
            } else if (std.mem.eql(u8, name, "panic")) {
                return self.emitPanic(call.args);
            } else if (std.mem.eql(u8, name, "assert")) {
                return self.emitAssert(call.args);
            } else if (std.mem.eql(u8, name, "assert_eq")) {
                return self.emitAssertEq(call.args);
            } else if (std.mem.eql(u8, name, "dbg")) {
                return self.emitDbg(call.args);
            } else if (std.mem.eql(u8, name, "debug")) {
                return self.emitDebug(call);
            } else if (std.mem.eql(u8, name, "type_name")) {
                return self.emitTypeName(call.args);
            } else if (std.mem.eql(u8, name, "len")) {
                return self.emitLen(call.args);
            } else if (std.mem.eql(u8, name, "Ok")) {
                // Result::Ok(value) constructor
                return self.emitOkCall(call.args);
            } else if (std.mem.eql(u8, name, "Err")) {
                // Result::Err(error) constructor
                return self.emitErrCall(call.args);
            } else if (std.mem.eql(u8, name, "Some")) {
                // Optional::Some(value) constructor
                return self.emitSomeCall(call.args);
            } else if (std.mem.eql(u8, name, "None")) {
                // Optional::None constructor
                return self.emitNoneCall();
            } else if (std.mem.eql(u8, name, "stdout")) {
                // stdout() -> Stdout
                // Returns the stdout FILE* handle
                const stdout_fn = self.getOrDeclareStdout();
                return self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stdout_fn), stdout_fn, &[_]llvm.ValueRef{}, "stdout.handle");
            } else if (std.mem.eql(u8, name, "stderr")) {
                // stderr() -> Stderr
                // Returns the stderr FILE* handle
                const stderr_fn = self.getOrDeclareStderr();
                return self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stderr_fn), stderr_fn, &[_]llvm.ValueRef{}, "stderr.handle");
            } else if (std.mem.eql(u8, name, "stdin")) {
                // stdin() -> Stdin
                // Returns the stdin FILE* handle
                const stdin_fn = self.getOrDeclareStdin();
                return self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stdin_fn), stdin_fn, &[_]llvm.ValueRef{}, "stdin.handle");
            }
            // FFI Pointer Functions
            else if (std.mem.eql(u8, name, "is_null")) {
                return self.emitIsNull(call);
            } else if (std.mem.eql(u8, name, "unwrap_ptr")) {
                return self.emitUnwrapPtr(call);
            } else if (std.mem.eql(u8, name, "read")) {
                return self.emitRead(call);
            } else if (std.mem.eql(u8, name, "write")) {
                return self.emitWrite(call);
            } else if (std.mem.eql(u8, name, "offset")) {
                return self.emitOffset(call);
            } else if (std.mem.eql(u8, name, "ref_to_ptr")) {
                return self.emitRefToPtr(call);
            } else if (std.mem.eql(u8, name, "ptr_cast")) {
                return self.emitPtrCast(call);
            }
        }

        // Check if this is a monomorphized generic function call
        if (self.type_checker) |checker| {
            if (checker.getCallResolution(call)) |mangled_name| {
                const mangled_z = self.allocator.dupeZ(u8, mangled_name) catch return EmitError.OutOfMemory;
                defer self.allocator.free(mangled_z);

                if (self.module.getNamedFunction(mangled_z)) |func| {
                    // Get function type and parameter types upfront for arg conversion
                    const fn_type = llvm.getGlobalValueType(func);
                    const param_count = llvm.c.LLVMCountParamTypes(fn_type);
                    var param_types: [32]llvm.TypeRef = undefined;
                    if (param_count <= 32) {
                        llvm.c.LLVMGetParamTypes(fn_type, &param_types);
                    }

                    // Check if this function uses sret
                    if (self.sret_functions.get(mangled_name)) |sret_return_type| {
                        // Sret call: allocate space, prepend pointer, call, load result
                        const sret_alloca = self.builder.buildAlloca(sret_return_type, "sret.tmp");

                        var args = std.ArrayListUnmanaged(llvm.ValueRef){};
                        defer args.deinit(self.allocator);

                        // First argument is the sret pointer
                        args.append(self.allocator, sret_alloca) catch return EmitError.OutOfMemory;

                        // Then the user arguments (sret is first param, so user args start at index 1)
                        for (call.args, 0..) |arg, i| {
                            const arg_value = try self.emitExpr(arg);
                            const converted = if (param_count <= 32 and i + 1 < param_count)
                                self.convertArgIfNeeded(arg_value, param_types[i + 1])
                            else
                                arg_value;
                            args.append(self.allocator, converted) catch return EmitError.OutOfMemory;
                        }

                        const call_inst = self.builder.buildCall(fn_type, func, args.items, "");

                        // Add sret attribute to the call site
                        const sret_kind = self.getSretAttrKind();
                        const sret_attr = llvm.createTypeAttribute(self.ctx, sret_kind, sret_return_type);
                        llvm.addCallSiteAttribute(call_inst, 1, sret_attr);

                        // Load and return the result
                        return self.builder.buildLoad(sret_return_type, sret_alloca, "sret.load");
                    }

                    // Normal call (non-sret)
                    var args = std.ArrayListUnmanaged(llvm.ValueRef){};
                    defer args.deinit(self.allocator);

                    for (call.args, 0..) |arg, i| {
                        const arg_value = try self.emitExpr(arg);
                        const converted = if (param_count <= 32 and i < param_count)
                            self.convertArgIfNeeded(arg_value, param_types[i])
                        else
                            arg_value;
                        args.append(self.allocator, converted) catch return EmitError.OutOfMemory;
                    }

                    const return_type = llvm.getReturnType(fn_type);
                    const call_name_str: [:0]const u8 = if (llvm.isVoidType(return_type)) "" else "calltmp";
                    return self.builder.buildCall(fn_type, func, args.items, call_name_str);
                }
            }
        }

        // Try to find as a module-level function
        if (func_name) |name| {
            // First, try to find the function directly by name
            var lookup_name = name;

            // Check if this is an aliased import - if so, use the original name
            if (self.type_checker) |tc| {
                if (tc.lookupSymbol(name)) |sym| {
                    if (sym.original_name) |orig| {
                        lookup_name = orig;
                    }
                }
            }

            const name_z = self.allocator.dupeZ(u8, lookup_name) catch return EmitError.OutOfMemory;
            defer self.allocator.free(name_z);

            if (self.module.getNamedFunction(name_z)) |func| {
                // Get function type and parameter types upfront for arg conversion
                const fn_type = llvm.getGlobalValueType(func);
                const param_count = llvm.c.LLVMCountParamTypes(fn_type);
                var param_types: [32]llvm.TypeRef = undefined;
                if (param_count <= 32) {
                    llvm.c.LLVMGetParamTypes(fn_type, &param_types);
                }

                // Check if this function uses sret
                if (self.sret_functions.get(lookup_name)) |sret_return_type| {
                    // Sret call: allocate space, prepend pointer, call, load result
                    const sret_alloca = self.builder.buildAlloca(sret_return_type, "sret.tmp");

                    var args = std.ArrayListUnmanaged(llvm.ValueRef){};
                    defer args.deinit(self.allocator);

                    // First argument is the sret pointer
                    args.append(self.allocator, sret_alloca) catch return EmitError.OutOfMemory;

                    // Then the user arguments (sret is first param, so user args start at index 1)
                    for (call.args, 0..) |arg, i| {
                        const arg_value = try self.emitExpr(arg);
                        const converted = if (param_count <= 32 and i + 1 < param_count)
                            self.convertArgIfNeeded(arg_value, param_types[i + 1])
                        else
                            arg_value;
                        args.append(self.allocator, converted) catch return EmitError.OutOfMemory;
                    }

                    const call_inst = self.builder.buildCall(fn_type, func, args.items, "");

                    // Add sret attribute to the call site
                    const sret_kind = self.getSretAttrKind();
                    const sret_attr = llvm.createTypeAttribute(self.ctx, sret_kind, sret_return_type);
                    llvm.addCallSiteAttribute(call_inst, 1, sret_attr);

                    // Load and return the result
                    return self.builder.buildLoad(sret_return_type, sret_alloca, "sret.load");
                }

                // Check if this is an extern function with ABI-lowered types, out params, or struct return
                if (self.extern_functions.get(lookup_name)) |extern_info| {
                    const has_abi_lowered_params = extern_info.abi_lowered_param_types != null;
                    const has_abi_lowered_return = extern_info.abi_lowered_return_type != null;
                    const has_out_params = extern_info.out_params != 0;

                    if (has_abi_lowered_return or has_abi_lowered_params or has_out_params) {
                        // Build args with ABI lowering for struct parameters and out parameter handling
                        var args = std.ArrayListUnmanaged(llvm.ValueRef){};
                        defer args.deinit(self.allocator);

                        for (call.args, 0..) |arg, i| {
                            // Check if this is an out parameter
                            const is_out_param = (i < 64) and ((extern_info.out_params & (@as(u64, 1) << @intCast(i))) != 0);

                            if (is_out_param) {
                                // For out parameters, we need to pass a pointer to the variable
                                if (arg == .out_arg) {
                                    const out_arg = arg.out_arg;
                                    // Look up the variable's alloca
                                    if (self.named_values.get(out_arg.name)) |local| {
                                        // Pass the address of the variable
                                        args.append(self.allocator, local.value) catch return EmitError.OutOfMemory;
                                    } else {
                                        // Variable not found - this should have been caught by the checker
                                        return EmitError.InvalidAST;
                                    }
                                } else {
                                    // Non-out_arg for out parameter - should be caught by checker
                                    return EmitError.InvalidAST;
                                }
                            } else {
                                // Regular parameter
                                const arg_value = try self.emitExpr(arg);

                                // Check if this parameter needs ABI lowering (struct -> int)
                                if (extern_info.abi_lowered_param_types) |lowered_params| {
                                    if (i < lowered_params.len) {
                                        if (lowered_params[i]) |lowered| {
                                            // Convert struct to integer by storing and loading as int
                                            const tmp = self.builder.buildAlloca(lowered.struct_type, "abi.param.tmp");
                                            _ = self.builder.buildStore(arg_value, tmp);
                                            const int_val = self.builder.buildLoad(lowered.int_type, tmp, "abi.param.int");
                                            args.append(self.allocator, int_val) catch return EmitError.OutOfMemory;
                                            continue;
                                        }
                                    }
                                }
                                args.append(self.allocator, arg_value) catch return EmitError.OutOfMemory;
                            }
                        }

                        // fn_type already declared in outer scope
                        const call_result = self.builder.buildCall(fn_type, func, args.items, if (has_abi_lowered_return) "abi.int" else "calltmp");

                        // If return was ABI-lowered, convert integer back to struct
                        if (extern_info.abi_lowered_return_type) |struct_type| {
                            const tmp_alloca = self.builder.buildAlloca(struct_type, "abi.struct.tmp");
                            _ = self.builder.buildStore(call_result, tmp_alloca);
                            return self.builder.buildLoad(struct_type, tmp_alloca, "abi.struct");
                        }
                        return call_result;
                    }
                }

                // Normal direct function call (non-sret)
                var args = std.ArrayListUnmanaged(llvm.ValueRef){};
                defer args.deinit(self.allocator);

                for (call.args, 0..) |arg, i| {
                    const arg_value = try self.emitExpr(arg);
                    const converted = if (param_count <= 32 and i < param_count)
                        self.convertArgIfNeeded(arg_value, param_types[i])
                    else
                        arg_value;
                    args.append(self.allocator, converted) catch return EmitError.OutOfMemory;
                }

                const return_type = llvm.getReturnType(fn_type);
                const call_name_str: [:0]const u8 = if (llvm.isVoidType(return_type)) "" else "calltmp";
                return self.builder.buildCall(fn_type, func, args.items, call_name_str);
            }

            // Check if it's a local variable (closure)
            if (self.named_values.get(name)) |local| {
                // Load the closure value from the local variable
                const closure_struct_type = self.getClosureStructType();
                const closure_value = if (local.is_alloca)
                    self.builder.buildLoad(closure_struct_type, local.value, "closure.load")
                else
                    local.value;
                return self.emitClosureCallTyped(closure_value, call.args, local.closure_return_type, local.closure_param_types);
            }
        }

        // Generic callee - evaluate it and call as closure
        const callee_value = try self.emitExpr(call.callee);
        return self.emitClosureCallTyped(callee_value, call.args, null, null);
    }

    /// Emit a call to a closure value with optional type information.
    /// Closure struct is { fn_ptr: ptr, env_ptr: ptr }
    /// If return_type and param_types are provided, they are used for the function signature.
    /// Otherwise, defaults to i32 return type and i32 parameters.
    fn emitClosureCallTyped(
        self: *Emitter,
        closure_value: llvm.ValueRef,
        args: []const ast.Expr,
        return_type: ?llvm.TypeRef,
        param_types_info: ?[]const llvm.TypeRef,
    ) EmitError!llvm.ValueRef {
        // Closure struct type: { fn_ptr, env_ptr }
        const closure_struct_type = self.getClosureStructType();

        // Allocate space to store the closure value (since we have it by value)
        const closure_alloca = self.builder.buildAlloca(closure_struct_type, "closure.tmp");
        _ = self.builder.buildStore(closure_value, closure_alloca);

        // Load function pointer
        var fn_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "fn.ptr.ptr");
        const fn_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), fn_ptr_gep, "fn.ptr");

        // Load environment pointer
        var env_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "env.ptr.ptr");
        const env_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), env_ptr_gep, "env.ptr");

        // Build argument list: env_ptr + user args
        var call_args = std.ArrayListUnmanaged(llvm.ValueRef){};
        defer call_args.deinit(self.allocator);

        call_args.append(self.allocator, env_ptr) catch return EmitError.OutOfMemory;

        for (args) |arg| {
            call_args.append(self.allocator, try self.emitExpr(arg)) catch return EmitError.OutOfMemory;
        }

        // Build function type for the call
        // Use provided types if available, otherwise default to i32
        var param_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer param_types.deinit(self.allocator);

        // First param is always the environment pointer
        param_types.append(self.allocator, llvm.Types.pointer(self.ctx)) catch return EmitError.OutOfMemory;

        // Add user parameter types
        if (param_types_info) |pti| {
            // Use the provided parameter types
            for (pti) |pt| {
                param_types.append(self.allocator, pt) catch return EmitError.OutOfMemory;
            }
        } else {
            // Default to i32 for each argument
            for (args) |_| {
                param_types.append(self.allocator, llvm.Types.int32(self.ctx)) catch return EmitError.OutOfMemory;
            }
        }

        // Use provided return type or default to i32
        const actual_return_type = return_type orelse llvm.Types.int32(self.ctx);
        const fn_type = llvm.Types.function(actual_return_type, param_types.items, false);

        // Call through function pointer
        const call_name: [:0]const u8 = if (llvm.isVoidType(actual_return_type)) "" else "closure.call";
        return self.builder.buildCall(fn_type, fn_ptr, call_args.items, call_name);
    }

    /// Emit an if statement (no value produced, no PHI nodes).
    fn emitIfStmt(self: *Emitter, if_stmt: *ast.IfStmt) EmitError!void {
        const func = self.current_function orelse return EmitError.InvalidAST;

        const cond = try self.emitExpr(if_stmt.condition);

        // Create blocks
        const then_bb = llvm.appendBasicBlock(self.ctx, func, "then");
        const else_bb = if (if_stmt.else_branch != null)
            llvm.appendBasicBlock(self.ctx, func, "else")
        else
            null;
        const merge_bb = llvm.appendBasicBlock(self.ctx, func, "ifcont");

        // Branch to then or else/merge
        if (else_bb) |eb| {
            _ = self.builder.buildCondBr(cond, then_bb, eb);
        } else {
            _ = self.builder.buildCondBr(cond, then_bb, merge_bb);
        }

        // Emit then block
        self.builder.positionAtEnd(then_bb);
        self.has_terminator = false;
        _ = try self.emitBlock(if_stmt.then_branch);
        const then_has_term = self.has_terminator;
        if (!then_has_term) {
            _ = self.builder.buildBr(merge_bb);
        }

        // Emit else block if present
        var else_has_term = false;
        if (if_stmt.else_branch) |else_branch| {
            self.builder.positionAtEnd(else_bb.?);
            self.has_terminator = false;
            switch (else_branch.*) {
                .block => |block| {
                    _ = try self.emitBlock(block);
                },
                .if_stmt => |nested_if| {
                    try self.emitIfStmt(nested_if);
                },
            }
            else_has_term = self.has_terminator;
            if (!else_has_term) {
                _ = self.builder.buildBr(merge_bb);
            }
        }

        // Position at merge block
        self.builder.positionAtEnd(merge_bb);

        // If both branches terminate (e.g., both return), the merge block is unreachable
        if (then_has_term and (if_stmt.else_branch != null and else_has_term)) {
            _ = self.builder.buildUnreachable();
            self.has_terminator = true;
        } else {
            self.has_terminator = false;
        }
    }

    /// Emit a match statement (no value produced, no PHI nodes).
    /// Creates a chain of conditional branches that test each pattern in order.
    fn emitMatchStmt(self: *Emitter, match_stmt: *ast.MatchStmt) EmitError!void {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Emit the subject expression
        const subject_val = try self.emitExpr(match_stmt.subject);

        // Get the subject's semantic type for pattern binding
        // First, try to look up from named_values if subject is an identifier
        const subject_type: ?types.Type = blk: {
            if (match_stmt.subject == .identifier) {
                const var_name = match_stmt.subject.identifier.name;
                if (self.named_values.get(var_name)) |local| {
                    if (local.semantic_type) |st| {
                        break :blk st;
                    }
                }
            }
            // Handle field access on tuples (e.g., tuple.0, tuple.1)
            if (match_stmt.subject == .field) {
                const field = match_stmt.subject.field;
                // Check if the object is an identifier we know about
                if (field.object == .identifier) {
                    const obj_name = field.object.identifier.name;
                    if (self.named_values.get(obj_name)) |local| {
                        if (local.semantic_type) |obj_type| {
                            // Check if it's a tuple type
                            if (obj_type == .tuple) {
                                // Parse the field name as a tuple index
                                if (std.fmt.parseInt(usize, field.field_name, 10)) |idx| {
                                    if (idx < obj_type.tuple.elements.len) {
                                        break :blk obj_type.tuple.elements[idx];
                                    }
                                } else |_| {}
                            }
                        }
                    }
                }
            }
            // Fall back to type checker (may not work if scope changed)
            if (self.type_checker) |tc| {
                const tc_mut = @constCast(tc);
                const t = tc_mut.checkExpr(match_stmt.subject);
                if (t != .unknown and t != .error_type) break :blk t;
            }
            break :blk null;
        };

        // Create the merge block for after all arms
        const merge_bb = llvm.appendBasicBlock(self.ctx, func, "match.merge");

        // Create a "match failed" block with unreachable (for non-exhaustive matches)
        const match_failed_bb = llvm.appendBasicBlock(self.ctx, func, "match.failed");

        // Process each arm
        const num_arms = match_stmt.arms.len;
        var all_arms_terminate = true;
        for (match_stmt.arms, 0..) |arm, i| {
            const is_last_arm = (i == num_arms - 1);

            // Create blocks for this arm
            const arm_body_bb = llvm.appendBasicBlock(self.ctx, func, "match.arm");
            // For last arm, failed pattern goes to match_failed, not merge
            const next_arm_bb = if (is_last_arm)
                match_failed_bb
            else
                llvm.appendBasicBlock(self.ctx, func, "match.next");

            // Emit pattern matching condition
            const pattern_matches = try self.emitPatternMatch(arm.pattern, subject_val, subject_type);

            // Check guard if present
            const condition = if (arm.guard) |guard| blk: {
                // Create a block to evaluate the guard
                const guard_bb = llvm.appendBasicBlock(self.ctx, func, "match.guard");
                _ = self.builder.buildCondBr(pattern_matches, guard_bb, next_arm_bb);

                // Evaluate guard
                self.builder.positionAtEnd(guard_bb);
                const guard_val = try self.emitExpr(guard);
                // Combine pattern match + guard
                break :blk guard_val;
            } else pattern_matches;

            // Branch based on match result
            _ = self.builder.buildCondBr(condition, arm_body_bb, next_arm_bb);

            // Emit arm body
            self.builder.positionAtEnd(arm_body_bb);
            self.has_terminator = false;

            // Push a new scope for pattern bindings
            try self.pushScope(false);
            defer self.popScope();

            // Bind pattern variables with semantic type info
            try self.bindPatternVariables(arm.pattern, subject_val, subject_type);

            // Emit the arm body (as a block)
            _ = try self.emitBlock(arm.body);
            const arm_has_term = self.has_terminator;

            if (!arm_has_term) {
                _ = self.builder.buildBr(merge_bb);
                all_arms_terminate = false;
            }

            // Move to next arm block
            if (!is_last_arm) {
                self.builder.positionAtEnd(next_arm_bb);
            }
        }

        // Emit match failed block - this should be unreachable for exhaustive matches
        self.builder.positionAtEnd(match_failed_bb);
        _ = self.builder.buildUnreachable();

        // Position at merge block
        self.builder.positionAtEnd(merge_bb);

        // If all arms terminate, merge block is unreachable
        if (all_arms_terminate) {
            _ = self.builder.buildUnreachable();
            self.has_terminator = true;
        } else {
            self.has_terminator = false;
        }
    }

    /// Emit code that evaluates to true (i1) if the pattern matches the subject.
    fn emitPatternMatch(self: *Emitter, pattern: ast.Pattern, subject: llvm.ValueRef, subject_type: ?types.Type) EmitError!llvm.ValueRef {
        return switch (pattern) {
            .wildcard => {
                // Wildcard always matches
                return llvm.Const.int1(self.ctx, true);
            },
            .literal => |lit| {
                // Compare subject to literal value
                return self.emitLiteralPatternMatch(lit, subject);
            },
            .binding => {
                // Binding always matches (variable capture is done in bindPatternVariables)
                return llvm.Const.int1(self.ctx, true);
            },
            .variant => |v| {
                // Check enum tag matches
                return self.emitVariantPatternMatch(v, subject, subject_type);
            },
            .or_pattern => |o| {
                // Any alternative matches
                var result = llvm.Const.int1(self.ctx, false);
                for (o.alternatives) |alt| {
                    const alt_match = try self.emitPatternMatch(alt, subject, subject_type);
                    result = self.builder.buildOr(result, alt_match, "or.pattern");
                }
                return result;
            },
            .guarded => |g| {
                // Just check the pattern; guard is handled separately
                return self.emitPatternMatch(g.pattern, subject, subject_type);
            },
            .tuple_pattern => |t| {
                // Check each element matches
                var result = llvm.Const.int1(self.ctx, true);
                for (t.elements, 0..) |elem, i| {
                    // Extract tuple element
                    var indices = [_]llvm.ValueRef{
                        llvm.Const.int32(self.ctx, 0),
                        llvm.Const.int32(self.ctx, @intCast(i)),
                    };
                    const subject_llvm_type = llvm.typeOf(subject);
                    const elem_val = self.builder.buildGEP(subject_llvm_type, subject, &indices, "tuple.elem");
                    // Get element type from tuple type if available
                    const elem_type: ?types.Type = if (subject_type) |st| blk: {
                        if (st == .tuple and i < st.tuple.elements.len) {
                            break :blk st.tuple.elements[i];
                        }
                        break :blk null;
                    } else null;
                    const elem_match = try self.emitPatternMatch(elem, elem_val, elem_type);
                    result = self.builder.buildAnd(result, elem_match, "tuple.match");
                }
                return result;
            },
            .struct_pattern => {
                // For struct patterns, we need to match field by field
                // For now, return true (simplified)
                return llvm.Const.int1(self.ctx, true);
            },
        };
    }

    /// Emit comparison for a literal pattern.
    fn emitLiteralPatternMatch(self: *Emitter, lit: ast.PatternLiteral, subject: llvm.ValueRef) llvm.ValueRef {
        return switch (lit.kind) {
            .int => |v| {
                const lit_val = if (v >= std.math.minInt(i32) and v <= std.math.maxInt(i32))
                    llvm.Const.int32(self.ctx, @intCast(v))
                else
                    llvm.Const.int64(self.ctx, @intCast(v));
                return self.builder.buildICmp(llvm.c.LLVMIntEQ, subject, lit_val, "int.match");
            },
            .float => |v| {
                const lit_val = llvm.Const.float64(self.ctx, v);
                return self.builder.buildFCmp(llvm.c.LLVMRealOEQ, subject, lit_val, "float.match");
            },
            .bool_ => |v| {
                const lit_val = llvm.Const.int1(self.ctx, v);
                return self.builder.buildICmp(llvm.c.LLVMIntEQ, subject, lit_val, "bool.match");
            },
            .char => |v| {
                const lit_val = llvm.Const.int(llvm.Types.int32(self.ctx), v, false);
                return self.builder.buildICmp(llvm.c.LLVMIntEQ, subject, lit_val, "char.match");
            },
            .string => |s| {
                // String comparison - call strcmp or similar
                // For now, simplified: compare pointers (won't work for different string instances)
                const str_z = self.allocator.dupeZ(u8, s) catch return llvm.Const.int1(self.ctx, false);
                defer self.allocator.free(str_z);
                const lit_val = self.builder.buildGlobalStringPtr(str_z, "str.pat");
                return self.builder.buildICmp(llvm.c.LLVMIntEQ, subject, lit_val, "str.match");
            },
        };
    }

    /// Emit code to check if an enum variant matches.
    fn emitVariantPatternMatch(self: *Emitter, pat: *ast.VariantPattern, subject: llvm.ValueRef, subject_type: ?types.Type) EmitError!llvm.ValueRef {
        // Get the enum type to find the variant index
        const variant_index = try self.lookupVariantIndex(pat, subject_type);

        // Determine tag type: i1 for Result/Optional, i8 for regular enums
        const tag_type: llvm.TypeRef = if (subject_type) |st| blk: {
            if (st == .result or st == .optional) {
                break :blk llvm.Types.int1(self.ctx);
            }
            break :blk llvm.Types.int8(self.ctx);
        } else llvm.Types.int8(self.ctx);

        // Extract the tag from subject (field 0)
        const subject_llvm_type = llvm.typeOf(subject);
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };

        // For value types (not pointers), we need to allocate and then GEP
        // Check if subject is a struct type (value) or pointer
        const type_kind = llvm.getTypeKind(subject_llvm_type);
        if (type_kind == llvm.c.LLVMStructTypeKind) {
            // Subject is a value, extract tag directly using extractvalue
            const tag_val = self.builder.buildExtractValue(subject, 0, "enum.tag");
            const expected_tag = llvm.Const.int(tag_type, variant_index, false);
            return self.builder.buildICmp(llvm.c.LLVMIntEQ, tag_val, expected_tag, "variant.match");
        } else {
            // Subject is a pointer, use GEP
            const tag_ptr = self.builder.buildGEP(subject_llvm_type, subject, &tag_indices, "enum.tag.ptr");
            const tag_val = self.builder.buildLoad(tag_type, tag_ptr, "enum.tag");
            const expected_tag = llvm.Const.int(tag_type, variant_index, false);
            return self.builder.buildICmp(llvm.c.LLVMIntEQ, tag_val, expected_tag, "variant.match");
        }
    }

    /// Look up the variant index for a pattern.
    fn lookupVariantIndex(self: *Emitter, pat: *ast.VariantPattern, subject_type: ?types.Type) EmitError!u32 {
        // Handle shorthand patterns (no explicit type_expr) for built-in types
        if (pat.type_expr == null) {
            if (subject_type) |st| {
                // Result type: tag 0 = Err, tag 1 = Ok (i1 representation)
                if (st == .result) {
                    if (std.mem.eql(u8, pat.variant_name, "Ok")) return 1;
                    if (std.mem.eql(u8, pat.variant_name, "Err")) return 0;
                    return EmitError.InvalidAST;
                }
                // Optional type: tag 0 = None, tag 1 = Some (i1 representation)
                if (st == .optional) {
                    if (std.mem.eql(u8, pat.variant_name, "None")) return 0;
                    if (std.mem.eql(u8, pat.variant_name, "Some")) return 1;
                    return EmitError.InvalidAST;
                }
            }
            // No type info and no explicit type - cannot determine variant
            return EmitError.UnsupportedFeature;
        }

        // Get the enum type name from the pattern
        const enum_name: []const u8 = if (pat.type_expr) |type_expr| blk: {
            break :blk switch (type_expr) {
                .named => |n| n.name,
                .generic_apply => |g| switch (g.base) {
                    .named => |n| n.name,
                    else => return EmitError.InvalidAST,
                },
                else => return EmitError.InvalidAST,
            };
        } else unreachable; // Already handled above

        // Look up in monomorphized enums first
        if (self.type_checker) |tc| {
            const monos = tc.getMonomorphizedEnums();
            for (monos) |mono| {
                // Check if this is the enum we're looking for
                if (std.mem.eql(u8, mono.original_name, enum_name)) {
                    for (mono.concrete_type.variants, 0..) |v, i| {
                        if (std.mem.eql(u8, v.name, pat.variant_name)) {
                            return @intCast(i);
                        }
                    }
                }
            }
        }

        // Check registered enum types (non-generic)
        if (self.type_checker) |tc| {
            const enum_types = tc.getEnumTypes();
            for (enum_types) |et| {
                if (std.mem.eql(u8, et.name, enum_name)) {
                    for (et.variants, 0..) |v, i| {
                        if (std.mem.eql(u8, v.name, pat.variant_name)) {
                            return @intCast(i);
                        }
                    }
                }
            }
        }

        // If still not found, return error instead of silent 0
        return EmitError.InvalidAST;
    }

    /// Bind pattern variables to extracted values.
    /// `expected_type` provides semantic type information for setting collection flags.
    fn bindPatternVariables(self: *Emitter, pattern: ast.Pattern, subject: llvm.ValueRef, expected_type: ?types.Type) EmitError!void {
        switch (pattern) {
            .wildcard => {},
            .literal => {},
            .binding => |b| {
                // Bind the subject value to the variable name
                const name_z = self.allocator.dupeZ(u8, b.name) catch return EmitError.OutOfMemory;
                defer self.allocator.free(name_z);

                // Create alloca for the bound variable
                const var_type = llvm.typeOf(subject);
                const alloca = self.builder.buildAlloca(var_type, name_z);
                _ = self.builder.buildStore(subject, alloca);

                // Build LocalValue with collection type flags based on expected_type
                var local_value: LocalValue = .{
                    .value = alloca,
                    .is_alloca = true,
                    .ty = var_type,
                    .is_signed = false,
                };

                // Set collection-specific flags based on semantic type
                if (expected_type) |et| {
                    switch (et) {
                        .map => |m| {
                            local_value.is_map = true;
                            local_value.map_key_type = m.key;
                            local_value.map_value_type = m.value;
                        },
                        .list => |l| {
                            local_value.list_element_type = l.element;
                        },
                        .set => |s| {
                            local_value.is_set = true;
                            local_value.set_element_type = s.element;
                        },
                        .string_data => {
                            local_value.is_string_data = true;
                        },
                        .struct_ => |s| {
                            // Set struct type name for field access
                            local_value.struct_type_name = s.name;
                        },
                        else => {},
                    }
                }

                self.named_values.put(b.name, local_value) catch return EmitError.OutOfMemory;
            },
            .variant => |v| {
                // If variant has a payload pattern, extract and bind it
                if (v.payload) |payload_pattern| {
                    // Get the semantic payload type from the type definition
                    const payload_type = self.getVariantPayloadType(v, expected_type);

                    // Handle Result/Optional specially - they have direct payload fields
                    if (expected_type) |et| {
                        if (et == .result) {
                            // Result struct: { tag: i1, ok_value: T, err_value: E }
                            // Ok payload is at index 1, Err payload is at index 2
                            const field_idx: i32 = if (std.mem.eql(u8, v.variant_name, "Ok")) 1 else 2;
                            const val_type = llvm.typeOf(subject);
                            const type_kind = llvm.getTypeKind(val_type);

                            var payload_val: llvm.ValueRef = undefined;
                            if (type_kind == llvm.c.LLVMStructTypeKind) {
                                // Value type: extract directly
                                payload_val = self.builder.buildExtractValue(subject, @intCast(field_idx), "result.payload");
                            } else {
                                // Pointer type: GEP and load
                                var indices = [_]llvm.ValueRef{
                                    llvm.Const.int32(self.ctx, 0),
                                    llvm.Const.int32(self.ctx, field_idx),
                                };
                                const llvm_payload_type = if (payload_type) |pt| self.typeToLLVM(pt) else llvm.Types.int32(self.ctx);
                                const payload_ptr = self.builder.buildGEP(val_type, subject, &indices, "result.payload.ptr");
                                payload_val = self.builder.buildLoad(llvm_payload_type, payload_ptr, "result.payload");
                            }
                            try self.bindPatternVariables(payload_pattern, payload_val, payload_type);
                            return;
                        }

                        if (et == .optional) {
                            // Optional struct: { tag: i1, value: T }
                            // Some payload is at index 1
                            const val_type = llvm.typeOf(subject);
                            const type_kind = llvm.getTypeKind(val_type);

                            var payload_val: llvm.ValueRef = undefined;
                            if (type_kind == llvm.c.LLVMStructTypeKind) {
                                // Value type: extract directly
                                payload_val = self.builder.buildExtractValue(subject, 1, "optional.payload");
                            } else {
                                // Pointer type: GEP and load
                                var indices = [_]llvm.ValueRef{
                                    llvm.Const.int32(self.ctx, 0),
                                    llvm.Const.int32(self.ctx, 1),
                                };
                                const llvm_payload_type = if (payload_type) |pt| self.typeToLLVM(pt) else llvm.Types.int32(self.ctx);
                                const payload_ptr = self.builder.buildGEP(val_type, subject, &indices, "optional.payload.ptr");
                                payload_val = self.builder.buildLoad(llvm_payload_type, payload_ptr, "optional.payload");
                            }
                            try self.bindPatternVariables(payload_pattern, payload_val, payload_type);
                            return;
                        }
                    }

                    // Regular enum: extractEnumPayload returns i8* (pointer to raw payload bytes)
                    const payload_bytes_ptr = try self.extractEnumPayload(subject);

                    // Convert semantic type to LLVM type and load the actual value
                    var payload_val: llvm.ValueRef = undefined;
                    if (payload_type) |pt| {
                        const llvm_payload_type = self.typeToLLVM(pt);
                        // Load the payload value from the raw bytes (pointer is already correctly typed for GEP)
                        payload_val = self.builder.buildLoad(llvm_payload_type, payload_bytes_ptr, "enum.payload.val");
                    } else {
                        // Fallback: no type info, use the pointer directly (may cause issues)
                        payload_val = payload_bytes_ptr;
                    }

                    try self.bindPatternVariables(payload_pattern, payload_val, payload_type);
                }
            },
            .tuple_pattern => |t| {
                for (t.elements, 0..) |elem, i| {
                    var indices = [_]llvm.ValueRef{
                        llvm.Const.int32(self.ctx, 0),
                        llvm.Const.int32(self.ctx, @intCast(i)),
                    };
                    const subject_type = llvm.typeOf(subject);
                    const elem_val = self.builder.buildGEP(subject_type, subject, &indices, "tuple.elem");

                    // Get element type from tuple
                    const elem_type = if (expected_type) |et| blk: {
                        if (et == .tuple) {
                            const tuple_types = et.tuple.elements;
                            if (i < tuple_types.len) {
                                break :blk tuple_types[i];
                            }
                        }
                        break :blk null;
                    } else null;
                    try self.bindPatternVariables(elem, elem_val, elem_type);
                }
            },
            .or_pattern => |o| {
                // For or-patterns, bind from first alternative (they should have same bindings)
                if (o.alternatives.len > 0) {
                    try self.bindPatternVariables(o.alternatives[0], subject, expected_type);
                }
            },
            .guarded => |g| {
                try self.bindPatternVariables(g.pattern, subject, expected_type);
            },
            .struct_pattern => {},
        }
    }

    /// Get the payload type for a variant pattern from the enum definition.
    fn getVariantPayloadType(self: *Emitter, v: *ast.VariantPattern, expected_type: ?types.Type) ?types.Type {
        // Get enum type - either from pattern's type_expr or from expected_type
        const match_type: ?types.Type = if (v.type_expr) |type_expr| blk: {
            // Try to resolve the type expression
            if (self.type_checker) |tc| {
                const tc_mut = @constCast(tc);
                const resolved = tc_mut.resolveTypeExpr(type_expr) catch break :blk expected_type;
                break :blk resolved;
            }
            break :blk expected_type;
        } else expected_type;

        if (match_type == null) {
            return null;
        }
        const mt = match_type.?;

        // Handle Result type payloads
        if (mt == .result) {
            const result_type = mt.result;
            if (std.mem.eql(u8, v.variant_name, "Ok")) {
                return result_type.ok_type;
            } else if (std.mem.eql(u8, v.variant_name, "Err")) {
                return result_type.err_type;
            }
            return null;
        }

        // Handle Optional type payloads
        if (mt == .optional) {
            if (std.mem.eql(u8, v.variant_name, "Some")) {
                return mt.optional.*;
            }
            // None has no payload
            return null;
        }

        // Handle regular enum types
        if (mt != .enum_) {
            return null;
        }

        const enum_def = mt.enum_;

        // Find the variant by name
        for (enum_def.variants) |variant| {
            if (std.mem.eql(u8, variant.name, v.variant_name)) {
                if (variant.payload) |payload| {
                    switch (payload) {
                        .tuple => |tuple_types| {
                            // Single-element tuple: return the element type directly
                            if (tuple_types.len == 1) {
                                return tuple_types[0];
                            }
                            // Multi-element tuple: would need to construct tuple type
                            // For now, return null and let it fall through
                            return null;
                        },
                        .struct_ => {
                            // Struct payload - not handled for now
                            return null;
                        },
                    }
                } else {
                }
                break;
            }
        }
        return null;
    }

    /// Extract the payload from an enum value (returns pointer to payload bytes).
    fn extractEnumPayload(self: *Emitter, enum_val: llvm.ValueRef) EmitError!llvm.ValueRef {
        const val_type = llvm.typeOf(enum_val);
        const type_kind = llvm.getTypeKind(val_type);

        if (type_kind == llvm.c.LLVMStructTypeKind) {
            // Value type: extract payload (field 1) - this gives us the byte array
            // For value types, we need to allocate first to get a pointer
            const alloca = self.builder.buildAlloca(val_type, "enum.tmp");
            _ = self.builder.buildStore(enum_val, alloca);

            // GEP to payload field (index 1, then index 0 for start of array)
            var payload_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 1),
                llvm.Const.int32(self.ctx, 0),
            };
            return self.builder.buildGEP(val_type, alloca, &payload_indices, "enum.payload");
        } else {
            // Pointer type: GEP directly
            var payload_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 1),
                llvm.Const.int32(self.ctx, 0),
            };
            return self.builder.buildGEP(val_type, enum_val, &payload_indices, "enum.payload");
        }
    }

    /// Convert a type expression to LLVM type.
    fn typeExprToLLVM(self: *Emitter, type_expr: ast.TypeExpr) EmitError!llvm.TypeRef {
        return switch (type_expr) {
            .named => |named| self.namedTypeToLLVM(named.name),
            .array => |arr| {
                // Get element type
                const elem_type = try self.typeExprToLLVM(arr.element);
                // Get size from the size expression (must be compile-time constant)
                const size: u64 = switch (arr.size) {
                    .literal => |lit| switch (lit.kind) {
                        .int => |v| @intCast(v),
                        else => return EmitError.InvalidAST,
                    },
                    .identifier => |ident| blk: {
                        // Look up constant from type checker
                        if (self.type_checker) |tc| {
                            if (tc.getConstantValue(ident.name)) |cv| {
                                if (cv == .int) {
                                    break :blk @intCast(cv.int.value);
                                }
                            }
                        }
                        return EmitError.UnsupportedFeature;
                    },
                    else => return EmitError.UnsupportedFeature, // Non-constant array size
                };
                return llvm.Types.array(elem_type, size);
            },
            .tuple => |tup| {
                // Create struct type for tuple
                var elem_types = std.ArrayListUnmanaged(llvm.TypeRef){};
                defer elem_types.deinit(self.allocator);

                for (tup.elements) |elem| {
                    const elem_llvm_type = try self.typeExprToLLVM(elem);
                    elem_types.append(self.allocator, elem_llvm_type) catch return EmitError.OutOfMemory;
                }

                return llvm.Types.struct_(self.ctx, elem_types.items, false);
            },
            .slice => |sl| {
                // Slice is a struct of {pointer, length}
                const elem_type = try self.typeExprToLLVM(sl.element);
                _ = elem_type; // Element type is for the pointed-to data
                var slice_fields = [_]llvm.TypeRef{
                    llvm.Types.pointer(self.ctx), // data pointer
                    llvm.Types.int64(self.ctx), // length (usize)
                };
                return llvm.Types.struct_(self.ctx, &slice_fields, false);
            },
            .reference => |ref| {
                // Reference is a pointer
                _ = ref;
                return llvm.Types.pointer(self.ctx);
            },
            .optional => |opt| {
                // Optional is a struct of {tag, value}
                const inner_type = try self.typeExprToLLVM(opt.inner);
                var opt_fields = [_]llvm.TypeRef{
                    llvm.Types.int1(self.ctx), // tag (0 = none, 1 = some)
                    inner_type, // value
                };
                return llvm.Types.struct_(self.ctx, &opt_fields, false);
            },
            .function => {
                // Function type is represented as closure struct: { fn_ptr: ptr, env_ptr: ptr }
                // This is the same layout used in emitClosure
                return self.getClosureStructType();
            },
            .result => |res| {
                // Result[T, E] is a struct of { tag: i1, ok_value: T, err_value: E }
                // tag: 1 = Ok, 0 = Err
                const ok_type = try self.typeExprToLLVM(res.ok_type);
                const err_type = try self.typeExprToLLVM(res.err_type);
                var result_fields = [_]llvm.TypeRef{
                    llvm.Types.int1(self.ctx), // tag (0 = err, 1 = ok)
                    ok_type, // ok_value
                    err_type, // err_value
                };
                return llvm.Types.struct_(self.ctx, &result_fields, false);
            },
            .generic_apply => |g| {
                // Handle builtin generic types like Result[T, E], ContextError[E], etc.
                if (g.base == .named) {
                    const base_name = g.base.named.name;
                    if (std.mem.eql(u8, base_name, "Result") and g.args.len == 2) {
                        // Result[T, E] is a struct of { tag: i1, ok_value: T, err_value: E }
                        const ok_type = try self.typeExprToLLVM(g.args[0]);
                        const err_type = try self.typeExprToLLVM(g.args[1]);
                        var result_fields = [_]llvm.TypeRef{
                            llvm.Types.int1(self.ctx), // tag (0 = err, 1 = ok)
                            ok_type, // ok_value
                            err_type, // err_value
                        };
                        return llvm.Types.struct_(self.ctx, &result_fields, false);
                    }
                    if (std.mem.eql(u8, base_name, "ContextError") and g.args.len == 1) {
                        // ContextError[E] layout: { message: ptr, cause: E, file: ptr, line: i32, column: i32 }
                        const inner_type = try self.typeExprToLLVM(g.args[0]);
                        var context_err_fields = [_]llvm.TypeRef{
                            llvm.Types.pointer(self.ctx), // message
                            inner_type, // cause
                            llvm.Types.pointer(self.ctx), // file
                            llvm.Types.int32(self.ctx), // line
                            llvm.Types.int32(self.ctx), // column
                        };
                        return llvm.Types.struct_(self.ctx, &context_err_fields, false);
                    }

                    // Try to look up user-defined generic struct types
                    // Build mangled name: BaseName$Type1$Type2...
                    var mangled = std.ArrayListUnmanaged(u8){};
                    defer mangled.deinit(self.allocator);
                    mangled.appendSlice(self.allocator, base_name) catch return EmitError.OutOfMemory;
                    for (g.args) |arg| {
                        mangled.append(self.allocator, '$') catch return EmitError.OutOfMemory;
                        self.appendTypeNameForMangling(&mangled, arg) catch return EmitError.OutOfMemory;
                    }

                    // Look up the mangled struct type in cache
                    if (self.struct_types.get(mangled.items)) |struct_info| {
                        return struct_info.llvm_type;
                    }
                }
                // Other complex types - return pointer as placeholder
                return llvm.Types.pointer(self.ctx);
            },
            .qualified => {
                // Qualified types like Self.Item are resolved by the type checker
                // At codegen time, they should have been substituted with concrete types
                // If we get here, it's an unresolved associated type - use pointer as placeholder
                return llvm.Types.pointer(self.ctx);
            },
        };
    }

    /// Get the LLVM struct type for closures: { fn_ptr: ptr, env_ptr: ptr }
    /// This is a consistent layout used throughout closure handling.
    fn getClosureStructType(self: *Emitter) llvm.TypeRef {
        var types_arr = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx), // fn_ptr
            llvm.Types.pointer(self.ctx), // env_ptr
        };
        return llvm.Types.struct_(self.ctx, &types_arr, false);
    }

    fn namedTypeToLLVM(self: *Emitter, name: []const u8) llvm.TypeRef {
        // Map Klar type names to LLVM types
        if (std.mem.eql(u8, name, "i8")) return llvm.Types.int8(self.ctx);
        if (std.mem.eql(u8, name, "i16")) return llvm.Types.int16(self.ctx);
        if (std.mem.eql(u8, name, "i32")) return llvm.Types.int32(self.ctx);
        if (std.mem.eql(u8, name, "i64")) return llvm.Types.int64(self.ctx);
        if (std.mem.eql(u8, name, "i128")) return llvm.Types.int128(self.ctx);
        if (std.mem.eql(u8, name, "u8")) return llvm.Types.int8(self.ctx);
        if (std.mem.eql(u8, name, "u16")) return llvm.Types.int16(self.ctx);
        if (std.mem.eql(u8, name, "u32")) return llvm.Types.int32(self.ctx);
        if (std.mem.eql(u8, name, "u64")) return llvm.Types.int64(self.ctx);
        if (std.mem.eql(u8, name, "u128")) return llvm.Types.int128(self.ctx);
        if (std.mem.eql(u8, name, "f32")) return llvm.Types.float32(self.ctx);
        if (std.mem.eql(u8, name, "f64")) return llvm.Types.float64(self.ctx);
        if (std.mem.eql(u8, name, "bool")) return llvm.Types.int1(self.ctx);
        if (std.mem.eql(u8, name, "string")) return llvm.Types.pointer(self.ctx);
        if (std.mem.eql(u8, name, "char")) return llvm.Types.int32(self.ctx); // Unicode codepoint
        if (std.mem.eql(u8, name, "isize")) return llvm.Types.int64(self.ctx);
        if (std.mem.eql(u8, name, "usize")) return llvm.Types.int64(self.ctx);

        // Check if it's a registered struct type
        if (self.struct_types.get(name)) |struct_info| {
            return struct_info.llvm_type;
        }

        // Builtin types that aren't in struct_types
        if (std.mem.eql(u8, name, "IoError")) {
            return self.getIoErrorStructType();
        }
        if (std.mem.eql(u8, name, "File")) {
            return llvm.Types.pointer(self.ctx); // FILE*
        }
        if (std.mem.eql(u8, name, "Stdin")) {
            return llvm.Types.pointer(self.ctx); // FILE*
        }
        if (std.mem.eql(u8, name, "Stdout")) {
            return llvm.Types.pointer(self.ctx); // FILE*
        }
        if (std.mem.eql(u8, name, "Stderr")) {
            return llvm.Types.pointer(self.ctx); // FILE*
        }

        // FFI types
        if (std.mem.eql(u8, name, "CStr")) {
            return llvm.Types.pointer(self.ctx); // Null-terminated C string (borrowed)
        }
        if (std.mem.eql(u8, name, "CStrOwned")) {
            return llvm.Types.pointer(self.ctx); // Null-terminated C string (owned)
        }

        // Check if it's an extern type registered in the type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            if (tc_mut.lookupType(name)) |ty| {
                if (ty == .extern_type) {
                    return self.typeToLLVM(ty);
                }
            }
        }

        // Default to i32
        return llvm.Types.int32(self.ctx);
    }

    /// Check if a type expression represents a signed type.
    fn isTypeSigned(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .named => |named| {
                // Unsigned types start with 'u'
                if (named.name.len > 0 and named.name[0] == 'u') {
                    // But could be "usize" which is architecture-dependent
                    // For now, treat it as unsigned
                    if (std.mem.eql(u8, named.name, "u8")) return false;
                    if (std.mem.eql(u8, named.name, "u16")) return false;
                    if (std.mem.eql(u8, named.name, "u32")) return false;
                    if (std.mem.eql(u8, named.name, "u64")) return false;
                    if (std.mem.eql(u8, named.name, "u128")) return false;
                    if (std.mem.eql(u8, named.name, "usize")) return false;
                }
                // Signed types: i8, i16, i32, i64, i128, isize, or floats
                return true;
            },
            else => true, // Default to signed
        };
    }

    /// Resolve a type expression directly from AST (for Result, Optional types).
    /// This doesn't depend on type checker scope, so it works during codegen.
    fn resolveTypeExprDirect(self: *Emitter, type_expr: ast.TypeExpr) ?types.Type {
        switch (type_expr) {
            .optional => |opt| {
                // ?T syntax
                const inner = self.resolveTypeExprDirect(opt.inner) orelse return null;
                const inner_ptr = self.allocator.create(types.Type) catch return null;
                inner_ptr.* = inner;
                return .{ .optional = inner_ptr };
            },
            .generic_apply => |g| {
                // Check for Result[T, E]
                if (g.base == .named) {
                    const name = g.base.named.name;
                    if (std.mem.eql(u8, name, "Result") and g.args.len == 2) {
                        const ok_type = self.resolveTypeExprDirect(g.args[0]) orelse return null;
                        const err_type = self.resolveTypeExprDirect(g.args[1]) orelse return null;
                        const result_ptr = self.allocator.create(types.ResultType) catch return null;
                        result_ptr.* = .{ .ok_type = ok_type, .err_type = err_type };
                        return .{ .result = result_ptr };
                    }
                    // Check for CPtr[T]
                    if (std.mem.eql(u8, name, "CPtr") and g.args.len == 1) {
                        const inner = self.resolveTypeExprDirect(g.args[0]) orelse return null;
                        const cptr_type = self.allocator.create(types.CptrType) catch return null;
                        cptr_type.* = .{ .inner = inner };
                        return .{ .cptr = cptr_type };
                    }
                    // Check for COptPtr[T]
                    if (std.mem.eql(u8, name, "COptPtr") and g.args.len == 1) {
                        const inner = self.resolveTypeExprDirect(g.args[0]) orelse return null;
                        const copt_ptr_type = self.allocator.create(types.CoptPtrType) catch return null;
                        copt_ptr_type.* = .{ .inner = inner };
                        return .{ .copt_ptr = copt_ptr_type };
                    }
                }
                // For other generic types, try type checker (may fail due to scope)
                if (self.type_checker) |tc| {
                    const tc_mut = @constCast(tc);
                    return tc_mut.resolveTypeExpr(type_expr) catch return null;
                }
                return null;
            },
            .named => |n| {
                // Primitive types
                if (types.Primitive.fromName(n.name)) |prim| {
                    return .{ .primitive = prim };
                }
                // string is a primitive type
                if (std.mem.eql(u8, n.name, "string")) {
                    return .{ .primitive = .string_ };
                }
                // FFI types
                if (std.mem.eql(u8, n.name, "CStr")) {
                    return .cstr;
                }
                if (std.mem.eql(u8, n.name, "CStrOwned")) {
                    return .cstr_owned;
                }
                // For other named types, try type checker
                if (self.type_checker) |tc| {
                    const tc_mut = @constCast(tc);
                    return tc_mut.resolveTypeExpr(type_expr) catch return null;
                }
                return null;
            },
            else => {
                // For other types, try type checker
                if (self.type_checker) |tc| {
                    const tc_mut = @constCast(tc);
                    return tc_mut.resolveTypeExpr(type_expr) catch return null;
                }
                return null;
            },
        }
    }

    /// Check if a type expression is a primitive string type.
    fn isTypeString(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .named => |named| std.mem.eql(u8, named.name, "string"),
            else => false,
        };
    }

    /// Check if a type expression is a heap-allocated String type.
    fn isTypeStringData(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .named => |named| std.mem.eql(u8, named.name, "String"),
            else => false,
        };
    }

    /// Check if a type expression is a File type.
    fn isTypeFile(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .named => |named| std.mem.eql(u8, named.name, "File"),
            else => false,
        };
    }

    /// Check if a type expression is a Stdout type.
    fn isTypeStdout(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .named => |named| std.mem.eql(u8, named.name, "Stdout"),
            else => false,
        };
    }

    /// Check if a type expression is a Stderr type.
    fn isTypeStderr(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .named => |named| std.mem.eql(u8, named.name, "Stderr"),
            else => false,
        };
    }

    /// Check if a type expression is a Stdin type.
    fn isTypeStdin(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .named => |named| std.mem.eql(u8, named.name, "Stdin"),
            else => false,
        };
    }

    /// Check if a type expression is a BufReader type.
    fn isTypeBufReader(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .generic_apply => |g| if (g.base == .named) std.mem.eql(u8, g.base.named.name, "BufReader") else false,
            else => false,
        };
    }

    /// Check if a type expression is a BufWriter type.
    fn isTypeBufWriter(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .generic_apply => |g| if (g.base == .named) std.mem.eql(u8, g.base.named.name, "BufWriter") else false,
            else => false,
        };
    }

    /// Check if a type expression is a CStrOwned type.
    fn isTypeCstrOwned(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .named => |n| std.mem.eql(u8, n.name, "CStrOwned"),
            else => false,
        };
    }

    /// Check if a type expression is an array or slice type.
    fn isTypeArray(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return type_expr == .array or type_expr == .slice;
    }

    /// Get array info from a type expression.
    /// Returns (element_type, size) where size is null for slices.
    fn getArrayTypeInfo(self: *Emitter, type_expr: ast.TypeExpr) ?struct { element_type: ?types.Type, size: ?usize } {
        switch (type_expr) {
            .array => |arr| {
                // For fixed-size arrays, get the size from the expression
                const size: ?usize = if (arr.size == .literal) blk: {
                    if (arr.size.literal.kind == .int) {
                        // Get the integer value directly
                        const int_val = arr.size.literal.kind.int;
                        if (int_val >= 0 and int_val <= std.math.maxInt(usize)) {
                            break :blk @intCast(int_val);
                        }
                    }
                    break :blk null;
                } else null;
                // Convert the element type expression to a types.Type using type checker
                const element_type: ?types.Type = if (self.type_checker) |tc| blk: {
                    const tc_mut = @constCast(tc);
                    break :blk tc_mut.resolveTypeExpr(arr.element) catch null;
                } else null;
                return .{ .element_type = element_type, .size = size };
            },
            .slice => |slc| {
                // Slices don't have a size
                const element_type: ?types.Type = if (self.type_checker) |tc| blk: {
                    const tc_mut = @constCast(tc);
                    break :blk tc_mut.resolveTypeExpr(slc.element) catch null;
                } else null;
                return .{ .element_type = element_type, .size = null };
            },
            else => return null,
        }
    }

    /// Get List element type from type expression (e.g., List[i32] -> i32)
    fn getListTypeInfo(self: *Emitter, type_expr: ast.TypeExpr) ?types.Type {
        switch (type_expr) {
            .generic_apply => |g| {
                // Check if the base is "List"
                if (g.base == .named and std.mem.eql(u8, g.base.named.name, "List")) {
                    if (g.args.len == 1) {
                        // Resolve the element type using type checker
                        if (self.type_checker) |tc| {
                            const tc_mut = @constCast(tc);
                            return tc_mut.resolveTypeExpr(g.args[0]) catch null;
                        }
                    }
                }
                return null;
            },
            else => return null,
        }
    }

    /// Check if a type expression is a Map type and extract key/value types.
    const MapTypeInfo = struct {
        key_type: types.Type,
        value_type: types.Type,
    };

    fn getMapTypeInfo(self: *Emitter, type_expr: ast.TypeExpr) ?MapTypeInfo {
        switch (type_expr) {
            .generic_apply => |g| {
                // Check if the base is "Map"
                if (g.base == .named and std.mem.eql(u8, g.base.named.name, "Map")) {
                    if (g.args.len == 2) {
                        // Resolve the key and value types using type checker
                        if (self.type_checker) |tc| {
                            const tc_mut = @constCast(tc);
                            const key_type = tc_mut.resolveTypeExpr(g.args[0]) catch return null;
                            const value_type = tc_mut.resolveTypeExpr(g.args[1]) catch return null;
                            return .{ .key_type = key_type, .value_type = value_type };
                        }
                    }
                }
                return null;
            },
            else => return null,
        }
    }

    /// Check if a type expression is a Set type and extract element type.
    fn getSetTypeInfo(self: *Emitter, type_expr: ast.TypeExpr) ?types.Type {
        switch (type_expr) {
            .generic_apply => |g| {
                // Check if the base is "Set"
                if (g.base == .named and std.mem.eql(u8, g.base.named.name, "Set")) {
                    if (g.args.len == 1) {
                        // Resolve the element type using type checker
                        if (self.type_checker) |tc| {
                            const tc_mut = @constCast(tc);
                            return tc_mut.resolveTypeExpr(g.args[0]) catch null;
                        }
                    }
                }
                return null;
            },
            else => return null,
        }
    }

    /// Resolve a type expression to a types.Type for use as expected_type context.
    /// Used to propagate type annotations to constructors like Ok/Err.
    fn resolveExpectedType(self: *Emitter, type_expr: ast.TypeExpr) ?types.Type {
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            return tc_mut.resolveTypeExpr(type_expr) catch null;
        }
        return null;
    }

    /// Infer LLVM type from expression (simplified).
    fn inferExprType(self: *Emitter, expr: ast.Expr) EmitError!llvm.TypeRef {
        return switch (expr) {
            .literal => |lit| switch (lit.kind) {
                .int => blk: {
                    // Check if we have an expected type that requires a specific width
                    if (self.expected_type) |expected| {
                        if (expected == .primitive) {
                            const prim = expected.primitive;
                            break :blk switch (prim) {
                                .i8_ => llvm.Types.int8(self.ctx),
                                .i16_ => llvm.Types.int16(self.ctx),
                                .i32_ => llvm.Types.int32(self.ctx),
                                .i64_ => llvm.Types.int64(self.ctx),
                                .i128_ => llvm.Types.int128(self.ctx),
                                .isize_ => llvm.Types.int64(self.ctx),
                                .u8_ => llvm.Types.int8(self.ctx),
                                .u16_ => llvm.Types.int16(self.ctx),
                                .u32_ => llvm.Types.int32(self.ctx),
                                .u64_ => llvm.Types.int64(self.ctx),
                                .u128_ => llvm.Types.int128(self.ctx),
                                .usize_ => llvm.Types.int64(self.ctx),
                                else => llvm.Types.int32(self.ctx),
                            };
                        }
                    }
                    break :blk llvm.Types.int32(self.ctx);
                },
                .float => llvm.Types.float64(self.ctx),
                .bool_ => llvm.Types.int1(self.ctx),
                .char => llvm.Types.int32(self.ctx),
                .string => llvm.Types.pointer(self.ctx),
            },
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    return local.ty;
                }
                // Check if this is a module-level constant
                if (self.type_checker) |tc| {
                    if (tc.getConstantValue(id.name)) |cv| {
                        return switch (cv) {
                            .int => |i| if (i.is_i32) llvm.Types.int32(self.ctx) else llvm.Types.int64(self.ctx),
                            .float => llvm.Types.float64(self.ctx),
                            .bool_ => llvm.Types.int1(self.ctx),
                            .string => llvm.Types.pointer(self.ctx),
                            .void_ => llvm.Types.int32(self.ctx),
                            .struct_ => |cs| blk: {
                                if (self.struct_types.get(cs.type_name)) |struct_info| {
                                    break :blk struct_info.llvm_type;
                                }
                                break :blk llvm.Types.int32(self.ctx);
                            },
                            .array => |arr| blk: {
                                const elem_ty = self.typeToLLVM(arr.element_type);
                                break :blk llvm.Types.array(elem_ty, @intCast(arr.elements.len));
                            },
                        };
                    }
                }
                return llvm.Types.int32(self.ctx);
            },
            .binary => |bin| {
                // Comparison operators return bool
                switch (bin.op) {
                    .eq, .not_eq, .lt, .gt, .lt_eq, .gt_eq, .and_, .or_ => {
                        return llvm.Types.int1(self.ctx);
                    },
                    .null_coalesce => {
                        // Null coalescing returns the inner type of the Optional
                        // which is the same as the right side type
                        return try self.inferExprType(bin.right);
                    },
                    else => {
                        // For arithmetic, check both sides - if either is float, result is float
                        const left_ty = try self.inferExprType(bin.left);
                        const right_ty = try self.inferExprType(bin.right);
                        const left_kind = llvm.getTypeKind(left_ty);
                        const right_kind = llvm.getTypeKind(right_ty);
                        const left_is_float = left_kind == llvm.c.LLVMFloatTypeKind or left_kind == llvm.c.LLVMDoubleTypeKind;
                        const right_is_float = right_kind == llvm.c.LLVMFloatTypeKind or right_kind == llvm.c.LLVMDoubleTypeKind;
                        if (left_is_float) return left_ty;
                        if (right_is_float) return right_ty;
                        return left_ty;
                    },
                }
            },
            // Composite types - build the type from elements
            .tuple_literal => |tup| {
                if (tup.elements.len == 0) {
                    return llvm.Types.int32(self.ctx); // Empty tuple as unit
                }
                var elem_types = std.ArrayListUnmanaged(llvm.TypeRef){};
                defer elem_types.deinit(self.allocator);
                for (tup.elements) |elem| {
                    const elem_ty = try self.inferExprType(elem);
                    elem_types.append(self.allocator, elem_ty) catch return EmitError.OutOfMemory;
                }
                return llvm.Types.struct_(self.ctx, elem_types.items, false);
            },
            .array_literal => |arr| {
                if (arr.elements.len == 0) {
                    return llvm.Types.array(llvm.Types.int32(self.ctx), 0);
                }
                const elem_ty = try self.inferExprType(arr.elements[0]);
                return llvm.Types.array(elem_ty, @intCast(arr.elements.len));
            },
            .struct_literal => |s| {
                // First check if there's a type name - if so, use the registered struct type
                if (s.type_name) |type_name| {
                    const name = switch (type_name) {
                        .named => |n| n.name,
                        else => null,
                    };
                    if (name) |n| {
                        if (self.struct_types.get(n)) |struct_info| {
                            return struct_info.llvm_type;
                        }
                    }
                }
                // Fallback: Infer struct type from field values (anonymous struct)
                var field_types = std.ArrayListUnmanaged(llvm.TypeRef){};
                defer field_types.deinit(self.allocator);
                for (s.fields) |field_init| {
                    const field_ty = try self.inferExprType(field_init.value);
                    field_types.append(self.allocator, field_ty) catch return EmitError.OutOfMemory;
                }
                return llvm.Types.struct_(self.ctx, field_types.items, false);
            },
            .field => |f| {
                // Get the struct type name from the object expression (handles call expressions too)
                const struct_name = self.getStructTypeNameFromExpr(f.object);
                if (struct_name) |name| {
                    // Use lookupFieldType for correct struct type resolution
                    if (self.lookupFieldType(name, f.field_name)) |field_ty| {
                        return field_ty;
                    }
                    // Fallback to LLVMStructGetTypeAtIndex for non-struct fields
                    if (self.struct_types.get(name)) |struct_info| {
                        if (self.lookupFieldIndex(name, f.field_name)) |idx| {
                            return llvm.c.LLVMStructGetTypeAtIndex(struct_info.llvm_type, idx);
                        }
                    }
                }
                // Fallback: Field access on a composite - get the base type and extract field type
                const base_ty = try self.inferExprType(f.object);
                const type_kind = llvm.getTypeKind(base_ty);
                if (type_kind == llvm.c.LLVMStructTypeKind) {
                    // Try to parse as numeric index for tuple
                    if (std.fmt.parseInt(u32, f.field_name, 10)) |idx| {
                        return llvm.c.LLVMStructGetTypeAtIndex(base_ty, idx);
                    } else |_| {
                        // Named field - fallback to i32 as placeholder
                        return llvm.Types.int32(self.ctx);
                    }
                }
                return llvm.Types.int32(self.ctx);
            },
            .index => |i| {
                // Index access on array - return element type
                const base_ty = try self.inferExprType(i.object);
                const type_kind = llvm.getTypeKind(base_ty);
                if (type_kind == llvm.c.LLVMArrayTypeKind) {
                    return llvm.c.LLVMGetElementType(base_ty);
                }
                return llvm.Types.int32(self.ctx);
            },
            .grouped => |g| try self.inferExprType(g.expr),
            .call => |call| {
                // Get function return type
                const func_name = switch (call.callee) {
                    .identifier => |id| id.name,
                    else => return llvm.Types.int32(self.ctx),
                };

                // Handle builtin Result constructors: Ok(value) and Err(error)
                // Use expected_type if available (from type annotation context)
                if (std.mem.eql(u8, func_name, "Ok")) {
                    // Ok(value) returns Result[T, E] - use expected type if available
                    if (call.args.len == 1) {
                        const ok_type = try self.inferExprType(call.args[0]);
                        // Use expected_type's err_type if available
                        const err_type = if (self.expected_type) |et| blk: {
                            if (et == .result) {
                                break :blk self.typeToLLVM(et.result.err_type);
                            }
                            break :blk llvm.Types.int32(self.ctx);
                        } else llvm.Types.int32(self.ctx);
                        return self.getResultType(ok_type, err_type);
                    }
                    return llvm.Types.int32(self.ctx);
                }

                if (std.mem.eql(u8, func_name, "Err")) {
                    // Err(error) returns Result[T, E] - use expected type if available
                    if (call.args.len == 1) {
                        const err_type = try self.inferExprType(call.args[0]);
                        // Use expected_type's ok_type if available
                        const ok_type = if (self.expected_type) |et| blk: {
                            if (et == .result) {
                                break :blk self.typeToLLVM(et.result.ok_type);
                            }
                            break :blk llvm.Types.int32(self.ctx);
                        } else llvm.Types.int32(self.ctx);
                        return self.getResultType(ok_type, err_type);
                    }
                    return llvm.Types.int32(self.ctx);
                }

                // Handle builtin Optional constructors: Some(value) and None
                if (std.mem.eql(u8, func_name, "Some")) {
                    // Some(value) returns ?T
                    if (call.args.len == 1) {
                        const inner_type = try self.inferExprType(call.args[0]);
                        return self.getOptionalType(inner_type);
                    }
                    return llvm.Types.int32(self.ctx);
                }

                if (std.mem.eql(u8, func_name, "None")) {
                    // None returns ?T - use expected type if available
                    const inner_type = if (self.expected_type) |et| blk: {
                        if (et == .optional) {
                            break :blk self.typeToLLVM(et.optional.*);
                        }
                        break :blk llvm.Types.int32(self.ctx);
                    } else llvm.Types.int32(self.ctx);
                    return self.getOptionalType(inner_type);
                }

                // Handle stdout(), stderr(), stdin() - they return FILE* pointers
                if (std.mem.eql(u8, func_name, "stdout") or std.mem.eql(u8, func_name, "stderr") or std.mem.eql(u8, func_name, "stdin")) {
                    return llvm.Types.pointer(self.ctx);
                }

                // Handle readline() - returns a string (char* pointer)
                if (std.mem.eql(u8, func_name, "readline")) {
                    return llvm.Types.pointer(self.ctx);
                }

                // Handle debug() - returns a string (char* pointer)
                if (std.mem.eql(u8, func_name, "debug")) {
                    return llvm.Types.pointer(self.ctx);
                }

                // Check if this is a monomorphized generic function call
                if (self.type_checker) |checker| {
                    if (checker.getCallResolution(call)) |mangled_name| {
                        // Check if this function uses sret (return type is in sret_functions)
                        if (self.sret_functions.get(mangled_name)) |sret_type| {
                            return sret_type;
                        }

                        const mangled_z = self.allocator.dupeZ(u8, mangled_name) catch return EmitError.OutOfMemory;
                        defer self.allocator.free(mangled_z);

                        if (self.module.getNamedFunction(mangled_z)) |func| {
                            const fn_type = llvm.getGlobalValueType(func);
                            return llvm.getReturnType(fn_type);
                        }
                    }
                }

                // Check if this is a local closure variable with known return type
                if (self.named_values.get(func_name)) |local| {
                    if (local.closure_return_type) |ret_type| {
                        return ret_type;
                    }
                }

                // Check if this function uses sret (return type is in sret_functions)
                if (self.sret_functions.get(func_name)) |sret_type| {
                    return sret_type;
                }

                // Check if this is an extern function with ABI-lowered struct return
                if (self.extern_functions.get(func_name)) |extern_info| {
                    if (extern_info.abi_lowered_return_type) |struct_type| {
                        return struct_type;
                    }
                }

                const name = self.allocator.dupeZ(u8, func_name) catch return EmitError.OutOfMemory;
                defer self.allocator.free(name);

                if (self.module.getNamedFunction(name)) |func| {
                    const fn_type = llvm.getGlobalValueType(func);
                    return llvm.getReturnType(fn_type);
                }
                return llvm.Types.int32(self.ctx);
            },
            .postfix => |post| {
                // Postfix operators (unwrap) return the inner type
                // For Optional[T] (2-field struct): { i1, T } -> returns T
                // For Result[T, E] (3-field struct): { i1, T, E } -> returns T (ok_value)
                const operand_type = try self.inferExprType(post.operand);
                const type_kind = llvm.getTypeKind(operand_type);
                if (type_kind == llvm.c.LLVMStructTypeKind) {
                    const num_fields = llvm.c.LLVMCountStructElementTypes(operand_type);
                    // Both Optional (2 fields) and Result (3 fields) have value at index 1
                    if (num_fields == 2 or num_fields == 3) {
                        return llvm.c.LLVMStructGetTypeAtIndex(operand_type, 1);
                    }
                }
                return operand_type;
            },
            .method_call => |m| {
                // Check for special Rc, Arc, Cell, and List methods that return pointers
                if (m.object == .identifier) {
                    const obj_name = m.object.identifier.name;
                    if (std.mem.eql(u8, obj_name, "Rc") and std.mem.eql(u8, m.method_name, "new")) {
                        // Rc.new() returns a pointer (Rc[T])
                        return llvm.Types.pointer(self.ctx);
                    }
                    if (std.mem.eql(u8, obj_name, "Arc") and std.mem.eql(u8, m.method_name, "new")) {
                        // Arc.new() returns a pointer (Arc[T])
                        return llvm.Types.pointer(self.ctx);
                    }
                    if (std.mem.eql(u8, obj_name, "Cell") and std.mem.eql(u8, m.method_name, "new")) {
                        // Cell.new() returns a pointer (Cell[T])
                        return llvm.Types.pointer(self.ctx);
                    }
                    if (std.mem.eql(u8, obj_name, "List") and std.mem.eql(u8, m.method_name, "new")) {
                        // List.new[T]() returns List struct { ptr, i32, i32 }
                        return self.getListStructType();
                    }
                    if (std.mem.eql(u8, obj_name, "List") and std.mem.eql(u8, m.method_name, "with_capacity")) {
                        // List.with_capacity[T](n) returns List struct { ptr, i32, i32 }
                        return self.getListStructType();
                    }
                    if (std.mem.eql(u8, obj_name, "Map") and std.mem.eql(u8, m.method_name, "new")) {
                        // Map.new[K,V]() returns Map struct { ptr, i32, i32, i32 }
                        return self.getMapStructType();
                    }
                    if (std.mem.eql(u8, obj_name, "Map") and std.mem.eql(u8, m.method_name, "with_capacity")) {
                        // Map.with_capacity[K,V](n) returns Map struct { ptr, i32, i32, i32 }
                        return self.getMapStructType();
                    }
                    // Set static constructors
                    if (std.mem.eql(u8, obj_name, "Set") and std.mem.eql(u8, m.method_name, "new")) {
                        // Set.new[T]() returns Set struct { ptr, i32, i32, i32 }
                        return self.getSetStructType();
                    }
                    if (std.mem.eql(u8, obj_name, "Set") and std.mem.eql(u8, m.method_name, "with_capacity")) {
                        // Set.with_capacity[T](n) returns Set struct { ptr, i32, i32, i32 }
                        return self.getSetStructType();
                    }
                    // String static constructors
                    if (std.mem.eql(u8, obj_name, "String") and std.mem.eql(u8, m.method_name, "new")) {
                        // String.new() returns String struct { ptr, i32, i32 }
                        return self.getStringStructType();
                    }
                    if (std.mem.eql(u8, obj_name, "String") and std.mem.eql(u8, m.method_name, "from")) {
                        // String.from(s) returns String struct { ptr, i32, i32 }
                        return self.getStringStructType();
                    }
                    if (std.mem.eql(u8, obj_name, "String") and std.mem.eql(u8, m.method_name, "with_capacity")) {
                        // String.with_capacity(n) returns String struct { ptr, i32, i32 }
                        return self.getStringStructType();
                    }
                    // File.open(path, mode) -> Result[File, IoError]
                    if (std.mem.eql(u8, obj_name, "File") and std.mem.eql(u8, m.method_name, "open")) {
                        return self.getFileResultType();
                    }
                    // File.read_to_string(path) -> Result[String, IoError]
                    if (std.mem.eql(u8, obj_name, "File") and std.mem.eql(u8, m.method_name, "read_to_string")) {
                        return self.getStringResultType();
                    }
                    // File.read_all(path) -> Result[List[u8], IoError]
                    if (std.mem.eql(u8, obj_name, "File") and std.mem.eql(u8, m.method_name, "read_all")) {
                        return self.getListResultType();
                    }
                    // BufReader.new[R](reader) -> BufReader[R]
                    if (std.mem.eql(u8, obj_name, "BufReader") and std.mem.eql(u8, m.method_name, "new")) {
                        return self.getBufReaderStructType();
                    }
                    // BufWriter.new[W](writer) -> BufWriter[W]
                    if (std.mem.eql(u8, obj_name, "BufWriter") and std.mem.eql(u8, m.method_name, "new")) {
                        return self.getBufWriterStructType();
                    }
                }

                // File instance methods (file.write_string, file.read, etc.)
                if (self.isFileExpr(m.object)) {
                    if (std.mem.eql(u8, m.method_name, "write_string") or
                        std.mem.eql(u8, m.method_name, "write") or
                        std.mem.eql(u8, m.method_name, "read"))
                    {
                        // Returns Result[i32, IoError]
                        return self.getI32ResultType();
                    }
                    if (std.mem.eql(u8, m.method_name, "close") or
                        std.mem.eql(u8, m.method_name, "flush"))
                    {
                        // Returns Result[void, IoError]
                        return self.getVoidResultType();
                    }
                }

                // Stdout/Stderr instance methods
                if (self.isStdoutExpr(m.object) or self.isStderrExpr(m.object)) {
                    if (std.mem.eql(u8, m.method_name, "write") or
                        std.mem.eql(u8, m.method_name, "write_string"))
                    {
                        // Returns Result[i32, IoError]
                        return self.getI32ResultType();
                    }
                    if (std.mem.eql(u8, m.method_name, "flush")) {
                        // Returns Result[void, IoError]
                        return self.getVoidResultType();
                    }
                }

                // Stdin instance methods
                if (self.isStdinExpr(m.object)) {
                    if (std.mem.eql(u8, m.method_name, "read")) {
                        // Returns Result[i32, IoError]
                        return self.getI32ResultType();
                    }
                }

                // BufReader instance methods
                if (self.isBufReaderExpr(m.object)) {
                    if (std.mem.eql(u8, m.method_name, "read")) {
                        return self.getI32ResultType();
                    }
                    if (std.mem.eql(u8, m.method_name, "read_line") or
                        std.mem.eql(u8, m.method_name, "read_to_string"))
                    {
                        return self.getStringResultType();
                    }
                    if (std.mem.eql(u8, m.method_name, "fill_buf")) {
                        return self.getSliceResultType();
                    }
                    if (std.mem.eql(u8, m.method_name, "consume")) {
                        return llvm.Types.int32(self.ctx); // void, placeholder
                    }
                    if (std.mem.eql(u8, m.method_name, "into_inner")) {
                        return llvm.Types.pointer(self.ctx); // Returns FILE*
                    }
                }

                // BufWriter instance methods
                if (self.isBufWriterExpr(m.object)) {
                    if (std.mem.eql(u8, m.method_name, "write") or
                        std.mem.eql(u8, m.method_name, "write_string"))
                    {
                        return self.getI32ResultType();
                    }
                    if (std.mem.eql(u8, m.method_name, "flush")) {
                        return self.getVoidResultType();
                    }
                    if (std.mem.eql(u8, m.method_name, "into_inner")) {
                        return self.getFileResultType();
                    }
                }

                // Array/slice methods - check FIRST before Cell methods (which also have .get())
                if (self.isArrayExpr(m.object)) {
                    // len() returns i32
                    if (std.mem.eql(u8, m.method_name, "len")) {
                        return llvm.Types.int32(self.ctx);
                    }
                    // is_empty() and contains() return bool
                    if (std.mem.eql(u8, m.method_name, "is_empty") or
                        std.mem.eql(u8, m.method_name, "contains"))
                    {
                        return llvm.Types.int1(self.ctx);
                    }
                    // first(), last(), get() return Optional[T] - struct { i1 tag, T value }
                    if (std.mem.eql(u8, m.method_name, "first") or
                        std.mem.eql(u8, m.method_name, "last") or
                        std.mem.eql(u8, m.method_name, "get"))
                    {
                        const elem_llvm_type = if (self.getArrayElementType(m.object)) |element_type|
                            self.typeToLLVM(element_type)
                        else
                            llvm.Types.int32(self.ctx); // Fallback to i32 if element type unknown
                        var opt_fields = [_]llvm.TypeRef{
                            llvm.Types.int1(self.ctx), // tag (bool, matches built-in Optional)
                            elem_llvm_type, // value
                        };
                        return llvm.Types.struct_(self.ctx, &opt_fields, false);
                    }
                }

                // List methods - check BEFORE Cell methods (which also have .get())
                if (self.isListExpr(m.object)) {
                    // len() and capacity() return i32
                    if (std.mem.eql(u8, m.method_name, "len") or
                        std.mem.eql(u8, m.method_name, "capacity"))
                    {
                        return llvm.Types.int32(self.ctx);
                    }
                    // is_empty() returns bool
                    if (std.mem.eql(u8, m.method_name, "is_empty")) {
                        return llvm.Types.int1(self.ctx);
                    }
                    // push(), set(), clear() return void (we use i32 as placeholder)
                    if (std.mem.eql(u8, m.method_name, "push") or
                        std.mem.eql(u8, m.method_name, "set") or
                        std.mem.eql(u8, m.method_name, "clear"))
                    {
                        return llvm.Types.int32(self.ctx);
                    }
                    // pop(), first(), last(), get() return Optional[T]
                    if (std.mem.eql(u8, m.method_name, "pop") or
                        std.mem.eql(u8, m.method_name, "first") or
                        std.mem.eql(u8, m.method_name, "last") or
                        std.mem.eql(u8, m.method_name, "get"))
                    {
                        const elem_llvm_type = if (self.getListElementType(m.object)) |element_type|
                            self.typeToLLVM(element_type)
                        else
                            llvm.Types.int32(self.ctx); // Fallback to i32 if element type unknown
                        var opt_fields = [_]llvm.TypeRef{
                            llvm.Types.int1(self.ctx), // tag
                            elem_llvm_type, // value
                        };
                        return llvm.Types.struct_(self.ctx, &opt_fields, false);
                    }
                    // clone(), take(), skip(), filter() return List[T]
                    if (std.mem.eql(u8, m.method_name, "clone") or
                        std.mem.eql(u8, m.method_name, "take") or
                        std.mem.eql(u8, m.method_name, "skip") or
                        std.mem.eql(u8, m.method_name, "filter"))
                    {
                        return self.getListStructType();
                    }
                    // map() returns List[U] (same struct, different element type)
                    if (std.mem.eql(u8, m.method_name, "map")) {
                        return self.getListStructType();
                    }
                    // enumerate() returns List[(i32, T)]
                    if (std.mem.eql(u8, m.method_name, "enumerate")) {
                        return self.getListStructType();
                    }
                    // zip() returns List[(T, U)]
                    if (std.mem.eql(u8, m.method_name, "zip")) {
                        return self.getListStructType();
                    }
                    // drop() returns void
                    if (std.mem.eql(u8, m.method_name, "drop")) {
                        return llvm.Types.int32(self.ctx);
                    }
                }

                // String (heap-allocated) methods
                if (self.isStringDataExpr(m.object)) {
                    // len() and capacity() return i32
                    if (std.mem.eql(u8, m.method_name, "len") or
                        std.mem.eql(u8, m.method_name, "capacity"))
                    {
                        return llvm.Types.int32(self.ctx);
                    }
                    // is_empty(), eq() return bool
                    if (std.mem.eql(u8, m.method_name, "is_empty") or
                        std.mem.eql(u8, m.method_name, "eq"))
                    {
                        return llvm.Types.int1(self.ctx);
                    }
                    // hash() returns i64
                    if (std.mem.eql(u8, m.method_name, "hash")) {
                        return llvm.Types.int64(self.ctx);
                    }
                    // push(), append(), clear(), drop() return void (we use i32 as placeholder)
                    if (std.mem.eql(u8, m.method_name, "push") or
                        std.mem.eql(u8, m.method_name, "append") or
                        std.mem.eql(u8, m.method_name, "clear") or
                        std.mem.eql(u8, m.method_name, "drop"))
                    {
                        return llvm.Types.int32(self.ctx);
                    }
                    // clone(), concat() return String
                    if (std.mem.eql(u8, m.method_name, "clone") or
                        std.mem.eql(u8, m.method_name, "concat"))
                    {
                        return self.getStringStructType();
                    }
                    // as_str() returns string pointer
                    if (std.mem.eql(u8, m.method_name, "as_str")) {
                        return llvm.Types.pointer(self.ctx);
                    }
                    // as_cstr() returns CStr (pointer)
                    if (std.mem.eql(u8, m.method_name, "as_cstr")) {
                        return llvm.Types.pointer(self.ctx);
                    }
                    // to_cstr() returns CStrOwned (pointer)
                    if (std.mem.eql(u8, m.method_name, "to_cstr")) {
                        return llvm.Types.pointer(self.ctx);
                    }
                }

                // CStr methods
                if (self.isCstrExpr(m.object)) {
                    // len() returns usize (i64)
                    if (std.mem.eql(u8, m.method_name, "len")) {
                        return llvm.Types.int64(self.ctx);
                    }
                    // to_string() returns String
                    if (std.mem.eql(u8, m.method_name, "to_string")) {
                        return self.getStringStructType();
                    }
                }

                // CStrOwned methods
                if (self.isCstrOwnedExpr(m.object)) {
                    // as_cstr() returns CStr (pointer)
                    if (std.mem.eql(u8, m.method_name, "as_cstr")) {
                        return llvm.Types.pointer(self.ctx);
                    }
                    // len() returns usize (i64)
                    if (std.mem.eql(u8, m.method_name, "len")) {
                        return llvm.Types.int64(self.ctx);
                    }
                    // to_string() returns String
                    if (std.mem.eql(u8, m.method_name, "to_string")) {
                        return self.getStringStructType();
                    }
                }

                // Primitive string methods (as_cstr, to_cstr)
                if (self.isPrimitiveStringExpr(m.object)) {
                    // as_cstr() returns CStr (pointer) - string literals are already null-terminated
                    if (std.mem.eql(u8, m.method_name, "as_cstr")) {
                        return llvm.Types.pointer(self.ctx);
                    }
                    // to_cstr() returns CStrOwned (pointer) - allocates null-terminated copy
                    if (std.mem.eql(u8, m.method_name, "to_cstr")) {
                        return llvm.Types.pointer(self.ctx);
                    }
                }

                // Map methods
                const infer_is_map = self.isMapExpr(m.object);
                if (infer_is_map) {
                    // len() and capacity() return i32
                    if (std.mem.eql(u8, m.method_name, "len") or
                        std.mem.eql(u8, m.method_name, "capacity"))
                    {
                        return llvm.Types.int32(self.ctx);
                    }
                    // is_empty(), contains_key() return bool
                    if (std.mem.eql(u8, m.method_name, "is_empty") or
                        std.mem.eql(u8, m.method_name, "contains_key"))
                    {
                        return llvm.Types.int1(self.ctx);
                    }
                    // insert(), clear(), drop() return void (we use i32 as placeholder)
                    if (std.mem.eql(u8, m.method_name, "insert") or
                        std.mem.eql(u8, m.method_name, "clear") or
                        std.mem.eql(u8, m.method_name, "drop"))
                    {
                        return llvm.Types.int32(self.ctx);
                    }
                    // get(), remove() return Optional[V]
                    if (std.mem.eql(u8, m.method_name, "get") or
                        std.mem.eql(u8, m.method_name, "remove"))
                    {
                        const value_llvm_type = if (self.getMapValueType(m.object)) |value_type|
                            self.typeToLLVM(value_type)
                        else
                            llvm.Types.int32(self.ctx); // Fallback to i32 if value type unknown
                        var opt_fields = [_]llvm.TypeRef{
                            llvm.Types.int1(self.ctx), // tag
                            value_llvm_type, // value
                        };
                        return llvm.Types.struct_(self.ctx, &opt_fields, false);
                    }
                    // keys() returns List[K]
                    if (std.mem.eql(u8, m.method_name, "keys")) {
                        return self.getListStructType();
                    }
                    // values() returns List[V]
                    if (std.mem.eql(u8, m.method_name, "values")) {
                        return self.getListStructType();
                    }
                    // clone() returns Map[K,V]
                    if (std.mem.eql(u8, m.method_name, "clone")) {
                        return self.getMapStructType();
                    }
                }

                // Set methods
                if (self.isSetExpr(m.object)) {
                    // len() and capacity() return i32
                    if (std.mem.eql(u8, m.method_name, "len") or
                        std.mem.eql(u8, m.method_name, "capacity"))
                    {
                        return llvm.Types.int32(self.ctx);
                    }
                    // is_empty(), contains(), insert(), remove() return bool
                    if (std.mem.eql(u8, m.method_name, "is_empty") or
                        std.mem.eql(u8, m.method_name, "contains") or
                        std.mem.eql(u8, m.method_name, "insert") or
                        std.mem.eql(u8, m.method_name, "remove"))
                    {
                        return llvm.Types.int1(self.ctx);
                    }
                    // clear(), drop() return void (we use i32 as placeholder)
                    if (std.mem.eql(u8, m.method_name, "clear") or
                        std.mem.eql(u8, m.method_name, "drop"))
                    {
                        return llvm.Types.int32(self.ctx);
                    }
                    // clone(), union(), intersection(), difference() return Set[T]
                    if (std.mem.eql(u8, m.method_name, "clone") or
                        std.mem.eql(u8, m.method_name, "union") or
                        std.mem.eql(u8, m.method_name, "intersection") or
                        std.mem.eql(u8, m.method_name, "difference"))
                    {
                        return self.getSetStructType();
                    }
                    // take(n), skip(n), filter(fn) return Set[T]
                    if (std.mem.eql(u8, m.method_name, "take") or
                        std.mem.eql(u8, m.method_name, "skip") or
                        std.mem.eql(u8, m.method_name, "filter"))
                    {
                        return self.getSetStructType();
                    }
                    // map(fn), enumerate(), zip(other) return List
                    if (std.mem.eql(u8, m.method_name, "map") or
                        std.mem.eql(u8, m.method_name, "enumerate") or
                        std.mem.eql(u8, m.method_name, "zip"))
                    {
                        return self.getListStructType();
                    }
                }

                // downgrade() always returns pointer (Weak type)
                if (std.mem.eql(u8, m.method_name, "downgrade")) {
                    return llvm.Types.pointer(self.ctx);
                }
                // clone() - for Rc/Arc returns pointer, for Clone trait returns same type as object
                if (std.mem.eql(u8, m.method_name, "clone")) {
                    if (self.isArcType(m.object) or self.isRcType(m.object)) {
                        return llvm.Types.pointer(self.ctx);
                    }
                    // For Clone trait, return the type of the object being cloned
                    return self.inferExprType(m.object);
                }
                // upgrade() returns optional pointer - struct {i1, ptr}
                if (std.mem.eql(u8, m.method_name, "upgrade")) {
                    const ptr_type = llvm.Types.pointer(self.ctx);
                    var opt_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), ptr_type };
                    return llvm.Types.struct_(self.ctx, &opt_fields, false);
                }
                // Cell methods: get(), replace(), set()
                // Only applies when object has inner_type (indicating it's a Cell)
                // First check if this is a user-defined struct/enum method
                const has_user_method = blk: {
                    if (self.getStructNameFromExpr(m.object)) |struct_name| {
                        var fn_name_buf = std.ArrayListUnmanaged(u8){};
                        defer fn_name_buf.deinit(self.allocator);
                        fn_name_buf.appendSlice(self.allocator, struct_name) catch break :blk false;
                        fn_name_buf.append(self.allocator, '_') catch break :blk false;
                        fn_name_buf.appendSlice(self.allocator, m.method_name) catch break :blk false;
                        const fn_name = self.allocator.dupeZ(u8, fn_name_buf.items) catch break :blk false;
                        defer self.allocator.free(fn_name);
                        if (self.module.getNamedFunction(fn_name) != null) {
                            break :blk true;
                        }
                    }
                    break :blk false;
                };

                // Only check Cell methods if not a Map, List, Array, and no user method found
                const is_cell_for_infer = !has_user_method and
                    !self.isMapExpr(m.object) and
                    !self.isListExpr(m.object) and
                    !self.isArrayExpr(m.object);

                if (is_cell_for_infer) {
                    // Cell methods: get() returns the inner type
                    if (std.mem.eql(u8, m.method_name, "get")) {
                        return self.inferCellInnerType(m.object);
                    }
                    // replace() returns the inner type (old value)
                    if (std.mem.eql(u8, m.method_name, "replace")) {
                        return self.inferCellInnerType(m.object);
                    }
                    // set() returns void (we use i32 as placeholder)
                    if (std.mem.eql(u8, m.method_name, "set")) {
                        return llvm.Types.int32(self.ctx);
                    }
                }
                // Eq trait: eq() returns bool (i1)
                if (std.mem.eql(u8, m.method_name, "eq")) {
                    return llvm.Types.int1(self.ctx);
                }
                // Ordered trait: lt(), le(), gt(), ge() return bool (i1)
                if (std.mem.eql(u8, m.method_name, "lt") or
                    std.mem.eql(u8, m.method_name, "le") or
                    std.mem.eql(u8, m.method_name, "gt") or
                    std.mem.eql(u8, m.method_name, "ge"))
                {
                    return llvm.Types.int1(self.ctx);
                }
                // is_ok, is_err, is_some, is_none all return bool
                if (std.mem.eql(u8, m.method_name, "is_ok") or
                    std.mem.eql(u8, m.method_name, "is_err") or
                    std.mem.eql(u8, m.method_name, "is_some") or
                    std.mem.eql(u8, m.method_name, "is_none"))
                {
                    return llvm.Types.int1(self.ctx);
                }
                // Result.ok() returns Optional[T] where Result is Result[T, E]
                if (std.mem.eql(u8, m.method_name, "ok")) {
                    // Get the Result type from the object
                    const result_type = try self.inferExprType(m.object);
                    // ok_type is at index 1 in the Result struct {tag, ok_value, err_value}
                    const ok_type = llvm.c.LLVMStructGetTypeAtIndex(result_type, 1);
                    // Build Optional type: {i1, T}
                    var opt_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), ok_type };
                    return llvm.Types.struct_(self.ctx, &opt_fields, false);
                }
                // Result.err() returns Optional[E] where Result is Result[T, E]
                if (std.mem.eql(u8, m.method_name, "err")) {
                    // Get the Result type from the object
                    const result_type = try self.inferExprType(m.object);
                    // err_type is at index 2 in the Result struct {tag, ok_value, err_value}
                    const err_type = llvm.c.LLVMStructGetTypeAtIndex(result_type, 2);
                    // Build Optional type: {i1, E}
                    var opt_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), err_type };
                    return llvm.Types.struct_(self.ctx, &opt_fields, false);
                }
                // Result.unwrap_err() returns E directly where Result is Result[T, E]
                if (std.mem.eql(u8, m.method_name, "unwrap_err")) {
                    // Get the Result type from the object
                    const result_type = try self.inferExprType(m.object);
                    // err_type is at index 2 in the Result struct {tag, ok_value, err_value}
                    return llvm.c.LLVMStructGetTypeAtIndex(result_type, 2);
                }
                // Result.unwrap() returns T directly where Result is Result[T, E]
                if (std.mem.eql(u8, m.method_name, "unwrap")) {
                    // Get the Result type from the object
                    const result_type = try self.inferExprType(m.object);
                    // ok_type is at index 1 in the Result struct {tag, ok_value, err_value}
                    return llvm.c.LLVMStructGetTypeAtIndex(result_type, 1);
                }
                // map(f) returns Optional[U] or Result[U, E] where U is the function's return type
                if (std.mem.eql(u8, m.method_name, "map")) {
                    // The return type is determined by the function argument's return type
                    // wrapped in Optional or Result
                    const object_type = try self.inferExprType(m.object);
                    const num_fields = llvm.c.LLVMCountStructElementTypes(object_type);
                    const is_result = num_fields == 3;

                    // For now, use i32 as the mapped type (closure return type)
                    // The actual type will be determined at runtime from the closure call
                    if (is_result) {
                        const err_type = llvm.c.LLVMStructGetTypeAtIndex(object_type, 2);
                        var result_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), llvm.Types.int32(self.ctx), err_type };
                        return llvm.Types.struct_(self.ctx, &result_fields, false);
                    } else {
                        var opt_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), llvm.Types.int32(self.ctx) };
                        return llvm.Types.struct_(self.ctx, &opt_fields, false);
                    }
                }
                // and_then(f) returns the function's return type directly
                if (std.mem.eql(u8, m.method_name, "and_then")) {
                    // Same as map - the result type is determined by the closure
                    const object_type = try self.inferExprType(m.object);
                    const num_fields = llvm.c.LLVMCountStructElementTypes(object_type);
                    const is_result = num_fields == 3;

                    if (is_result) {
                        const err_type = llvm.c.LLVMStructGetTypeAtIndex(object_type, 2);
                        var result_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), llvm.Types.int32(self.ctx), err_type };
                        return llvm.Types.struct_(self.ctx, &result_fields, false);
                    } else {
                        var opt_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), llvm.Types.int32(self.ctx) };
                        return llvm.Types.struct_(self.ctx, &opt_fields, false);
                    }
                }
                // map_err(f) returns Result[T, F] where T is unchanged and F is the mapped error type
                if (std.mem.eql(u8, m.method_name, "map_err")) {
                    // Get the Result type from the object
                    const object_type = try self.inferExprType(m.object);
                    // ok_type is at index 1, unchanged
                    const ok_type = llvm.c.LLVMStructGetTypeAtIndex(object_type, 1);
                    // For now, use i32 as the mapped error type (closure return type)
                    var result_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), ok_type, llvm.Types.int32(self.ctx) };
                    return llvm.Types.struct_(self.ctx, &result_fields, false);
                }
                // context(msg) returns Result[T, ContextError[E]] where T and E come from the original Result
                if (std.mem.eql(u8, m.method_name, "context")) {
                    // Get the Result type from the object
                    const object_type = try self.inferExprType(m.object);
                    // ok_type is at index 1, unchanged
                    const ok_type = llvm.c.LLVMStructGetTypeAtIndex(object_type, 1);
                    // err_type is at index 2
                    const err_type = llvm.c.LLVMStructGetTypeAtIndex(object_type, 2);
                    // ContextError[E] layout: { message: ptr, cause: E, file: ptr, line: i32, column: i32 }
                    var context_err_fields = [_]llvm.TypeRef{
                        llvm.Types.pointer(self.ctx), // message
                        err_type, // cause
                        llvm.Types.pointer(self.ctx), // file
                        llvm.Types.int32(self.ctx), // line
                        llvm.Types.int32(self.ctx), // column
                    };
                    const context_err_type = llvm.Types.struct_(self.ctx, &context_err_fields, false);
                    // Result[T, ContextError[E]] layout: { tag: i1, ok_value: T, err_value: ContextError[E] }
                    var result_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), ok_type, context_err_type };
                    return llvm.Types.struct_(self.ctx, &result_fields, false);
                }
                // Hash trait: hash() returns i64
                if (std.mem.eql(u8, m.method_name, "hash")) {
                    return llvm.Types.int64(self.ctx);
                }
                // ContextError methods
                // message() returns string (pointer)
                if (std.mem.eql(u8, m.method_name, "message")) {
                    const object_type = try self.inferExprType(m.object);
                    // Check if object type looks like a ContextError (struct with 5 fields)
                    if (llvm.c.LLVMGetTypeKind(object_type) == llvm.c.LLVMStructTypeKind) {
                        if (llvm.c.LLVMCountStructElementTypes(object_type) == 5) {
                            return llvm.Types.pointer(self.ctx);
                        }
                    }
                }
                // cause() returns the inner error type
                if (std.mem.eql(u8, m.method_name, "cause")) {
                    const object_type = try self.inferExprType(m.object);
                    // Check if object type looks like a ContextError (struct with 5 fields)
                    if (llvm.c.LLVMGetTypeKind(object_type) == llvm.c.LLVMStructTypeKind) {
                        if (llvm.c.LLVMCountStructElementTypes(object_type) == 5) {
                            // Return the cause type (second field)
                            return llvm.c.LLVMStructGetTypeAtIndex(object_type, 1);
                        }
                    }
                }
                // display_chain() returns string (pointer)
                if (std.mem.eql(u8, m.method_name, "display_chain")) {
                    const object_type = try self.inferExprType(m.object);
                    // Check if object type looks like a ContextError (struct with 5 fields)
                    if (llvm.c.LLVMGetTypeKind(object_type) == llvm.c.LLVMStructTypeKind) {
                        if (llvm.c.LLVMCountStructElementTypes(object_type) == 5) {
                            return llvm.Types.pointer(self.ctx);
                        }
                    }
                }
                // String methods
                // len() returns i32
                if (std.mem.eql(u8, m.method_name, "len")) {
                    return llvm.Types.int32(self.ctx);
                }
                // is_empty(), contains(), starts_with(), ends_with() return bool
                if (std.mem.eql(u8, m.method_name, "is_empty") or
                    std.mem.eql(u8, m.method_name, "contains") or
                    std.mem.eql(u8, m.method_name, "starts_with") or
                    std.mem.eql(u8, m.method_name, "ends_with"))
                {
                    return llvm.Types.int1(self.ctx);
                }
                // trim(), to_uppercase(), to_lowercase() return string (pointer)
                if (std.mem.eql(u8, m.method_name, "trim") or
                    std.mem.eql(u8, m.method_name, "to_uppercase") or
                    std.mem.eql(u8, m.method_name, "to_lowercase"))
                {
                    return llvm.Types.pointer(self.ctx);
                }
                // bytes() and chars() return slice struct { ptr, len }
                if (std.mem.eql(u8, m.method_name, "bytes") or
                    std.mem.eql(u8, m.method_name, "chars"))
                {
                    var slice_fields = [_]llvm.TypeRef{
                        llvm.Types.pointer(self.ctx), // data pointer
                        llvm.Types.int64(self.ctx), // length
                    };
                    return llvm.Types.struct_(self.ctx, &slice_fields, false);
                }

                // Default trait: TypeName.default() returns the type's default value
                if (std.mem.eql(u8, m.method_name, "default")) {
                    if (m.object == .identifier) {
                        const type_name = m.object.identifier.name;
                        // Map type name to LLVM type
                        if (std.mem.eql(u8, type_name, "i8")) return llvm.Types.int8(self.ctx);
                        if (std.mem.eql(u8, type_name, "i16")) return llvm.Types.int16(self.ctx);
                        if (std.mem.eql(u8, type_name, "i32")) return llvm.Types.int32(self.ctx);
                        if (std.mem.eql(u8, type_name, "i64")) return llvm.Types.int64(self.ctx);
                        if (std.mem.eql(u8, type_name, "i128")) return llvm.Types.int128(self.ctx);
                        if (std.mem.eql(u8, type_name, "isize")) return llvm.Types.int64(self.ctx);
                        if (std.mem.eql(u8, type_name, "u8")) return llvm.Types.int8(self.ctx);
                        if (std.mem.eql(u8, type_name, "u16")) return llvm.Types.int16(self.ctx);
                        if (std.mem.eql(u8, type_name, "u32")) return llvm.Types.int32(self.ctx);
                        if (std.mem.eql(u8, type_name, "u64")) return llvm.Types.int64(self.ctx);
                        if (std.mem.eql(u8, type_name, "u128")) return llvm.Types.int128(self.ctx);
                        if (std.mem.eql(u8, type_name, "usize")) return llvm.Types.int64(self.ctx);
                        if (std.mem.eql(u8, type_name, "f32")) return llvm.Types.float32(self.ctx);
                        if (std.mem.eql(u8, type_name, "f64")) return llvm.Types.float64(self.ctx);
                        if (std.mem.eql(u8, type_name, "bool")) return llvm.Types.int1(self.ctx);
                        if (std.mem.eql(u8, type_name, "char")) return llvm.Types.int32(self.ctx);
                        if (std.mem.eql(u8, type_name, "string")) return llvm.Types.pointer(self.ctx);
                        // Check for struct types
                        if (self.struct_types.get(type_name)) |struct_info| {
                            return struct_info.llvm_type;
                        }
                    }
                }

                // Range methods
                if (self.isRangeExpr(m.object)) {
                    // next() returns Optional[i32] - struct { i1 tag, i32 value }
                    if (std.mem.eql(u8, m.method_name, "next")) {
                        var opt_fields = [_]llvm.TypeRef{
                            llvm.Types.int1(self.ctx), // tag
                            llvm.Types.int32(self.ctx), // value (i32 for now)
                        };
                        return llvm.Types.struct_(self.ctx, &opt_fields, false);
                    }
                    // reset() returns void (represented as i32)
                    if (std.mem.eql(u8, m.method_name, "reset")) {
                        return llvm.Types.int32(self.ctx);
                    }
                    // is_empty() returns bool
                    if (std.mem.eql(u8, m.method_name, "is_empty")) {
                        return llvm.Types.int1(self.ctx);
                    }
                    // len() returns i32
                    if (std.mem.eql(u8, m.method_name, "len")) {
                        return llvm.Types.int32(self.ctx);
                    }
                }

                // Try to look up user-defined struct method by function name
                // Function name format: StructName_method_name
                // First check for instance methods (object is a variable of struct type)
                if (self.getStructNameFromExpr(m.object)) |struct_name| {
                    var fn_name_buf = std.ArrayListUnmanaged(u8){};
                    defer fn_name_buf.deinit(self.allocator);
                    fn_name_buf.appendSlice(self.allocator, struct_name) catch return EmitError.OutOfMemory;
                    fn_name_buf.append(self.allocator, '_') catch return EmitError.OutOfMemory;
                    fn_name_buf.appendSlice(self.allocator, m.method_name) catch return EmitError.OutOfMemory;

                    const fn_name = self.allocator.dupeZ(u8, fn_name_buf.items) catch return EmitError.OutOfMemory;
                    defer self.allocator.free(fn_name);

                    if (self.module.getNamedFunction(fn_name)) |func| {
                        const fn_type = llvm.getGlobalValueType(func);
                        return llvm.getReturnType(fn_type);
                    }
                }

                // to_string() method - char returns primitive string, other types return String struct
                if (std.mem.eql(u8, m.method_name, "to_string")) {
                    if (self.isCharExpr(m.object)) {
                        // char.to_string() returns primitive string (pointer)
                        return llvm.Types.pointer(self.ctx);
                    }
                    // Other types (integers, etc.) return String struct
                    return self.getStringStructType();
                }

                // Check for static method calls where object is a type name (e.g., Counter.new())
                if (m.object == .identifier) {
                    const type_name = m.object.identifier.name;
                    // Check if this identifier is a struct type (not a variable)
                    if (self.struct_types.contains(type_name)) {
                        var fn_name_buf = std.ArrayListUnmanaged(u8){};
                        defer fn_name_buf.deinit(self.allocator);
                        fn_name_buf.appendSlice(self.allocator, type_name) catch return EmitError.OutOfMemory;
                        fn_name_buf.append(self.allocator, '_') catch return EmitError.OutOfMemory;
                        fn_name_buf.appendSlice(self.allocator, m.method_name) catch return EmitError.OutOfMemory;

                        const fn_name = self.allocator.dupeZ(u8, fn_name_buf.items) catch return EmitError.OutOfMemory;
                        defer self.allocator.free(fn_name);

                        if (self.module.getNamedFunction(fn_name)) |func| {
                            const fn_type = llvm.getGlobalValueType(func);
                            return llvm.getReturnType(fn_type);
                        }
                    }
                }

                return llvm.Types.int32(self.ctx);
            },
            .closure => {
                // Closure type is a struct { fn_ptr: ptr, env_ptr: ptr }
                var closure_fields = [_]llvm.TypeRef{
                    llvm.Types.pointer(self.ctx), // fn_ptr
                    llvm.Types.pointer(self.ctx), // env_ptr
                };
                return llvm.Types.struct_(self.ctx, &closure_fields, false);
            },
            .unary => |un| {
                return switch (un.op) {
                    .negate, .not => try self.inferExprType(un.operand),
                    .deref => {
                        // Dereference returns the inner type
                        return try self.inferDerefType(un.operand);
                    },
                    .ref, .ref_mut => {
                        // Reference returns a pointer type
                        return llvm.Types.pointer(self.ctx);
                    },
                };
            },
            .type_cast => |tc| {
                // Return the target type of the cast
                return self.getTypeByName(switch (tc.target_type) {
                    .named => |n| n.name,
                    else => return llvm.Types.int32(self.ctx),
                }) orelse llvm.Types.int32(self.ctx);
            },
            .block => |blk| {
                // Block type is the type of its final expression, or void if none
                if (blk.final_expr) |final| {
                    return try self.inferExprType(final);
                }
                return llvm.Types.void_(self.ctx);
            },
            .unsafe_block => |ub| {
                // Unsafe block type is the type of its body block's final expression
                if (ub.body.final_expr) |final| {
                    return try self.inferExprType(final);
                }
                return llvm.Types.void_(self.ctx);
            },
            .enum_literal => |lit| {
                // Look up the registered enum type
                const mangled_name = try self.getMangledEnumName(lit.enum_type);
                if (self.struct_types.get(mangled_name)) |enum_info| {
                    return enum_info.llvm_type;
                }
                // Try base name for non-generic enums
                const base_name = switch (lit.enum_type) {
                    .named => |n| n.name,
                    .generic_apply => |g| switch (g.base) {
                        .named => |n| n.name,
                        else => return llvm.Types.int32(self.ctx),
                    },
                    else => return llvm.Types.int32(self.ctx),
                };
                if (self.struct_types.get(base_name)) |enum_info| {
                    return enum_info.llvm_type;
                }
                return llvm.Types.int32(self.ctx);
            },
            // Comptime expressions
            .builtin_call => |bc| {
                // Check for user-defined comptime function call results first
                if (self.type_checker) |tc| {
                    if (tc.comptime_builtin_values.get(bc)) |comptime_value| {
                        return switch (comptime_value) {
                            .int => |i| if (i.is_i32) llvm.Types.int32(self.ctx) else llvm.Types.int64(self.ctx),
                            .float => llvm.Types.float64(self.ctx),
                            .bool_ => llvm.Types.int1(self.ctx),
                            .string => llvm.Types.pointer(self.ctx),
                            .void_ => llvm.Types.int32(self.ctx),
                            .struct_ => |cs| blk: {
                                // Get the LLVM struct type
                                if (self.struct_types.get(cs.type_name)) |struct_info| {
                                    break :blk struct_info.llvm_type;
                                }
                                break :blk llvm.Types.int32(self.ctx); // Fallback
                            },
                            .array => |arr| blk: {
                                // Get the LLVM array type
                                const elem_llvm_type = self.typeToLLVM(arr.element_type);
                                break :blk llvm.Types.array(elem_llvm_type, @intCast(arr.elements.len));
                            },
                        };
                    }
                }
                // Builtin calls that return strings
                if (std.mem.eql(u8, bc.name, "typeName") or
                    std.mem.eql(u8, bc.name, "typeInfo") or
                    std.mem.eql(u8, bc.name, "fields"))
                {
                    return llvm.Types.pointer(self.ctx); // string type
                }
                // @hasField returns bool
                if (std.mem.eql(u8, bc.name, "hasField")) {
                    return llvm.Types.int1(self.ctx); // bool type
                }
                // @sizeOf and @alignOf return i32
                if (std.mem.eql(u8, bc.name, "sizeOf") or std.mem.eql(u8, bc.name, "alignOf")) {
                    return llvm.Types.int32(self.ctx);
                }
                // @repeat returns an array type
                if (std.mem.eql(u8, bc.name, "repeat")) {
                    if (self.type_checker) |tc| {
                        if (tc.comptime_repeats.get(bc)) |repeat_info| {
                            const elem_llvm_type = self.typeToLLVM(repeat_info.element_type);
                            return llvm.Types.array(elem_llvm_type, repeat_info.count);
                        }
                    }
                }
                // Default to i32 for unknown builtins
                return llvm.Types.int32(self.ctx);
            },
            .comptime_block => |cb| blk: {
                // Look up the precomputed result from type checker
                if (self.type_checker) |tc| {
                    if (tc.comptime_values.get(cb)) |comptime_value| {
                        break :blk switch (comptime_value) {
                            .int => |i| if (i.is_i32) llvm.Types.int32(self.ctx) else llvm.Types.int64(self.ctx),
                            .float => llvm.Types.float64(self.ctx),
                            .bool_ => llvm.Types.int1(self.ctx),
                            .string => llvm.Types.pointer(self.ctx),
                            .void_ => llvm.Types.int32(self.ctx),
                            .struct_ => |cs| struct_blk: {
                                // Get the LLVM struct type
                                if (self.struct_types.get(cs.type_name)) |struct_info| {
                                    break :struct_blk struct_info.llvm_type;
                                }
                                break :struct_blk llvm.Types.int32(self.ctx); // Fallback
                            },
                            .array => |arr| arr_blk: {
                                // Get the LLVM array type
                                const elem_llvm_type = self.typeToLLVM(arr.element_type);
                                break :arr_blk llvm.Types.array(elem_llvm_type, @intCast(arr.elements.len));
                            },
                        };
                    }
                }
                break :blk llvm.Types.int32(self.ctx); // Fallback
            },
            .range => {
                // Range type: { start: T, end: T, current: T, inclusive: i1 }
                // For now, assume i32 element type
                const i32_type = llvm.Types.int32(self.ctx);
                const i1_type = llvm.Types.int1(self.ctx);
                var fields = [_]llvm.TypeRef{
                    i32_type, // start
                    i32_type, // end
                    i32_type, // current
                    i1_type, // inclusive
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            else => llvm.Types.int32(self.ctx),
        };
    }

    /// Get the LLVM module reference for further operations.
    pub fn getModule(self: *Emitter) llvm.Module {
        return self.module;
    }

    /// Verify the module.
    pub fn verify(self: *Emitter) !void {
        try self.module.verify();
    }

    /// Extract struct type name from an expression if it's a struct literal.
    fn getStructTypeName(self: *Emitter, expr: ast.Expr) ?[]const u8 {
        return switch (expr) {
            .identifier => |id| {
                // Look up variable's struct type name
                if (self.named_values.get(id.name)) |local| {
                    return local.struct_type_name;
                }
                return null;
            },
            .struct_literal => |lit| {
                if (lit.type_name) |type_name| {
                    return switch (type_name) {
                        .named => |n| n.name,
                        .generic_apply => |g| blk: {
                            // Build mangled name for generic struct
                            const base_name = switch (g.base) {
                                .named => |n| n.name,
                                else => break :blk null,
                            };
                            var mangled = std.ArrayListUnmanaged(u8){};
                            mangled.appendSlice(self.allocator, base_name) catch break :blk null;
                            for (g.args) |arg| {
                                mangled.append(self.allocator, '$') catch break :blk null;
                                self.appendTypeNameForMangling(&mangled, arg) catch break :blk null;
                            }
                            break :blk mangled.toOwnedSlice(self.allocator) catch null;
                        },
                        else => null,
                    };
                }
                return null;
            },
            .comptime_block => |cb| {
                // Look up the comptime value and extract struct type name
                if (self.type_checker) |tc| {
                    if (tc.comptime_values.get(cb)) |comptime_value| {
                        if (comptime_value == .struct_) {
                            return comptime_value.struct_.type_name;
                        }
                    }
                }
                return null;
            },
            else => null,
        };
    }

    /// Extract struct type name from a type annotation (TypeExpr).
    /// Used as fallback when the expression doesn't provide a struct name
    /// (e.g., for method calls that return structs).
    fn getStructTypeNameFromAnnotation(self: *Emitter, type_expr: ast.TypeExpr) ?[]const u8 {
        _ = self;
        return switch (type_expr) {
            .named => |n| n.name,
            else => null,
        };
    }

    /// Extract struct type name from an expression, including call expressions and field access.
    /// For call expressions, looks up the function's return type.
    /// For field expressions, looks up the field's type in the parent struct.
    fn getStructTypeNameFromExpr(self: *Emitter, expr: ast.Expr) ?[]const u8 {
        // First try the basic getStructTypeName for identifiers and struct literals
        if (self.getStructTypeName(expr)) |name| {
            return name;
        }

        // For call expressions, look up the function's return type
        if (expr == .call) {
            const call = expr.call;
            const func_name = switch (call.callee) {
                .identifier => |id| id.name,
                else => return null,
            };

            // Check if we have type checker info for the function's return type
            if (self.type_checker) |tc| {
                // Look up the function symbol to get its return type
                if (tc.global_scope.lookup(func_name)) |sym| {
                    if (sym.type_ == .function) {
                        const ret_type = sym.type_.function.return_type;
                        if (ret_type == .struct_) {
                            return ret_type.struct_.name;
                        }
                    }
                }
            }
        }

        // For field expressions, look up the field's type in the parent struct
        if (expr == .field) {
            const field = expr.field;
            // Recursively get the struct type name of the object
            const parent_struct_name = self.getStructTypeNameFromExpr(field.object) orelse return null;
            // Look up the field type
            return self.lookupFieldStructTypeName(parent_struct_name, field.field_name);
        }

        // For index expressions (array[i]), get the element type of the array
        if (expr == .index) {
            const idx = expr.index;
            // Get the array's element type by looking up the variable type
            if (idx.object == .identifier) {
                const var_name = idx.object.identifier.name;
                // Look up in local variables first
                if (self.named_values.get(var_name)) |local| {
                    if (local.array_element_type) |elem_type| {
                        if (elem_type == .struct_) {
                            return elem_type.struct_.name;
                        }
                    }
                }
                // Fall back to type checker's scope for the variable type
                if (self.type_checker) |tc| {
                    if (tc.global_scope.lookup(var_name)) |sym| {
                        if (sym.type_ == .array) {
                            const elem_type = sym.type_.array.element;
                            if (elem_type == .struct_) {
                                return elem_type.struct_.name;
                            }
                        }
                    }
                }
            }
            return null;
        }

        return null;
    }

    /// Look up the struct type name of a field, if the field is a struct type.
    fn lookupFieldStructTypeName(self: *Emitter, struct_type_name: []const u8, field_name: []const u8) ?[]const u8 {
        const tc = self.type_checker orelse return null;

        // Try global scope for non-generic structs
        if (tc.global_scope.lookup(struct_type_name)) |sym| {
            if (sym.type_ == .struct_) {
                for (sym.type_.struct_.fields) |field| {
                    if (std.mem.eql(u8, field.name, field_name)) {
                        if (field.type_ == .struct_) {
                            return field.type_.struct_.name;
                        }
                        return null;
                    }
                }
            }
        }

        // Try monomorphized structs for generic types
        for (tc.getMonomorphizedStructs()) |mono| {
            if (std.mem.eql(u8, mono.mangled_name, struct_type_name)) {
                for (mono.concrete_type.fields) |field| {
                    if (std.mem.eql(u8, field.name, field_name)) {
                        if (field.type_ == .struct_) {
                            return field.type_.struct_.name;
                        }
                        return null;
                    }
                }
            }
        }

        return null;
    }

    /// Look up a field index by name for a struct type.
    fn lookupFieldIndex(self: *Emitter, struct_type_name: []const u8, field_name: []const u8) ?u32 {
        if (self.struct_types.get(struct_type_name)) |info| {
            for (info.field_names, 0..) |name, i| {
                if (std.mem.eql(u8, name, field_name)) {
                    return info.field_indices[i];
                }
            }
        }
        return null;
    }

    /// Look up the LLVM type for a field, using registered struct types for struct-typed fields.
    /// This is necessary because LLVMStructGetTypeAtIndex may return a type reference that
    /// differs from the registered struct type in struct_types, causing load failures.
    fn lookupFieldType(self: *Emitter, struct_type_name: []const u8, field_name: []const u8) ?llvm.TypeRef {
        const tc = self.type_checker orelse return null;

        // Try global scope for non-generic structs
        if (tc.global_scope.lookup(struct_type_name)) |sym| {
            if (sym.type_ == .struct_) {
                for (sym.type_.struct_.fields) |field| {
                    if (std.mem.eql(u8, field.name, field_name)) {
                        return self.typeToLLVM(field.type_);
                    }
                }
            }
        }

        // Try monomorphized structs for generic types
        for (tc.getMonomorphizedStructs()) |mono| {
            if (std.mem.eql(u8, mono.mangled_name, struct_type_name)) {
                for (mono.concrete_type.fields) |field| {
                    if (std.mem.eql(u8, field.name, field_name)) {
                        return self.typeToLLVM(field.type_);
                    }
                }
            }
        }

        return null;
    }

    /// Look up the semantic Type for a field in a struct.
    /// Returns the Klar Type (not LLVM type) for the field.
    fn getFieldType(self: *Emitter, struct_type_name: []const u8, field_name: []const u8) ?types.Type {
        const tc = self.type_checker orelse return null;

        // Try global scope for non-generic structs
        if (tc.global_scope.lookup(struct_type_name)) |sym| {
            if (sym.type_ == .struct_) {
                for (sym.type_.struct_.fields) |field| {
                    if (std.mem.eql(u8, field.name, field_name)) {
                        return field.type_;
                    }
                }
            }
        }

        // Try monomorphized structs for generic types
        for (tc.getMonomorphizedStructs()) |mono| {
            if (std.mem.eql(u8, mono.mangled_name, struct_type_name)) {
                for (mono.concrete_type.fields) |field| {
                    if (std.mem.eql(u8, field.name, field_name)) {
                        return field.type_;
                    }
                }
            }
        }

        return null;
    }

    /// Append a type name to a buffer for name mangling (works with AST TypeExpr).
    fn appendTypeNameForMangling(self: *Emitter, buf: *std.ArrayListUnmanaged(u8), type_expr: ast.TypeExpr) !void {
        switch (type_expr) {
            .named => |n| try buf.appendSlice(self.allocator, n.name),
            .array => |a| {
                try buf.appendSlice(self.allocator, "arr_");
                try self.appendTypeNameForMangling(buf, a.element);
            },
            .slice => |s| {
                try buf.appendSlice(self.allocator, "slice_");
                try self.appendTypeNameForMangling(buf, s.element);
            },
            .optional => |o| {
                try buf.appendSlice(self.allocator, "opt_");
                try self.appendTypeNameForMangling(buf, o.inner);
            },
            .reference => |r| {
                try buf.appendSlice(self.allocator, if (r.mutable) "mutref_" else "ref_");
                try self.appendTypeNameForMangling(buf, r.inner);
            },
            .generic_apply => |g| {
                try self.appendTypeNameForMangling(buf, g.base);
                for (g.args) |arg| {
                    try buf.append(self.allocator, '_');
                    try self.appendTypeNameForMangling(buf, arg);
                }
            },
            .tuple => |t| {
                try buf.appendSlice(self.allocator, "tup");
                for (t.elements) |elem| {
                    try buf.append(self.allocator, '_');
                    try self.appendTypeNameForMangling(buf, elem);
                }
            },
            .result => {
                try buf.appendSlice(self.allocator, "result");
            },
            .function => {
                try buf.appendSlice(self.allocator, "fn");
            },
            .qualified => |q| {
                // For qualified types like Self.Item, mangle as Base_Member
                try self.appendTypeNameForMangling(buf, q.base);
                try buf.append(self.allocator, '_');
                try buf.appendSlice(self.allocator, q.member);
            },
        }
    }

    /// Append type name for mangling from a types.Type value.
    fn appendCheckerTypeNameForMangling(self: *Emitter, buf: *std.ArrayListUnmanaged(u8), ty: types.Type) !void {
        switch (ty) {
            .primitive => |p| {
                const name: []const u8 = switch (p) {
                    .i8_ => "i8",
                    .i16_ => "i16",
                    .i32_ => "i32",
                    .i64_ => "i64",
                    .i128_ => "i128",
                    .isize_ => "isize",
                    .u8_ => "u8",
                    .u16_ => "u16",
                    .u32_ => "u32",
                    .u64_ => "u64",
                    .u128_ => "u128",
                    .usize_ => "usize",
                    .f32_ => "f32",
                    .f64_ => "f64",
                    .bool_ => "bool",
                    .char_ => "char",
                    .string_ => "string",
                };
                try buf.appendSlice(self.allocator, name);
            },
            .void_ => try buf.appendSlice(self.allocator, "void"),
            .struct_ => |s| try buf.appendSlice(self.allocator, s.name),
            .enum_ => |e| try buf.appendSlice(self.allocator, e.name),
            .optional => |o| {
                try buf.appendSlice(self.allocator, "opt_");
                try self.appendCheckerTypeNameForMangling(buf, o.*);
            },
            .array => |a| {
                try buf.appendSlice(self.allocator, "arr_");
                try self.appendCheckerTypeNameForMangling(buf, a.element);
            },
            .slice => |s| {
                try buf.appendSlice(self.allocator, "slice_");
                try self.appendCheckerTypeNameForMangling(buf, s.element);
            },
            .reference => |r| {
                try buf.appendSlice(self.allocator, if (r.mutable) "mutref_" else "ref_");
                try self.appendCheckerTypeNameForMangling(buf, r.inner);
            },
            .applied => |a| {
                try self.appendCheckerTypeNameForMangling(buf, a.base);
                for (a.args) |arg| {
                    try buf.append(self.allocator, '$');
                    try self.appendCheckerTypeNameForMangling(buf, arg);
                }
            },
            .associated_type_ref => |atr| {
                // Format as TypeVar.AssocName for mangling (shouldn't normally reach here)
                try buf.appendSlice(self.allocator, atr.type_var.name);
                try buf.append(self.allocator, '_');
                try buf.appendSlice(self.allocator, atr.assoc_name);
            },
            .context_error => |ce| {
                try buf.appendSlice(self.allocator, "ctx_err_");
                try self.appendCheckerTypeNameForMangling(buf, ce.inner_type);
            },
            else => try buf.appendSlice(self.allocator, "unknown"),
        }
    }

    // =========================================================================
    // Composite Type Support
    // =========================================================================

    /// Get or create an LLVM struct type for a named struct.
    /// For packed structs (extern struct packed), LLVM will use packed struct layout (no padding).
    /// For regular and extern structs, LLVM uses standard C ABI alignment.
    fn getOrCreateStructType(self: *Emitter, name: []const u8, fields: []const ast.StructField, is_packed: bool) EmitError!llvm.TypeRef {
        // Check cache first
        if (self.struct_types.get(name)) |info| {
            return info.llvm_type;
        }

        // Create array of field types
        var field_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer field_types.deinit(self.allocator);

        var field_indices = try self.allocator.alloc(u32, fields.len);
        errdefer self.allocator.free(field_indices);

        var field_names = try self.allocator.alloc([]const u8, fields.len);
        errdefer self.allocator.free(field_names);

        for (fields, 0..) |field, i| {
            const field_llvm_type = try self.typeExprToLLVM(field.type_);
            field_types.append(self.allocator, field_llvm_type) catch return EmitError.OutOfMemory;
            field_indices[i] = @intCast(i);
            field_names[i] = field.name;
        }

        // Create LLVM struct type
        // - packed=true for extern struct packed (no padding between fields)
        // - packed=false for regular and extern structs (C ABI alignment with padding)
        const struct_type = llvm.Types.struct_(self.ctx, field_types.items, is_packed);

        // Cache the struct type info
        self.struct_types.put(name, .{
            .llvm_type = struct_type,
            .field_indices = field_indices,
            .field_names = field_names,
        }) catch return EmitError.OutOfMemory;

        return struct_type;
    }

    /// Emit a struct literal expression.
    fn emitStructLiteral(self: *Emitter, lit: *ast.StructLiteral) EmitError!llvm.ValueRef {
        // Get the struct type name - could be simple or generic
        const type_expr = lit.type_name orelse return EmitError.InvalidAST;
        const type_name = switch (type_expr) {
            .named => |n| n.name,
            .generic_apply => |g| blk: {
                // For generic types, we need to use the mangled name
                // The type checker has registered monomorphized structs with mangled names
                // We need to reconstruct the mangled name here
                const base_name = switch (g.base) {
                    .named => |n| n.name,
                    else => return EmitError.UnsupportedFeature,
                };
                // Build mangled name: BaseName$Type1$Type2...
                var mangled = std.ArrayListUnmanaged(u8){};
                errdefer mangled.deinit(self.allocator);
                mangled.appendSlice(self.allocator, base_name) catch return EmitError.OutOfMemory;
                for (g.args) |arg| {
                    mangled.append(self.allocator, '$') catch return EmitError.OutOfMemory;
                    self.appendTypeNameForMangling(&mangled, arg) catch return EmitError.OutOfMemory;
                }
                break :blk mangled.toOwnedSlice(self.allocator) catch return EmitError.OutOfMemory;
            },
            else => return EmitError.UnsupportedFeature,
        };

        // Check if we have a registered struct type (from struct declaration)
        if (self.struct_types.get(type_name)) |struct_info| {
            // Use the registered struct type - store fields in correct order
            const struct_type = struct_info.llvm_type;

            // Allocate stack space for the struct
            const type_name_z = self.allocator.dupeZ(u8, type_name) catch return EmitError.OutOfMemory;
            defer self.allocator.free(type_name_z);
            const alloca = self.builder.buildAlloca(struct_type, type_name_z);

            // Store each field value by looking up field name -> index
            for (lit.fields) |field_init| {
                // Find the field index by name
                const field_idx = self.lookupFieldIndex(type_name, field_init.name) orelse
                    return EmitError.InvalidAST;

                // Check if field is a slice type and value is an array literal
                const field_klar_type = self.getFieldType(type_name, field_init.name);
                const is_field_slice = if (field_klar_type) |ft| ft == .slice else false;
                const is_array_literal_value = field_init.value == .array_literal;

                var indices = [_]llvm.ValueRef{
                    llvm.Const.int32(self.ctx, 0),
                    llvm.Const.int32(self.ctx, @intCast(field_idx)),
                };
                const field_ptr = self.builder.buildGEP(struct_type, alloca, &indices, "field.ptr");

                if (is_field_slice and is_array_literal_value) {
                    // Convert array literal to slice for slice-typed field
                    const arr_lit = field_init.value.array_literal;
                    const array_value = try self.emitExpr(field_init.value);
                    const array_type = llvm.typeOf(array_value);

                    // Store the array in an alloca so we can get a pointer to it
                    const array_alloca = self.builder.buildAlloca(array_type, "arr.storage");
                    _ = self.builder.buildStore(array_value, array_alloca);

                    // Convert to slice and store in the field
                    const slice_value = self.convertArrayToSlice(array_alloca, arr_lit.elements.len);
                    _ = self.builder.buildStore(slice_value, field_ptr);
                } else {
                    const value = try self.emitExpr(field_init.value);
                    _ = self.builder.buildStore(value, field_ptr);
                }
            }

            // Load and return the complete struct value
            return self.builder.buildLoad(struct_type, alloca, "struct.val");
        }

        // Fallback: Create a simple struct type based on the field initializers (in order).
        // This is used when no struct declaration is available.
        var field_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer field_types.deinit(self.allocator);

        var field_values = std.ArrayListUnmanaged(llvm.ValueRef){};
        defer field_values.deinit(self.allocator);

        var field_names = std.ArrayListUnmanaged([]const u8){};
        defer field_names.deinit(self.allocator);

        for (lit.fields) |field_init| {
            const value = try self.emitExpr(field_init.value);
            const value_type = llvm.typeOf(value);
            field_types.append(self.allocator, value_type) catch return EmitError.OutOfMemory;
            field_values.append(self.allocator, value) catch return EmitError.OutOfMemory;
            field_names.append(self.allocator, field_init.name) catch return EmitError.OutOfMemory;
        }

        // Create struct type and register it for field access
        const struct_type = llvm.Types.struct_(self.ctx, field_types.items, false);

        // Register the struct type info for later field access
        const field_indices = self.allocator.alloc(u32, lit.fields.len) catch return EmitError.OutOfMemory;
        errdefer self.allocator.free(field_indices);
        for (field_indices, 0..) |*idx, i| {
            idx.* = @intCast(i);
        }
        const field_names_owned = self.allocator.alloc([]const u8, lit.fields.len) catch return EmitError.OutOfMemory;
        errdefer self.allocator.free(field_names_owned);
        for (field_names_owned, field_names.items) |*dst, src| {
            dst.* = src;
        }

        self.struct_types.put(type_name, .{
            .llvm_type = struct_type,
            .field_indices = field_indices,
            .field_names = field_names_owned,
        }) catch return EmitError.OutOfMemory;

        // Allocate stack space for the struct
        const type_name_z = self.allocator.dupeZ(u8, type_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(type_name_z);
        const alloca = self.builder.buildAlloca(struct_type, type_name_z);

        // Store each field value using GEP
        for (field_values.items, 0..) |value, i| {
            var indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, @intCast(i)),
            };
            const field_ptr = self.builder.buildGEP(struct_type, alloca, &indices, "field.ptr");
            _ = self.builder.buildStore(value, field_ptr);
        }

        // Load and return the complete struct value
        return self.builder.buildLoad(struct_type, alloca, "struct.val");
    }

    /// Emit an array literal expression.
    fn emitArrayLiteral(self: *Emitter, arr: *ast.ArrayLiteral) EmitError!llvm.ValueRef {
        if (arr.elements.len == 0) {
            // Empty array - return undefined/zero value
            const arr_type = llvm.Types.array(llvm.Types.int32(self.ctx), 0);
            return llvm.Const.undef(arr_type);
        }

        // Emit all elements
        var element_values = std.ArrayListUnmanaged(llvm.ValueRef){};
        defer element_values.deinit(self.allocator);

        for (arr.elements) |elem| {
            const value = try self.emitExpr(elem);
            element_values.append(self.allocator, value) catch return EmitError.OutOfMemory;
        }

        // Get element type from first element
        const elem_type = llvm.typeOf(element_values.items[0]);
        const arr_type = llvm.Types.array(elem_type, @intCast(arr.elements.len));

        // Allocate stack space for the array
        const alloca = self.builder.buildAlloca(arr_type, "arr.tmp");

        // Store each element using GEP
        for (element_values.items, 0..) |value, i| {
            var indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, @intCast(i)),
            };
            const elem_ptr = self.builder.buildGEP(arr_type, alloca, &indices, "arr.elem.ptr");
            _ = self.builder.buildStore(value, elem_ptr);
        }

        // Load and return the complete array value
        return self.builder.buildLoad(arr_type, alloca, "arr.val");
    }

    /// Emit a tuple literal expression.
    fn emitTupleLiteral(self: *Emitter, tup: *ast.TupleLiteral) EmitError!llvm.ValueRef {
        if (tup.elements.len == 0) {
            // Empty tuple - treated as unit/void
            return llvm.Const.int32(self.ctx, 0);
        }

        // Extract expected element types from expected_type if it's a tuple with matching arity
        const expected_elem_types: ?[]const types.Type = if (self.expected_type) |et| blk: {
            if (et == .tuple and et.tuple.elements.len == tup.elements.len) {
                break :blk et.tuple.elements;
            }
            break :blk null;
        } else null;

        // Emit all elements
        var element_values = std.ArrayListUnmanaged(llvm.ValueRef){};
        defer element_values.deinit(self.allocator);

        var element_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer element_types.deinit(self.allocator);

        const prev_expected = self.expected_type;
        for (tup.elements, 0..) |elem, i| {
            // Set expected_type for this element (for Ok/Err type inference)
            self.expected_type = if (expected_elem_types) |eet| eet[i] else null;
            const value = try self.emitExpr(elem);
            element_values.append(self.allocator, value) catch return EmitError.OutOfMemory;
            element_types.append(self.allocator, llvm.typeOf(value)) catch return EmitError.OutOfMemory;
        }
        self.expected_type = prev_expected;

        // Create tuple type (anonymous struct in LLVM)
        const tuple_type = llvm.Types.struct_(self.ctx, element_types.items, false);

        // Allocate stack space for the tuple
        const alloca = self.builder.buildAlloca(tuple_type, "tup.tmp");

        // Store each element using GEP
        for (element_values.items, 0..) |value, i| {
            var indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, @intCast(i)),
            };
            const elem_ptr = self.builder.buildGEP(tuple_type, alloca, &indices, "tup.elem.ptr");
            _ = self.builder.buildStore(value, elem_ptr);
        }

        // Load and return the complete tuple value
        return self.builder.buildLoad(tuple_type, alloca, "tup.val");
    }

    /// Emit field access expression (e.g., point.x or tuple.0).
    fn emitFieldAccess(self: *Emitter, field: *ast.Field) EmitError!llvm.ValueRef {
        // Check if this is a tuple index (numeric field name like .0, .1)
        const field_index: ?u32 = std.fmt.parseInt(u32, field.field_name, 10) catch null;

        // Special handling for identifier access - we can GEP directly from the alloca
        if (field.object == .identifier) {
            const id = field.object.identifier;
            if (self.named_values.get(id.name)) |local| {
                if (local.is_alloca) {
                    // For reference parameters, load the pointer first, then GEP into it
                    // For regular struct parameters, GEP directly from the alloca
                    const base_ptr = if (local.is_reference)
                        self.builder.buildLoad(local.ty, local.value, "ref.load")
                    else
                        local.value;

                    const gep_type = if (local.is_reference)
                        local.reference_inner_type.?
                    else
                        local.ty;

                    // First try numeric index (for tuples)
                    if (field_index) |idx| {
                        var indices = [_]llvm.ValueRef{
                            llvm.Const.int32(self.ctx, 0),
                            llvm.Const.int32(self.ctx, @intCast(idx)),
                        };
                        const field_ptr = self.builder.buildGEP(gep_type, base_ptr, &indices, "field.ptr");
                        // Get the field type from struct type
                        const field_type = llvm.c.LLVMStructGetTypeAtIndex(gep_type, idx);
                        return self.builder.buildLoad(field_type, field_ptr, "field.val");
                    }

                    // Named field access - look up field index from struct type name
                    if (local.struct_type_name) |struct_name| {
                        if (self.lookupFieldIndex(struct_name, field.field_name)) |idx| {
                            var indices = [_]llvm.ValueRef{
                                llvm.Const.int32(self.ctx, 0),
                                llvm.Const.int32(self.ctx, @intCast(idx)),
                            };
                            const field_ptr = self.builder.buildGEP(gep_type, base_ptr, &indices, "field.ptr");
                            const field_type = self.lookupFieldType(struct_name, field.field_name) orelse
                                llvm.c.LLVMStructGetTypeAtIndex(gep_type, idx);
                            return self.builder.buildLoad(field_type, field_ptr, "field.val");
                        }
                    }

                    return EmitError.UnsupportedFeature;
                }
            }
        }

        // For other cases, emit the object and handle it
        const obj = try self.emitExpr(field.object);
        const obj_type = llvm.typeOf(obj);
        const obj_type_kind = llvm.getTypeKind(obj_type);

        if (obj_type_kind == llvm.c.LLVMStructTypeKind) {
            // Object is a struct value - need to store to temp first for GEP
            const alloca = self.builder.buildAlloca(obj_type, "obj.tmp");
            _ = self.builder.buildStore(obj, alloca);

            if (field_index) |idx| {
                // Tuple access by index
                var indices = [_]llvm.ValueRef{
                    llvm.Const.int32(self.ctx, 0),
                    llvm.Const.int32(self.ctx, @intCast(idx)),
                };
                const field_ptr = self.builder.buildGEP(obj_type, alloca, &indices, "field.ptr");
                // Get the field type - need to extract from struct type
                const field_type = llvm.c.LLVMStructGetTypeAtIndex(obj_type, idx);
                return self.builder.buildLoad(field_type, field_ptr, "field.val");
            } else {
                // Named field access on non-identifier struct
                // Get struct type name from expression to look up field index
                if (self.getStructTypeNameFromExpr(field.object)) |struct_name| {
                    if (self.lookupFieldIndex(struct_name, field.field_name)) |idx| {
                        var indices = [_]llvm.ValueRef{
                            llvm.Const.int32(self.ctx, 0),
                            llvm.Const.int32(self.ctx, @intCast(idx)),
                        };
                        // Use obj_type for consistency (alloca was created with obj_type)
                        const field_ptr = self.builder.buildGEP(obj_type, alloca, &indices, "field.ptr");
                        const field_type = self.lookupFieldType(struct_name, field.field_name) orelse
                            llvm.c.LLVMStructGetTypeAtIndex(obj_type, idx);
                        return self.builder.buildLoad(field_type, field_ptr, "field.val");
                    }
                }
                return EmitError.UnsupportedFeature;
            }
        }

        return EmitError.UnsupportedFeature;
    }

    /// Emit array/slice index access expression (e.g., arr[i]).
    fn emitIndexAccess(self: *Emitter, idx: *ast.Index) EmitError!llvm.ValueRef {
        // Emit the index first (before potentially skipping object emission)
        const index_val = try self.emitExpr(idx.index);

        // Optimization: If the object is an identifier with an alloca, GEP directly
        // from the alloca instead of loading the entire array value. This prevents
        // stack overflow with large arrays in loops (e.g., 30KB Brainfuck tape).
        if (idx.object == .identifier) {
            const arr_id = idx.object.identifier;
            if (self.named_values.get(arr_id.name)) |local| {
                if (local.is_alloca) {
                    const arr_type = local.ty;
                    const arr_type_kind = llvm.getTypeKind(arr_type);

                    if (arr_type_kind == llvm.c.LLVMArrayTypeKind) {
                        // Get array length for bounds checking
                        const array_len = llvm.Types.getArrayLength(arr_type);
                        const len_val = llvm.Const.int64(self.ctx, @intCast(array_len));

                        // Zero-extend or sign-extend index to i64 for comparison
                        const index_type = llvm.typeOf(index_val);
                        const index_bits = llvm.c.LLVMGetIntTypeWidth(index_type);
                        const i64_type = llvm.Types.int64(self.ctx);

                        const index_i64 = if (index_bits < 64)
                            self.builder.buildZExt(index_val, i64_type, "idx.ext")
                        else if (index_bits > 64)
                            self.builder.buildTrunc(index_val, i64_type, "idx.trunc")
                        else
                            index_val;

                        // Bounds check: index < length (unsigned comparison)
                        const in_bounds = self.builder.buildICmp(
                            llvm.c.LLVMIntULT,
                            index_i64,
                            len_val,
                            "bounds.check",
                        );

                        // Create blocks for bounds check
                        const func = self.current_function orelse return EmitError.InvalidAST;
                        const ok_block = llvm.appendBasicBlock(self.ctx, func, "bounds.ok");
                        const fail_block = llvm.appendBasicBlock(self.ctx, func, "bounds.fail");

                        // Branch based on bounds check
                        _ = self.builder.buildCondBr(in_bounds, ok_block, fail_block);

                        // Fail block: trap/unreachable
                        self.builder.positionAtEnd(fail_block);
                        _ = self.builder.buildUnreachable();

                        // Continue in OK block
                        self.builder.positionAtEnd(ok_block);

                        // GEP directly from the alloca (no temp copy needed)
                        var indices = [_]llvm.ValueRef{
                            llvm.Const.int32(self.ctx, 0),
                            index_val,
                        };
                        const elem_ptr = self.builder.buildGEP(arr_type, local.value, &indices, "elem.ptr");

                        // Get element type and load
                        const elem_type = llvm.c.LLVMGetElementType(arr_type);
                        return self.builder.buildLoad(elem_type, elem_ptr, "elem.val");
                    } else if (arr_type_kind == llvm.c.LLVMStructTypeKind and local.is_array and local.array_size == null) {
                        // Slice indexing: slices are stored as { ptr: *T, len: i64 }
                        const i64_type = llvm.Types.int64(self.ctx);
                        const slice_type = self.getSliceStructType();

                        // Get element type from stored type info, or default to i32 (char)
                        const element_llvm_type = if (local.array_element_type) |elem_type|
                            self.typeToLLVM(elem_type)
                        else
                            llvm.Types.int32(self.ctx);

                        // Load length from slice struct (field 1)
                        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, local.value, 1, "slice.len_ptr");
                        const slice_len = self.builder.buildLoad(i64_type, len_ptr, "slice.len");

                        // Zero-extend or sign-extend index to i64 for comparison
                        const index_type = llvm.typeOf(index_val);
                        const index_bits = llvm.c.LLVMGetIntTypeWidth(index_type);

                        const index_i64 = if (index_bits < 64)
                            self.builder.buildZExt(index_val, i64_type, "idx.ext")
                        else if (index_bits > 64)
                            self.builder.buildTrunc(index_val, i64_type, "idx.trunc")
                        else
                            index_val;

                        // Bounds check: index < length (unsigned comparison)
                        const in_bounds = self.builder.buildICmp(
                            llvm.c.LLVMIntULT,
                            index_i64,
                            slice_len,
                            "bounds.check",
                        );

                        // Create blocks for bounds check
                        const func = self.current_function orelse return EmitError.InvalidAST;
                        const ok_block = llvm.appendBasicBlock(self.ctx, func, "bounds.ok");
                        const fail_block = llvm.appendBasicBlock(self.ctx, func, "bounds.fail");

                        // Branch based on bounds check
                        _ = self.builder.buildCondBr(in_bounds, ok_block, fail_block);

                        // Fail block: trap/unreachable
                        self.builder.positionAtEnd(fail_block);
                        _ = self.builder.buildUnreachable();

                        // Continue in OK block
                        self.builder.positionAtEnd(ok_block);

                        // Load data pointer from slice struct (field 0)
                        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, local.value, 0, "slice.ptr_ptr");
                        const data_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), ptr_ptr, "slice.data_ptr");

                        // GEP into data pointer with the index
                        var gep_indices = [_]llvm.ValueRef{index_i64};
                        const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, element_llvm_type, data_ptr, &gep_indices, 1, "slice.elem.ptr");

                        // Load and return the element
                        return self.builder.buildLoad(element_llvm_type, elem_ptr, "slice.elem.val");
                    }
                }
            }
        }

        // Fallback: emit the object expression (may produce a loaded array value)
        const obj = try self.emitExpr(idx.object);
        const obj_type = llvm.typeOf(obj);

        const obj_type_kind = llvm.getTypeKind(obj_type);

        if (obj_type_kind == llvm.c.LLVMArrayTypeKind) {
            // Array access with bounds checking (for non-identifier expressions)

            // Get array length
            const array_len = llvm.Types.getArrayLength(obj_type);
            const len_val = llvm.Const.int64(self.ctx, @intCast(array_len));

            // Zero-extend or sign-extend index to i64 for comparison
            const index_type = llvm.typeOf(index_val);
            const index_bits = llvm.c.LLVMGetIntTypeWidth(index_type);
            const i64_type = llvm.Types.int64(self.ctx);

            const index_i64 = if (index_bits < 64)
                self.builder.buildZExt(index_val, i64_type, "idx.ext")
            else if (index_bits > 64)
                self.builder.buildTrunc(index_val, i64_type, "idx.trunc")
            else
                index_val;

            // Bounds check: index < length (unsigned comparison)
            const in_bounds = self.builder.buildICmp(
                llvm.c.LLVMIntULT,
                index_i64,
                len_val,
                "bounds.check",
            );

            // Create blocks for bounds check
            const func = self.current_function orelse return EmitError.InvalidAST;
            const ok_block = llvm.appendBasicBlock(self.ctx, func, "bounds.ok");
            const fail_block = llvm.appendBasicBlock(self.ctx, func, "bounds.fail");

            // Branch based on bounds check
            _ = self.builder.buildCondBr(in_bounds, ok_block, fail_block);

            // Fail block: trap/unreachable
            self.builder.positionAtEnd(fail_block);
            _ = self.builder.buildUnreachable();

            // Continue in OK block
            self.builder.positionAtEnd(ok_block);

            // Array access - store to temp for GEP (needed for computed array expressions)
            const alloca = self.builder.buildAlloca(obj_type, "arr.tmp");
            _ = self.builder.buildStore(obj, alloca);

            // GEP with the index
            var indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                index_val,
            };
            const elem_ptr = self.builder.buildGEP(obj_type, alloca, &indices, "elem.ptr");

            // Get element type and load
            const elem_type = llvm.c.LLVMGetElementType(obj_type);
            return self.builder.buildLoad(elem_type, elem_ptr, "elem.val");
        } else if (obj_type_kind == llvm.c.LLVMPointerTypeKind) {
            // Pointer/slice access
            // For slices, we'd need to bounds check and extract the data pointer
            // For now, treat as raw pointer indexing
            return EmitError.UnsupportedFeature;
        }

        return EmitError.UnsupportedFeature;
    }

    // =========================================================================
    // Optional and Result Type Support
    // =========================================================================

    /// Emit a postfix operator expression (? for safe unwrap, ! for force unwrap).
    /// Works for both Optional[T] and Result[T, E] types:
    /// - Optional layout: { i1 tag, T value } where tag: 0=None, 1=Some
    /// - Result layout: { i1 tag, T ok_value, E err_value } where tag: 0=Err, 1=Ok
    /// The ! operator traps on None/Err and returns the value/ok_value at index 1.
    fn emitPostfix(self: *Emitter, post: *ast.Postfix) EmitError!llvm.ValueRef {
        // Emit the operand (should be an optional or result type)
        const operand = try self.emitExpr(post.operand);
        const operand_type = llvm.typeOf(operand);

        // Optional/Result type layout is { i1, T, ... } where i1 is the tag (0=None/Err, 1=Some/Ok)
        // First, check if operand is a struct type (our optional/result representation)
        const type_kind = llvm.getTypeKind(operand_type);
        if (type_kind != llvm.c.LLVMStructTypeKind) {
            return EmitError.UnsupportedFeature;
        }

        // Store the optional to a temp for GEP access
        const opt_alloca = self.builder.buildAlloca(operand_type, "opt.tmp");
        _ = self.builder.buildStore(operand, opt_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(operand_type, opt_alloca, &tag_indices, "opt.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "opt.tag");

        // Get the value (index 1)
        var val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const val_ptr = self.builder.buildGEP(operand_type, opt_alloca, &val_indices, "opt.val.ptr");
        const val_type = llvm.c.LLVMStructGetTypeAtIndex(operand_type, 1);

        switch (post.op) {
            .force_unwrap => {
                // ! operator: trap if None, return value if Some
                const func = self.current_function orelse return EmitError.InvalidAST;

                const ok_block = llvm.appendBasicBlock(self.ctx, func, "unwrap.ok");
                const fail_block = llvm.appendBasicBlock(self.ctx, func, "unwrap.fail");

                // Branch based on tag
                _ = self.builder.buildCondBr(tag, ok_block, fail_block);

                // Fail block: unreachable/trap
                self.builder.positionAtEnd(fail_block);
                _ = self.builder.buildUnreachable();

                // OK block: load and return value
                self.builder.positionAtEnd(ok_block);
                return self.builder.buildLoad(val_type, val_ptr, "unwrap.val");
            },
            .unwrap => {
                // ? operator: early return on None/Err
                const func = self.current_function orelse return EmitError.InvalidAST;
                const rt_info = self.current_return_type orelse return EmitError.InvalidAST;

                const ok_block = llvm.appendBasicBlock(self.ctx, func, "unwrap.ok");
                const propagate_block = llvm.appendBasicBlock(self.ctx, func, "unwrap.propagate");

                // Branch based on tag
                _ = self.builder.buildCondBr(tag, ok_block, propagate_block);

                // Propagate block: construct error return and return early
                self.builder.positionAtEnd(propagate_block);

                // Determine if operand is Optional (2 fields) or Result (3 fields)
                const num_fields = llvm.c.LLVMCountStructElementTypes(operand_type);

                if (rt_info.is_optional) {
                    // Return None: { i1 = 0, T = undef }
                    const none_val = self.emitNone(rt_info.llvm_type);
                    _ = self.builder.buildRet(none_val);
                } else if (rt_info.is_result) {
                    // Return Err with same error value
                    // For Result operand: extract error value from index 2
                    // For Optional operand: this should have been caught by type checker
                    if (num_fields == 3) {
                        // Operand is Result[T, E] - extract error from index 2
                        var err_indices = [_]llvm.ValueRef{
                            llvm.Const.int32(self.ctx, 0),
                            llvm.Const.int32(self.ctx, 2),
                        };
                        const err_ptr = self.builder.buildGEP(operand_type, opt_alloca, &err_indices, "propagate.err.ptr");
                        const err_type_llvm = llvm.c.LLVMStructGetTypeAtIndex(operand_type, 2);
                        var err_val = self.builder.buildLoad(err_type_llvm, err_ptr, "propagate.err.val");

                        // Check if we need From::from conversion for error type
                        if (self.type_checker) |tc| {
                            if (tc.error_conversions.get(post)) |conv| {
                                // Call the From::from method to convert the error
                                const from_method_z = self.allocator.dupeZ(u8, conv.from_method_name) catch "";
                                defer if (from_method_z.len > 0) self.allocator.free(from_method_z);

                                if (self.module.getNamedFunction(from_method_z)) |from_fn| {
                                    const fn_type = llvm.c.LLVMGlobalGetValueType(from_fn);
                                    const args_slice = &[_]llvm.ValueRef{err_val};
                                    err_val = self.builder.buildCall(fn_type, from_fn, args_slice, "from.result");
                                }
                            }
                        }

                        // Build Err result with the extracted (and possibly converted) error
                        const err_result = self.emitErr(err_val, rt_info.ok_type.?, rt_info.err_type.?);
                        _ = self.builder.buildRet(err_result);
                    } else {
                        // Operand is Optional but return is Result - shouldn't happen with proper type checking
                        // Fall back to unreachable
                        _ = self.builder.buildUnreachable();
                    }
                } else {
                    // Return type is neither optional nor result - shouldn't happen with proper type checking
                    _ = self.builder.buildUnreachable();
                }

                // OK block: load and return value
                self.builder.positionAtEnd(ok_block);
                return self.builder.buildLoad(val_type, val_ptr, "unwrap.val");
            },
        }
    }

    /// Emit null coalescing operator (??) - returns left if Some, else right.
    fn emitNullCoalesce(self: *Emitter, bin: *ast.Binary) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Emit the left side (optional value)
        const lhs = try self.emitExpr(bin.left);
        const lhs_type = llvm.typeOf(lhs);

        // Check type is struct (optional representation)
        const type_kind = llvm.getTypeKind(lhs_type);
        if (type_kind != llvm.c.LLVMStructTypeKind) {
            // Not an optional - just return right side as fallback
            return self.emitExpr(bin.right);
        }

        // Store optional to temp for GEP
        const opt_alloca = self.builder.buildAlloca(lhs_type, "coalesce.opt");
        _ = self.builder.buildStore(lhs, opt_alloca);

        // Extract tag
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(lhs_type, opt_alloca, &tag_indices, "coalesce.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "coalesce.tag");

        // Create blocks for Some/None branches
        const lhs_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const some_bb = llvm.appendBasicBlock(self.ctx, func, "coalesce.some");
        const none_bb = llvm.appendBasicBlock(self.ctx, func, "coalesce.none");
        const merge_bb = llvm.appendBasicBlock(self.ctx, func, "coalesce.merge");

        // Branch based on tag (1 = Some, 0 = None)
        _ = self.builder.buildCondBr(tag, some_bb, none_bb);

        // Some block: extract inner value
        self.builder.positionAtEnd(some_bb);
        var val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const val_ptr = self.builder.buildGEP(lhs_type, opt_alloca, &val_indices, "coalesce.val.ptr");
        const val_type = llvm.c.LLVMStructGetTypeAtIndex(lhs_type, 1);
        const some_val = self.builder.buildLoad(val_type, val_ptr, "coalesce.some.val");
        const some_end_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        _ = self.builder.buildBr(merge_bb);

        // None block: evaluate right side
        self.builder.positionAtEnd(none_bb);
        const none_val = try self.emitExpr(bin.right);
        const none_end_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        _ = self.builder.buildBr(merge_bb);

        // Merge block: phi node to select result
        self.builder.positionAtEnd(merge_bb);
        const phi = self.builder.buildPhi(val_type, "coalesce.result");
        var incoming_vals = [_]llvm.ValueRef{ some_val, none_val };
        var incoming_blocks = [_]llvm.BasicBlockRef{ some_end_bb, none_end_bb };
        llvm.addIncoming(phi, &incoming_vals, &incoming_blocks);

        _ = lhs_bb; // Suppress unused variable warning

        return phi;
    }

    /// Create an optional Some value wrapping the given value.
    fn emitSome(self: *Emitter, value: llvm.ValueRef, inner_type: llvm.TypeRef) llvm.ValueRef {
        // Optional type is { i1, T }
        var opt_fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag
            inner_type, // value
        };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Allocate and populate
        const opt_alloca = self.builder.buildAlloca(opt_type, "some.tmp");

        // Set tag to 1 (Some)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &tag_indices, "some.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

        // Set value
        var val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const val_ptr = self.builder.buildGEP(opt_type, opt_alloca, &val_indices, "some.val.ptr");
        _ = self.builder.buildStore(value, val_ptr);

        // Load and return
        return self.builder.buildLoad(opt_type, opt_alloca, "some.val");
    }

    /// Create an optional None value of the given optional type.
    fn emitNone(self: *Emitter, opt_type: llvm.TypeRef) llvm.ValueRef {
        // Allocate and set tag to 0 (None)
        const opt_alloca = self.builder.buildAlloca(opt_type, "none.tmp");

        // Set tag to 0 (None)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &tag_indices, "none.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr);

        // Load and return (value field is undefined/uninitialized)
        return self.builder.buildLoad(opt_type, opt_alloca, "none.val");
    }

    /// Create a Result Ok value: Result[T, E] = { tag: 1, ok_value: value, err_value: undef }
    fn emitOk(self: *Emitter, value: llvm.ValueRef, ok_type: llvm.TypeRef, err_type: llvm.TypeRef) llvm.ValueRef {
        // Result type is { i1, T, E }
        var result_fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag
            ok_type, // ok_value
            err_type, // err_value
        };
        const result_type = llvm.Types.struct_(self.ctx, &result_fields, false);

        // Allocate and populate
        const result_alloca = self.builder.buildAlloca(result_type, "ok.tmp");

        // Set tag to 1 (Ok)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(result_type, result_alloca, &tag_indices, "ok.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

        // Set ok_value
        var val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const val_ptr = self.builder.buildGEP(result_type, result_alloca, &val_indices, "ok.val.ptr");
        _ = self.builder.buildStore(value, val_ptr);

        // Load and return (err_value field is undefined/uninitialized)
        return self.builder.buildLoad(result_type, result_alloca, "ok.result");
    }

    /// Create a Result Err value: Result[T, E] = { tag: 0, ok_value: undef, err_value: error }
    fn emitErr(self: *Emitter, error_val: llvm.ValueRef, ok_type: llvm.TypeRef, err_type: llvm.TypeRef) llvm.ValueRef {
        // Result type is { i1, T, E }
        var result_fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag
            ok_type, // ok_value
            err_type, // err_value
        };
        const result_type = llvm.Types.struct_(self.ctx, &result_fields, false);

        // Allocate and populate
        const result_alloca = self.builder.buildAlloca(result_type, "err.tmp");

        // Set tag to 0 (Err)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(result_type, result_alloca, &tag_indices, "err.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr);

        // Set err_value (index 2)
        var err_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 2),
        };
        const err_ptr = self.builder.buildGEP(result_type, result_alloca, &err_indices, "err.err.ptr");
        _ = self.builder.buildStore(error_val, err_ptr);

        // Load and return (ok_value field is undefined/uninitialized)
        return self.builder.buildLoad(result_type, result_alloca, "err.result");
    }

    /// Get the Result type from ok_type and err_type.
    fn getResultType(self: *Emitter, ok_type: llvm.TypeRef, err_type: llvm.TypeRef) llvm.TypeRef {
        var result_fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag
            ok_type, // ok_value
            err_type, // err_value
        };
        return llvm.Types.struct_(self.ctx, &result_fields, false);
    }

    /// Get the Optional type from inner_type: { i1 tag, T value }
    fn getOptionalType(self: *Emitter, inner_type: llvm.TypeRef) llvm.TypeRef {
        var opt_fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag (0 = none, 1 = some)
            inner_type, // value
        };
        return llvm.Types.struct_(self.ctx, &opt_fields, false);
    }

    /// Emit an enum literal: EnumType::VariantName(payload)
    /// Also handles struct static method calls: StructType::method(args)
    /// Generates code to construct a tagged union value or call a static method.
    /// For extern enums, returns the integer constant value directly.
    fn emitEnumLiteral(self: *Emitter, lit: *ast.EnumLiteral) EmitError!llvm.ValueRef {
        // Get the base type name
        const base_name = switch (lit.enum_type) {
            .named => |n| n.name,
            .generic_apply => |g| switch (g.base) {
                .named => |n| n.name,
                else => return EmitError.UnsupportedFeature,
            },
            else => return EmitError.UnsupportedFeature,
        };

        // Check if this is a struct static method call
        if (self.type_checker) |tc| {
            if (tc.lookupStructMethod(base_name, lit.variant_name)) |struct_method| {
                // This is a struct static method call, not an enum literal
                if (!struct_method.has_self) {
                    return self.emitStructStaticMethodCall(lit, base_name, struct_method);
                }
            }
        }

        // Get the mangled enum type name
        const mangled_name = try self.getMangledEnumName(lit.enum_type);

        // Look up the registered enum type
        const enum_info = self.struct_types.get(mangled_name) orelse {
            // Enum type not registered - this might be a non-generic enum
            // Try base name lookup
            if (self.struct_types.get(base_name)) |info| {
                return self.emitEnumLiteralWithInfo(lit, info, base_name);
            }
            return EmitError.UnsupportedFeature;
        };

        return self.emitEnumLiteralWithInfo(lit, enum_info, mangled_name);
    }

    /// Emit a static method call on a struct: StructType::method(args)
    fn emitStructStaticMethodCall(
        self: *Emitter,
        lit: *ast.EnumLiteral,
        struct_name: []const u8,
        _: TypeChecker.StructMethod, // struct_method - unused but kept for potential future use
    ) EmitError!llvm.ValueRef {
        // Build the function name: StructName_methodName
        var fn_name_buf = std.ArrayListUnmanaged(u8){};
        defer fn_name_buf.deinit(self.allocator);
        fn_name_buf.appendSlice(self.allocator, struct_name) catch return EmitError.OutOfMemory;
        fn_name_buf.append(self.allocator, '_') catch return EmitError.OutOfMemory;
        fn_name_buf.appendSlice(self.allocator, lit.variant_name) catch return EmitError.OutOfMemory;

        const fn_name = self.allocator.dupeZ(u8, fn_name_buf.items) catch return EmitError.OutOfMemory;
        defer self.allocator.free(fn_name);

        // Get the function from the module
        const callee = self.module.getNamedFunction(fn_name) orelse {
            return EmitError.InvalidAST;
        };

        // Build arguments from the payload
        var args = std.ArrayListUnmanaged(llvm.ValueRef){};
        defer args.deinit(self.allocator);

        for (lit.payload) |arg| {
            const arg_val = try self.emitExpr(arg);
            args.append(self.allocator, arg_val) catch return EmitError.OutOfMemory;
        }

        // Call the method
        const fn_type = llvm.c.LLVMGlobalGetValueType(callee);

        // Check if return type is void
        const ret_type = llvm.c.LLVMGetReturnType(fn_type);
        const is_void = llvm.c.LLVMGetTypeKind(ret_type) == llvm.c.LLVMVoidTypeKind;
        const call_name: [:0]const u8 = if (is_void) "" else "static.result";

        return self.builder.buildCall(
            fn_type,
            callee,
            args.items,
            call_name,
        );
    }

    /// Emit an extern enum literal as an integer constant.
    /// Returns the variant's explicit value as the repr type.
    fn emitExternEnumLiteral(self: *Emitter, enum_type: *types.EnumType, variant_name: []const u8) EmitError!llvm.ValueRef {
        // Find the variant and get its value
        for (enum_type.variants) |variant| {
            if (std.mem.eql(u8, variant.name, variant_name)) {
                const value = variant.value orelse return EmitError.InvalidAST;
                const repr = enum_type.repr_type orelse return EmitError.UnsupportedFeature;
                const llvm_type = self.typeToLLVM(repr);

                // Check if it's a signed or unsigned type
                const is_signed = switch (repr) {
                    .primitive => |p| switch (p) {
                        .i8_, .i16_, .i32_, .i64_, .isize_ => true,
                        else => false,
                    },
                    else => false,
                };

                // For signed negative values, we need to handle the cast carefully
                if (is_signed and value < 0) {
                    // Cast to u64 with sign extension
                    const unsigned_value: u64 = @bitCast(@as(i64, @intCast(value)));
                    return llvm.Const.int(llvm_type, unsigned_value, true);
                } else {
                    return llvm.Const.int(llvm_type, @intCast(value), is_signed);
                }
            }
        }
        return EmitError.InvalidAST;
    }

    /// Helper to emit enum literal with resolved type info
    fn emitEnumLiteralWithInfo(self: *Emitter, lit: *ast.EnumLiteral, enum_info: StructTypeInfo, enum_name: []const u8) EmitError!llvm.ValueRef {
        // Find the variant index
        var variant_index: ?u32 = null;
        var variant_payload: ?types.VariantPayload = null;
        var found_enum_type: ?*types.EnumType = null;

        // We need to look up the enum definition to find variant info
        // For now, try to find it through the type checker's monomorphized enums
        if (self.type_checker) |tc| {
            const monos = tc.getMonomorphizedEnums();
            for (monos) |mono| {
                if (std.mem.eql(u8, mono.mangled_name, enum_name)) {
                    for (mono.concrete_type.variants, 0..) |v, i| {
                        if (std.mem.eql(u8, v.name, lit.variant_name)) {
                            variant_index = @intCast(i);
                            variant_payload = v.payload;
                            found_enum_type = mono.concrete_type;
                            break;
                        }
                    }
                    break;
                }
            }
        }

        // Also check non-monomorphized enums (non-generic enums)
        if (variant_index == null) {
            if (self.type_checker) |tc| {
                const enum_types = tc.getEnumTypes();
                for (enum_types) |et| {
                    if (std.mem.eql(u8, et.name, enum_name)) {
                        // Check if this is an extern enum
                        if (et.is_extern) {
                            return self.emitExternEnumLiteral(et, lit.variant_name);
                        }
                        for (et.variants, 0..) |v, i| {
                            if (std.mem.eql(u8, v.name, lit.variant_name)) {
                                variant_index = @intCast(i);
                                variant_payload = v.payload;
                                found_enum_type = et;
                                break;
                            }
                        }
                        break;
                    }
                }
            }
        }

        // Check if the found enum is extern (from monomorphized enums)
        if (found_enum_type) |et| {
            if (et.is_extern) {
                return self.emitExternEnumLiteral(et, lit.variant_name);
            }
        }

        const idx = variant_index orelse return EmitError.InvalidAST;
        const enum_type = enum_info.llvm_type;

        // Allocate the enum value
        const enum_alloca = self.builder.buildAlloca(enum_type, "enum.tmp");

        // Determine tag type (i8 for small enums, i16 for larger)
        const tag_type = llvm.Types.int8(self.ctx); // Assume small enums for now

        // Set the tag field (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(enum_type, enum_alloca, &tag_indices, "enum.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int(tag_type, idx, false), tag_ptr);

        // Set the payload if present
        if (lit.payload.len > 0 and variant_payload != null) {
            // Get pointer to payload field (index 1) - stored as byte array
            var payload_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 1),
                llvm.Const.int32(self.ctx, 0), // Start of the byte array
            };
            const payload_ptr = self.builder.buildGEP(enum_type, enum_alloca, &payload_indices, "enum.payload.ptr");

            switch (variant_payload.?) {
                .tuple => |tuple_types| {
                    // For tuple payloads, store each element at its offset
                    var offset: usize = 0;
                    for (lit.payload, tuple_types) |payload_expr, payload_type| {
                        const value = try self.emitExpr(payload_expr);

                        // Get pointer at current offset in the byte array
                        // In opaque pointer mode, we can store directly
                        var elem_indices = [_]llvm.ValueRef{
                            llvm.Const.int32(self.ctx, @intCast(offset)),
                        };
                        const elem_ptr = self.builder.buildGEP(
                            llvm.Types.int8(self.ctx),
                            payload_ptr,
                            &elem_indices,
                            "enum.payload.elem",
                        );
                        // Store the value - opaque pointers don't need bitcast
                        _ = self.builder.buildStore(value, elem_ptr);

                        offset += self.getTypeSize(payload_type);
                    }
                },
                .struct_ => |fields| {
                    // For struct payloads, store fields by offset
                    var offset: usize = 0;
                    for (lit.payload, fields) |payload_expr, field| {
                        const value = try self.emitExpr(payload_expr);

                        var elem_indices = [_]llvm.ValueRef{
                            llvm.Const.int32(self.ctx, @intCast(offset)),
                        };
                        const elem_ptr = self.builder.buildGEP(
                            llvm.Types.int8(self.ctx),
                            payload_ptr,
                            &elem_indices,
                            "enum.payload.field",
                        );
                        _ = self.builder.buildStore(value, elem_ptr);

                        offset += self.getTypeSize(field.type_);
                    }
                },
            }
        }

        // Load and return the constructed enum value
        return self.builder.buildLoad(enum_type, enum_alloca, "enum.result");
    }

    /// Get the mangled name for an enum type expression
    fn getMangledEnumName(self: *Emitter, type_expr: ast.TypeExpr) EmitError![]const u8 {
        return switch (type_expr) {
            .named => |n| n.name,
            .generic_apply => |g| blk: {
                const base_name = switch (g.base) {
                    .named => |n| n.name,
                    else => return EmitError.UnsupportedFeature,
                };

                // Build mangled name: EnumName$Arg1$Arg2
                var result = std.ArrayListUnmanaged(u8){};
                errdefer result.deinit(self.allocator);

                result.appendSlice(self.allocator, base_name) catch return EmitError.OutOfMemory;

                for (g.args) |arg| {
                    result.append(self.allocator, '$') catch return EmitError.OutOfMemory;
                    const arg_name = try self.getTypeName(arg);
                    result.appendSlice(self.allocator, arg_name) catch return EmitError.OutOfMemory;
                }

                const mangled_name = result.toOwnedSlice(self.allocator) catch return EmitError.OutOfMemory;
                // Track allocation for cleanup in deinit
                self.mangled_enum_names.append(self.allocator, mangled_name) catch return EmitError.OutOfMemory;
                break :blk mangled_name;
            },
            else => return EmitError.UnsupportedFeature,
        };
    }

    /// Get a string name for a type expression
    fn getTypeName(self: *Emitter, type_expr: ast.TypeExpr) EmitError![]const u8 {
        return switch (type_expr) {
            .named => |n| n.name,
            .generic_apply => try self.getMangledEnumName(type_expr),
            else => "unknown", // For primitive types referenced in generic args
        };
    }

    /// Emit a method call expression.
    /// Handles special methods like Rc.new(), Cell.new(), Ok(), Err(), .clone(), .downgrade(), etc.
    fn emitMethodCall(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        // Check for static constructors: Rc.new(value), Cell.new(value), Ok(value), Err(error)
        if (method.object == .identifier) {
            const obj_name = method.object.identifier.name;

            if (std.mem.eql(u8, obj_name, "Rc") and std.mem.eql(u8, method.method_name, "new")) {
                return self.emitRcNew(method);
            }

            if (std.mem.eql(u8, obj_name, "Arc") and std.mem.eql(u8, method.method_name, "new")) {
                return self.emitArcNew(method);
            }

            if (std.mem.eql(u8, obj_name, "Cell") and std.mem.eql(u8, method.method_name, "new")) {
                return self.emitCellNew(method);
            }

            // Result type constructors: Ok(value), Err(error)
            // These are parsed as method calls like Ok.new(value) style, but we handle them specially
            if (std.mem.eql(u8, obj_name, "Result")) {
                if (std.mem.eql(u8, method.method_name, "ok") or std.mem.eql(u8, method.method_name, "Ok")) {
                    return self.emitResultOk(method);
                }
                if (std.mem.eql(u8, method.method_name, "err") or std.mem.eql(u8, method.method_name, "Err")) {
                    return self.emitResultErr(method);
                }
            }

            // Default trait: TypeName.default() -> default value for the type
            // Primitives have builtin Default implementations
            if (std.mem.eql(u8, method.method_name, "default")) {
                return self.emitDefaultMethod(obj_name);
            }

            // List.new[T]() - creates an empty list
            if (std.mem.eql(u8, obj_name, "List") and std.mem.eql(u8, method.method_name, "new")) {
                return self.emitListNew(method);
            }

            // List.with_capacity[T](n) - creates a list with pre-allocated capacity
            if (std.mem.eql(u8, obj_name, "List") and std.mem.eql(u8, method.method_name, "with_capacity")) {
                return self.emitListWithCapacity(method);
            }

            // Map.new[K,V]() - creates an empty map
            if (std.mem.eql(u8, obj_name, "Map") and std.mem.eql(u8, method.method_name, "new")) {
                return self.emitMapNew(method);
            }

            // Map.with_capacity[K,V](n) - creates a map with pre-allocated capacity
            if (std.mem.eql(u8, obj_name, "Map") and std.mem.eql(u8, method.method_name, "with_capacity")) {
                return self.emitMapWithCapacity(method);
            }

            // Set.new[T]() - creates an empty set
            if (std.mem.eql(u8, obj_name, "Set") and std.mem.eql(u8, method.method_name, "new")) {
                return self.emitSetNew(method);
            }

            // Set.with_capacity[T](n) - creates a set with pre-allocated capacity
            if (std.mem.eql(u8, obj_name, "Set") and std.mem.eql(u8, method.method_name, "with_capacity")) {
                return self.emitSetWithCapacity(method);
            }

            // String.new() - creates an empty string
            if (std.mem.eql(u8, obj_name, "String") and std.mem.eql(u8, method.method_name, "new")) {
                return self.emitStringNew();
            }

            // String.from(s) - creates a string from a literal
            if (std.mem.eql(u8, obj_name, "String") and std.mem.eql(u8, method.method_name, "from")) {
                return self.emitStringFrom(method);
            }

            // String.with_capacity(n) - creates a string with pre-allocated capacity
            if (std.mem.eql(u8, obj_name, "String") and std.mem.eql(u8, method.method_name, "with_capacity")) {
                return self.emitStringWithCapacity(method);
            }

            // File.open(path, mode) -> Result[File, IoError]
            if (std.mem.eql(u8, obj_name, "File") and std.mem.eql(u8, method.method_name, "open")) {
                return self.emitFileOpen(method);
            }

            // File.read_to_string(path) -> Result[String, IoError]
            if (std.mem.eql(u8, obj_name, "File") and std.mem.eql(u8, method.method_name, "read_to_string")) {
                return self.emitFileReadToString(method);
            }

            // File.read_all(path) -> Result[List[u8], IoError]
            if (std.mem.eql(u8, obj_name, "File") and std.mem.eql(u8, method.method_name, "read_all")) {
                return self.emitFileReadAll(method);
            }

            // BufReader.new[R](reader: R) -> BufReader[R]
            if (std.mem.eql(u8, obj_name, "BufReader") and std.mem.eql(u8, method.method_name, "new")) {
                return self.emitBufReaderNew(method);
            }

            // BufWriter.new[W](writer: W) -> BufWriter[W]
            if (std.mem.eql(u8, obj_name, "BufWriter") and std.mem.eql(u8, method.method_name, "new")) {
                return self.emitBufWriterNew(method);
            }

            // CStr.from_ptr(ptr: CPtr[i8]) -> CStr
            // Just returns the pointer unchanged (CStr is represented as a pointer)
            if (std.mem.eql(u8, obj_name, "CStr") and std.mem.eql(u8, method.method_name, "from_ptr")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                return try self.emitExpr(method.args[0]);
            }
        }

        // Emit the object
        const object = try self.emitExpr(method.object);
        const object_type = llvm.typeOf(object);

        // Check for array/slice methods FIRST (before Cell methods which also have .get())
        if (self.isArrayExpr(method.object) or self.isSliceExpr(method.object)) {
            // For arrays/slices, we need a pointer to the array/slice struct, not the loaded value.
            // - For identifiers: get the alloca pointer directly from named_values
            // - For other expressions (field access, method calls, etc.): create a temp alloca
            const array_ptr = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value; // This is the alloca pointer
                }
                // Identifier not found in named_values - store to temp alloca
                const tmp_alloca = self.builder.buildAlloca(object_type, "arr.tmp");
                _ = self.builder.buildStore(object, tmp_alloca);
                break :blk tmp_alloca;
            } else blk: {
                // Non-identifier object (e.g., field access like `lexer.chars`)
                // Store the slice/array value to a temporary alloca for GEP access
                const tmp_alloca = self.builder.buildAlloca(object_type, "arr.tmp");
                _ = self.builder.buildStore(object, tmp_alloca);
                break :blk tmp_alloca;
            };

            if (std.mem.eql(u8, method.method_name, "len")) {
                return self.emitArrayLen(method.object, array_ptr);
            }
            if (std.mem.eql(u8, method.method_name, "is_empty")) {
                return self.emitArrayIsEmpty(method.object, array_ptr);
            }
            if (std.mem.eql(u8, method.method_name, "first")) {
                return self.emitArrayFirst(method.object, array_ptr);
            }
            if (std.mem.eql(u8, method.method_name, "last")) {
                return self.emitArrayLast(method.object, array_ptr);
            }
            if (std.mem.eql(u8, method.method_name, "get")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const index = try self.emitExpr(method.args[0]);
                return self.emitArrayGet(method.object, array_ptr, index);
            }
            if (std.mem.eql(u8, method.method_name, "contains")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const value = try self.emitExpr(method.args[0]);
                return self.emitArrayContains(method.object, array_ptr, value);
            }
        }

        // Check for List methods (BEFORE Cell methods which also have .get())
        if (self.isListExpr(method.object)) {
            // For List methods, we need the alloca pointer, not the loaded value
            const list_ptr_early = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value; // This is the alloca pointer
                }
                break :blk null;
            } else null;

            if (list_ptr_early) |ptr| {
                if (std.mem.eql(u8, method.method_name, "get")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const index = try self.emitExpr(method.args[0]);
                    return self.emitListGet(ptr, method, index);
                }
                if (std.mem.eql(u8, method.method_name, "set")) {
                    if (method.args.len != 2) return EmitError.InvalidAST;
                    const index = try self.emitExpr(method.args[0]);
                    const value = try self.emitExpr(method.args[1]);
                    return self.emitListSet(ptr, method, index, value);
                }
                if (std.mem.eql(u8, method.method_name, "clone")) {
                    if (method.args.len != 0) return EmitError.InvalidAST;
                    return self.emitListClone(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "drop")) {
                    if (method.args.len != 0) return EmitError.InvalidAST;
                    return self.emitListDrop(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "take")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const count = try self.emitExpr(method.args[0]);
                    return self.emitListTake(ptr, method, count);
                }
                if (std.mem.eql(u8, method.method_name, "skip")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const count = try self.emitExpr(method.args[0]);
                    return self.emitListSkip(ptr, method, count);
                }
                if (std.mem.eql(u8, method.method_name, "filter")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const closure = try self.emitFunctionOrClosure(method.args[0]);
                    return self.emitListFilter(ptr, method, closure);
                }
                if (std.mem.eql(u8, method.method_name, "map")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const closure = try self.emitFunctionOrClosure(method.args[0]);
                    return self.emitListMap(ptr, method, closure);
                }
                if (std.mem.eql(u8, method.method_name, "enumerate")) {
                    if (method.args.len != 0) return EmitError.InvalidAST;
                    return self.emitListEnumerate(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "zip")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    return self.emitListZip(ptr, method);
                }
            }
        }

        // Check for String methods (heap-allocated string)
        if (self.isStringDataExpr(method.object)) {
            // For String methods, we need the alloca pointer, not the loaded value
            // If object is an identifier, get its alloca directly
            // Otherwise, emit the expression and store to a temporary alloca
            const ptr = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value; // This is the alloca pointer
                }
                // Identifier not found in named_values, fall through to emit
                const obj_val = try self.emitExpr(method.object);
                const string_type = self.getStringStructType();
                const tmp_alloca = self.builder.buildAlloca(string_type, "str.tmp");
                _ = self.builder.buildStore(obj_val, tmp_alloca);
                break :blk tmp_alloca;
            } else blk: {
                // Non-identifier object (e.g., method call result like a.concat(b))
                // Emit the expression and store to a temporary alloca
                const obj_val = try self.emitExpr(method.object);
                const string_type = self.getStringStructType();
                const tmp_alloca = self.builder.buildAlloca(string_type, "str.tmp");
                _ = self.builder.buildStore(obj_val, tmp_alloca);
                break :blk tmp_alloca;
            };

            {
                if (std.mem.eql(u8, method.method_name, "len")) {
                    return self.emitStringDataLen(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "is_empty")) {
                    return self.emitStringDataIsEmpty(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "capacity")) {
                    return self.emitStringCapacity(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "push")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const char_val = try self.emitExpr(method.args[0]);
                    return self.emitStringPush(ptr, char_val);
                }
                if (std.mem.eql(u8, method.method_name, "concat")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    // For concat we need the other string's pointer
                    // If argument is an identifier, get its alloca directly
                    // Otherwise, emit the expression and store to a temporary alloca
                    const other_ptr = if (method.args[0] == .identifier) other_blk: {
                        if (self.named_values.get(method.args[0].identifier.name)) |local| {
                            break :other_blk local.value;
                        }
                        // Identifier not found in named_values, fall through to emit
                        const other_val = try self.emitExpr(method.args[0]);
                        const string_type = self.getStringStructType();
                        const other_tmp = self.builder.buildAlloca(string_type, "str.arg.tmp");
                        _ = self.builder.buildStore(other_val, other_tmp);
                        break :other_blk other_tmp;
                    } else other_blk: {
                        const other_val = try self.emitExpr(method.args[0]);
                        const string_type = self.getStringStructType();
                        const other_tmp = self.builder.buildAlloca(string_type, "str.arg.tmp");
                        _ = self.builder.buildStore(other_val, other_tmp);
                        break :other_blk other_tmp;
                    };
                    return self.emitStringConcat(ptr, other_ptr);
                }
                if (std.mem.eql(u8, method.method_name, "append")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const other_str = try self.emitExpr(method.args[0]);
                    const other_ptr = if (method.args[0] == .identifier) other_blk: {
                        if (self.named_values.get(method.args[0].identifier.name)) |local| {
                            break :other_blk local.value;
                        }
                        break :other_blk other_str;
                    } else other_str;
                    return self.emitStringAppend(ptr, other_ptr);
                }
                if (std.mem.eql(u8, method.method_name, "as_str")) {
                    return self.emitStringAsStr(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "clear")) {
                    return self.emitStringClear(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "clone")) {
                    return self.emitStringClone(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "drop")) {
                    return self.emitStringDrop(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "eq")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const other_str = try self.emitExpr(method.args[0]);
                    const other_ptr = if (method.args[0] == .identifier) other_blk: {
                        if (self.named_values.get(method.args[0].identifier.name)) |local| {
                            break :other_blk local.value;
                        }
                        break :other_blk other_str;
                    } else other_str;
                    return self.emitStringEq(ptr, other_ptr);
                }
                if (std.mem.eql(u8, method.method_name, "hash")) {
                    return self.emitStringDataHash(ptr);
                }
                // String.as_cstr() -> CStr (returns pointer to null-terminated data)
                if (std.mem.eql(u8, method.method_name, "as_cstr")) {
                    return self.emitStringDataAsCstr(ptr);
                }
                // String.to_cstr() -> CStrOwned (allocates owned null-terminated copy)
                if (std.mem.eql(u8, method.method_name, "to_cstr")) {
                    return self.emitStringDataToCstrOwned(ptr);
                }
            }
        }

        // Check for CStr methods (FFI: null-terminated C string)
        if (self.isCstrExpr(method.object)) {
            // CStr.to_string() -> String (copies C string to Klar String)
            if (std.mem.eql(u8, method.method_name, "to_string")) {
                return self.emitCstrToString(object);
            }
            // CStr.len() -> usize (returns length without null terminator)
            if (std.mem.eql(u8, method.method_name, "len")) {
                return self.emitCstrLen(object);
            }
        }

        // Check for CStrOwned methods (FFI: owned null-terminated C string)
        if (self.isCstrOwnedExpr(method.object)) {
            // CStrOwned.as_cstr() -> CStr (just returns the same pointer)
            if (std.mem.eql(u8, method.method_name, "as_cstr")) {
                return object;
            }
            // CStrOwned.to_string() -> String (copies to Klar String)
            if (std.mem.eql(u8, method.method_name, "to_string")) {
                return self.emitCstrToString(object);
            }
            // CStrOwned.len() -> usize (returns length without null terminator)
            if (std.mem.eql(u8, method.method_name, "len")) {
                return self.emitCstrLen(object);
            }
        }

        // Check for primitive string.as_cstr() (string literal or string variable)
        // String literals are already null-terminated pointers, so just return the pointer
        if (std.mem.eql(u8, method.method_name, "as_cstr")) {
            // Check for string literal directly
            if (method.object == .literal and method.object.literal.kind == .string) {
                return object; // String literals are already null-terminated pointers
            }
            // Check for identifier that refers to a string variable
            if (method.object == .identifier) {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    if (local.is_string) {
                        return object; // Primitive string variable is already a null-terminated pointer
                    }
                }
            }
            // Fallback: Check via type checker
            if (self.isPrimitiveStringExpr(method.object)) {
                return object; // Primitive string, already null-terminated
            }
        }

        // Check for primitive string.to_cstr() (string literal or string variable)
        // Creates an owned copy of the string data
        if (std.mem.eql(u8, method.method_name, "to_cstr")) {
            // Check for string literal directly
            if (method.object == .literal and method.object.literal.kind == .string) {
                return try self.emitPrimitiveStringToCstrOwned(object, method.object.literal);
            }
            // Check for identifier that refers to a string variable
            if (method.object == .identifier) {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    if (local.is_string) {
                        return try self.emitPrimitiveStringToCstrOwned(object, null);
                    }
                }
            }
            // Fallback: Check via type checker
            if (self.isPrimitiveStringExpr(method.object)) {
                return try self.emitPrimitiveStringToCstrOwned(object, null);
            }
        }

        // Check for user-defined struct methods FIRST before builtin methods
        // This ensures user-defined methods like .get() take precedence over Cell.get()
        if (self.type_checker) |tc| {
            const struct_name = self.getStructNameFromExpr(method.object);
            if (struct_name) |name| {
                if (tc.lookupStructMethod(name, method.method_name)) |struct_method| {
                    return self.emitUserDefinedMethod(method, object, name, struct_method);
                }
            }

            // Check for static method calls where object is a type name (e.g., Counter.new())
            if (method.object == .identifier) {
                const type_name = method.object.identifier.name;
                // Check if this identifier is a struct type (not a variable)
                if (self.struct_types.contains(type_name)) {
                    if (tc.lookupStructMethod(type_name, method.method_name)) |struct_method| {
                        // For static methods, we don't pass 'object' as self
                        // Pass a dummy value since emitUserDefinedMethod handles has_self=false
                        return self.emitUserDefinedMethod(method, object, type_name, struct_method);
                    }
                }
            }
        }

        // Check for Cell methods: .get(), .set(), .replace()
        // Only applies when the object is a pointer type (Cell is heap-allocated)
        // and not a Map, List, or Array type
        const is_cell_type = llvm.getTypeKind(object_type) == llvm.c.LLVMPointerTypeKind and
            !self.isMapExpr(method.object) and
            !self.isListExpr(method.object) and
            !self.isArrayExpr(method.object);

        if (is_cell_type) {
            if (std.mem.eql(u8, method.method_name, "get")) {
                // Cell.get() - load the value from the cell
                return self.emitCellGet(method, object, object_type);
            }

            if (std.mem.eql(u8, method.method_name, "set")) {
                // Cell.set(value) - store a new value in the cell
                return self.emitCellSet(method, object, object_type);
            }

            if (std.mem.eql(u8, method.method_name, "replace")) {
                // Cell.replace(value) - store new value, return old
                return self.emitCellReplace(method, object, object_type);
            }
        }

        // Check for Rc/Arc methods
        if (std.mem.eql(u8, method.method_name, "clone")) {
            // Check if this is an Arc or Rc and dispatch accordingly
            if (self.isArcType(method.object)) {
                return self.emitArcClone(object, object_type);
            } else if (self.isRcType(method.object)) {
                return self.emitRcClone(object, object_type);
            }
            // For non-Rc/Arc types, fall through to Clone trait handler below
        }

        if (std.mem.eql(u8, method.method_name, "downgrade")) {
            // Check if this is an Arc or Rc and dispatch accordingly
            if (self.isArcType(method.object)) {
                return self.emitArcDowngrade(object, object_type);
            } else {
                return self.emitRcDowngrade(object, object_type);
            }
        }

        if (std.mem.eql(u8, method.method_name, "upgrade")) {
            // Check if this is a WeakArc or Weak and dispatch accordingly
            // For now, assume Weak (non-atomic) - WeakArc needs separate tracking
            return self.emitWeakUpgrade(object, object_type);
        }

        // Check for Result/Optional methods: is_ok, is_err, is_some, is_none
        if (std.mem.eql(u8, method.method_name, "is_ok")) {
            // Result.is_ok() - return true if tag == 1
            return self.emitResultIsOk(object, object_type);
        }

        if (std.mem.eql(u8, method.method_name, "is_err")) {
            // Result.is_err() - return true if tag == 0
            return self.emitResultIsErr(object, object_type);
        }

        if (std.mem.eql(u8, method.method_name, "is_some")) {
            // Optional.is_some() - return true if tag == 1
            return self.emitOptionalIsSome(object, object_type);
        }

        if (std.mem.eql(u8, method.method_name, "is_none")) {
            // Optional.is_none() - return true if tag == 0
            return self.emitOptionalIsNone(object, object_type);
        }

        if (std.mem.eql(u8, method.method_name, "unwrap")) {
            // Result.unwrap() or Optional.unwrap() - same as ! operator
            return self.emitResultUnwrap(object, object_type);
        }

        if (std.mem.eql(u8, method.method_name, "unwrap_err")) {
            // Result.unwrap_err() - return error value, trap if Ok
            return self.emitResultUnwrapErr(object, object_type);
        }

        if (std.mem.eql(u8, method.method_name, "unwrap_or")) {
            // Optional.unwrap_or(default) or Result.unwrap_or(default)
            // Returns the inner value if Some/Ok, otherwise returns default
            if (method.args.len != 1) {
                return EmitError.InvalidAST;
            }
            const default_val = try self.emitExpr(method.args[0]);
            return self.emitUnwrapOr(object, object_type, default_val);
        }

        if (std.mem.eql(u8, method.method_name, "expect")) {
            // Optional.expect(msg) or Result.expect(msg)
            // Like unwrap but with a custom message (message ignored for now - traps on None/Err)
            // TODO: Print the message before trapping when panic infrastructure is available
            return self.emitResultUnwrap(object, object_type);
        }

        if (std.mem.eql(u8, method.method_name, "ok")) {
            // Result.ok() -> ?T - converts Result to Optional of Ok value
            // Returns Some(value) if Ok, None if Err
            return self.emitResultOkMethod(object, object_type, method);
        }

        if (std.mem.eql(u8, method.method_name, "err")) {
            // Result.err() -> ?E - converts Result to Optional of Err value
            // Returns Some(error) if Err, None if Ok
            return self.emitResultErrMethod(object, object_type, method);
        }

        // map(f) - applies function f to inner value if Some/Ok
        // Skip for Set and Map types which have their own map methods
        if (std.mem.eql(u8, method.method_name, "map") and !self.isSetExpr(method.object) and !self.isMapExpr(method.object)) {
            if (method.args.len != 1) {
                return EmitError.InvalidAST;
            }
            const func_val = try self.emitExpr(method.args[0]);
            return self.emitMapMethod(object, object_type, func_val, method);
        }

        // and_then(f) - applies function f and flattens result
        if (std.mem.eql(u8, method.method_name, "and_then")) {
            if (method.args.len != 1) {
                return EmitError.InvalidAST;
            }
            const func_val = try self.emitExpr(method.args[0]);
            return self.emitAndThenMethod(object, object_type, func_val, method);
        }

        // map_err(f) - applies function f to error value if Err
        if (std.mem.eql(u8, method.method_name, "map_err")) {
            if (method.args.len != 1) {
                return EmitError.InvalidAST;
            }
            const func_val = try self.emitExpr(method.args[0]);
            return self.emitMapErrMethod(object, object_type, func_val, method);
        }

        // context(msg) - wraps error with context message
        if (std.mem.eql(u8, method.method_name, "context")) {
            if (method.args.len != 1) {
                return EmitError.InvalidAST;
            }
            const msg_val = try self.emitExpr(method.args[0]);
            return self.emitContextMethod(object, object_type, msg_val, method.span);
        }

        // message() - gets context message from ContextError
        // Only match if this looks like a ContextError type (struct with 5 fields, first is pointer)
        if (std.mem.eql(u8, method.method_name, "message")) {
            // Check if object type is a struct (ContextError layout)
            if (llvm.c.LLVMGetTypeKind(object_type) == llvm.c.LLVMStructTypeKind) {
                // ContextError has exactly 5 fields: message, cause, file, line, column
                if (llvm.c.LLVMCountStructElementTypes(object_type) == 5) {
                    const first_field = llvm.c.LLVMStructGetTypeAtIndex(object_type, 0);
                    // First field should be a pointer (message)
                    if (llvm.c.LLVMGetTypeKind(first_field) == llvm.c.LLVMPointerTypeKind) {
                        return self.emitContextErrorMessage(object, object_type);
                    }
                }
            }
        }

        // cause() - gets original error from ContextError
        // Only match if this looks like a ContextError type (struct with 5 fields, first is pointer)
        if (std.mem.eql(u8, method.method_name, "cause")) {
            // Check if object type is a struct (ContextError layout)
            if (llvm.c.LLVMGetTypeKind(object_type) == llvm.c.LLVMStructTypeKind) {
                // ContextError has exactly 5 fields: message, cause, file, line, column
                if (llvm.c.LLVMCountStructElementTypes(object_type) == 5) {
                    const first_field = llvm.c.LLVMStructGetTypeAtIndex(object_type, 0);
                    // First field should be a pointer (message)
                    if (llvm.c.LLVMGetTypeKind(first_field) == llvm.c.LLVMPointerTypeKind) {
                        return self.emitContextErrorCause(object, object_type);
                    }
                }
            }
        }

        // display_chain() - formats the full error chain as a string
        // Only match if this looks like a ContextError type (struct with 5 fields, first is pointer)
        if (std.mem.eql(u8, method.method_name, "display_chain")) {
            // Check if object type is a struct (ContextError layout)
            if (llvm.c.LLVMGetTypeKind(object_type) == llvm.c.LLVMStructTypeKind) {
                // ContextError has exactly 5 fields: message, cause, file, line, column
                if (llvm.c.LLVMCountStructElementTypes(object_type) == 5) {
                    const first_field = llvm.c.LLVMStructGetTypeAtIndex(object_type, 0);
                    // First field should be a pointer (message)
                    if (llvm.c.LLVMGetTypeKind(first_field) == llvm.c.LLVMPointerTypeKind) {
                        return self.emitContextErrorDisplayChain(object, object_type);
                    }
                }
            }
        }

        // Eq trait: eq() method for equality comparison
        if (std.mem.eql(u8, method.method_name, "eq")) {
            return self.emitEqMethod(method, object, object_type);
        }

        // Ordered trait: lt(), le(), gt(), ge() methods for comparison
        if (std.mem.eql(u8, method.method_name, "lt") or
            std.mem.eql(u8, method.method_name, "le") or
            std.mem.eql(u8, method.method_name, "gt") or
            std.mem.eql(u8, method.method_name, "ge"))
        {
            return self.emitOrderedMethod(method, object, object_type);
        }

        // Clone trait: clone() method for explicit cloning
        if (std.mem.eql(u8, method.method_name, "clone")) {
            return self.emitCloneMethod(method, object, object_type);
        }

        // Drop trait: drop() method for explicit destruction
        // Only user-defined struct types can have drop() - primitives are trivially dropped
        if (std.mem.eql(u8, method.method_name, "drop")) {
            return self.emitDropMethod(method, object, object_type);
        }

        // Hash trait: hash() method for computing hash codes
        // All primitives have builtin Hash - structs need explicit impl
        if (std.mem.eql(u8, method.method_name, "hash")) {
            return self.emitHashMethod(method, object, object_type);
        }

        // Check for string methods
        // Strings are represented as pointers in LLVM, so we check the LLVM type
        if (self.isStringExpr(method.object)) {
            if (std.mem.eql(u8, method.method_name, "len")) {
                return self.emitStringLen(object);
            }
            if (std.mem.eql(u8, method.method_name, "is_empty")) {
                return self.emitStringIsEmpty(object);
            }
            if (std.mem.eql(u8, method.method_name, "contains")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const pattern = try self.emitExpr(method.args[0]);
                return self.emitStringContains(object, pattern);
            }
            if (std.mem.eql(u8, method.method_name, "starts_with")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const prefix = try self.emitExpr(method.args[0]);
                return self.emitStringStartsWith(object, prefix);
            }
            if (std.mem.eql(u8, method.method_name, "ends_with")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const suffix = try self.emitExpr(method.args[0]);
                return self.emitStringEndsWith(object, suffix);
            }
            if (std.mem.eql(u8, method.method_name, "trim")) {
                return self.emitStringTrim(object);
            }
            if (std.mem.eql(u8, method.method_name, "to_uppercase")) {
                return self.emitStringToUppercase(object);
            }
            if (std.mem.eql(u8, method.method_name, "to_lowercase")) {
                return self.emitStringToLowercase(object);
            }
            if (std.mem.eql(u8, method.method_name, "bytes")) {
                return self.emitStringBytes(object);
            }
            if (std.mem.eql(u8, method.method_name, "chars")) {
                return self.emitStringChars(object);
            }
            if (std.mem.eql(u8, method.method_name, "slice")) {
                if (method.args.len != 2) return EmitError.InvalidAST;
                const start = try self.emitExpr(method.args[0]);
                const end = try self.emitExpr(method.args[1]);
                return self.emitStringSlice(object, start, end);
            }
        }

        // Check for char methods BEFORE integer methods (char is i32 in LLVM)
        if (self.isCharExpr(method.object)) {
            if (std.mem.eql(u8, method.method_name, "to_string")) {
                return self.emitCharToString(object);
            }
        }

        // Check for integer methods
        if (self.isIntegerExpr(method.object)) {
            if (std.mem.eql(u8, method.method_name, "abs")) {
                return self.emitIntAbs(object);
            }
            if (std.mem.eql(u8, method.method_name, "min")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const other = try self.emitExpr(method.args[0]);
                return self.emitIntMin(object, other);
            }
            if (std.mem.eql(u8, method.method_name, "max")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const other = try self.emitExpr(method.args[0]);
                return self.emitIntMax(object, other);
            }
            if (std.mem.eql(u8, method.method_name, "to_string")) {
                // Detect if it's a 64-bit integer by checking the LLVM type
                const llvm_type = llvm.c.LLVMTypeOf(object);
                const bit_width = llvm.c.LLVMGetIntTypeWidth(llvm_type);
                const is_64bit = bit_width == 64;
                return self.emitIntToString(object, is_64bit);
            }
        }

        // Check for Range methods
        if (self.isRangeExpr(method.object)) {
            // For Range methods, we need the alloca pointer, not the loaded value
            const range_ptr = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value; // This is the alloca pointer
                }
                break :blk null;
            } else null;

            if (std.mem.eql(u8, method.method_name, "next")) {
                if (range_ptr) |ptr| {
                    return self.emitRangeNext(ptr);
                }
            }
            if (std.mem.eql(u8, method.method_name, "reset")) {
                if (range_ptr) |ptr| {
                    return self.emitRangeReset(ptr);
                }
            }
            if (std.mem.eql(u8, method.method_name, "is_empty")) {
                if (range_ptr) |ptr| {
                    return self.emitRangeIsEmpty(ptr);
                }
            }
            if (std.mem.eql(u8, method.method_name, "len")) {
                if (range_ptr) |ptr| {
                    return self.emitRangeLen(ptr);
                }
            }
        }

        // Check for List methods
        if (self.isListExpr(method.object)) {
            // For List methods, we need the alloca pointer, not the loaded value
            const list_ptr = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value; // This is the alloca pointer
                }
                break :blk null;
            } else null;

            if (list_ptr) |ptr| {
                if (std.mem.eql(u8, method.method_name, "len")) {
                    return self.emitListLen(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "is_empty")) {
                    return self.emitListIsEmpty(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "capacity")) {
                    return self.emitListCapacity(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "push")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const value = try self.emitExpr(method.args[0]);
                    return self.emitListPush(ptr, method, value);
                }
                if (std.mem.eql(u8, method.method_name, "pop")) {
                    return self.emitListPop(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "get")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const index = try self.emitExpr(method.args[0]);
                    return self.emitListGet(ptr, method, index);
                }
                if (std.mem.eql(u8, method.method_name, "set")) {
                    if (method.args.len != 2) return EmitError.InvalidAST;
                    const index = try self.emitExpr(method.args[0]);
                    const value = try self.emitExpr(method.args[1]);
                    return self.emitListSet(ptr, method, index, value);
                }
                if (std.mem.eql(u8, method.method_name, "first")) {
                    return self.emitListFirst(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "last")) {
                    return self.emitListLast(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "clear")) {
                    return self.emitListClear(ptr);
                }
            }
        }

        // Check for Map methods
        const is_map = self.isMapExpr(method.object);
        if (is_map) {
            // For Map methods, we need the alloca pointer, not the loaded value
            const map_ptr = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value; // This is the alloca pointer
                }
                break :blk null;
            } else null;

            if (map_ptr) |ptr| {
                if (std.mem.eql(u8, method.method_name, "len")) {
                    return self.emitMapLen(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "is_empty")) {
                    return self.emitMapIsEmpty(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "capacity")) {
                    return self.emitMapCapacity(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "insert")) {
                    if (method.args.len != 2) return EmitError.InvalidAST;
                    const key = try self.emitExpr(method.args[0]);
                    const value = try self.emitExpr(method.args[1]);
                    return self.emitMapInsert(ptr, method, key, value);
                }
                if (std.mem.eql(u8, method.method_name, "get")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const key = try self.emitExpr(method.args[0]);
                    return self.emitMapGet(ptr, method, key);
                }
                if (std.mem.eql(u8, method.method_name, "remove")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const key = try self.emitExpr(method.args[0]);
                    return self.emitMapRemove(ptr, method, key);
                }
                if (std.mem.eql(u8, method.method_name, "contains_key")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const key = try self.emitExpr(method.args[0]);
                    return self.emitMapContainsKey(ptr, method, key);
                }
                if (std.mem.eql(u8, method.method_name, "keys")) {
                    return self.emitMapKeys(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "values")) {
                    return self.emitMapValues(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "clear")) {
                    return self.emitMapClear(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "clone")) {
                    return self.emitMapClone(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "drop")) {
                    return self.emitMapDrop(ptr, method);
                }
                // Map iterator adapters
                if (std.mem.eql(u8, method.method_name, "take")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const count = try self.emitExpr(method.args[0]);
                    return self.emitMapTake(ptr, method, count);
                }
                if (std.mem.eql(u8, method.method_name, "skip")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const count = try self.emitExpr(method.args[0]);
                    return self.emitMapSkip(ptr, method, count);
                }
                if (std.mem.eql(u8, method.method_name, "filter")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const closure = try self.emitFunctionOrClosure(method.args[0]);
                    return self.emitMapFilter(ptr, method, closure);
                }
                if (std.mem.eql(u8, method.method_name, "map_values")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const closure = try self.emitFunctionOrClosure(method.args[0]);
                    return self.emitMapMapValues(ptr, method, closure);
                }
            }
        }

        // Check for Set methods
        if (self.isSetExpr(method.object)) {
            // For Set methods, we need the alloca pointer, not the loaded value
            const set_ptr = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value; // This is the alloca pointer
                }
                break :blk null;
            } else null;

            if (set_ptr) |ptr| {
                if (std.mem.eql(u8, method.method_name, "len")) {
                    return self.emitSetLen(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "is_empty")) {
                    return self.emitSetIsEmpty(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "capacity")) {
                    return self.emitSetCapacity(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "insert")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const element = try self.emitExpr(method.args[0]);
                    return self.emitSetInsert(ptr, method, element);
                }
                if (std.mem.eql(u8, method.method_name, "contains")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const element = try self.emitExpr(method.args[0]);
                    return self.emitSetContains(ptr, method, element);
                }
                if (std.mem.eql(u8, method.method_name, "remove")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const element = try self.emitExpr(method.args[0]);
                    return self.emitSetRemove(ptr, method, element);
                }
                if (std.mem.eql(u8, method.method_name, "clear")) {
                    return self.emitSetClear(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "clone")) {
                    return self.emitSetClone(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "drop")) {
                    return self.emitSetDrop(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "union")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    // Need the pointer to the other Set, not its value
                    const other_ptr = try self.getSetArgPtr(method.args[0]);
                    return self.emitSetUnion(ptr, method, other_ptr);
                }
                if (std.mem.eql(u8, method.method_name, "intersection")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    // Need the pointer to the other Set, not its value
                    const other_ptr = try self.getSetArgPtr(method.args[0]);
                    return self.emitSetIntersection(ptr, method, other_ptr);
                }
                if (std.mem.eql(u8, method.method_name, "difference")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    // Need the pointer to the other Set, not its value
                    const other_ptr = try self.getSetArgPtr(method.args[0]);
                    return self.emitSetDifference(ptr, method, other_ptr);
                }
                // Set iterator adapters
                if (std.mem.eql(u8, method.method_name, "take")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const count = try self.emitExpr(method.args[0]);
                    return self.emitSetTake(ptr, method, count);
                }
                if (std.mem.eql(u8, method.method_name, "skip")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const count = try self.emitExpr(method.args[0]);
                    return self.emitSetSkip(ptr, method, count);
                }
                if (std.mem.eql(u8, method.method_name, "filter")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const closure = try self.emitFunctionOrClosure(method.args[0]);
                    return self.emitSetFilter(ptr, method, closure);
                }
                if (std.mem.eql(u8, method.method_name, "map")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const closure = try self.emitFunctionOrClosure(method.args[0]);
                    return self.emitSetMap(ptr, method, closure);
                }
                if (std.mem.eql(u8, method.method_name, "enumerate")) {
                    return self.emitSetEnumerate(ptr, method);
                }
                if (std.mem.eql(u8, method.method_name, "zip")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const other_ptr = try self.getSetArgPtr(method.args[0]);
                    return self.emitSetZip(ptr, method, other_ptr);
                }
            }
        }

        // Check for File methods
        if (self.isFileExpr(method.object)) {
            // For File methods, we need the alloca pointer to get the FILE* handle
            const file_ptr = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value;
                }
                break :blk null;
            } else null;

            if (file_ptr) |ptr| {
                if (std.mem.eql(u8, method.method_name, "write_string")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const str_val = try self.emitExpr(method.args[0]);
                    return self.emitFileWriteString(ptr, str_val);
                }
                if (std.mem.eql(u8, method.method_name, "write")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const buf_val = try self.emitExpr(method.args[0]);
                    return self.emitFileWrite(ptr, buf_val, method.args[0]);
                }
                if (std.mem.eql(u8, method.method_name, "read")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const buf_val = try self.emitExpr(method.args[0]);
                    return self.emitFileRead(ptr, buf_val, method.args[0]);
                }
                if (std.mem.eql(u8, method.method_name, "close")) {
                    return self.emitFileClose(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "flush")) {
                    return self.emitFileFlush(ptr);
                }
            }
        }

        // Check for Stdout methods
        if (self.isStdoutExpr(method.object)) {
            if (std.mem.eql(u8, method.method_name, "write")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const buf_val = try self.emitExpr(method.args[0]);
                return self.emitStdoutWrite(buf_val, method.args[0]);
            }
            if (std.mem.eql(u8, method.method_name, "write_string")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const str_val = try self.emitExpr(method.args[0]);
                return self.emitStdoutWriteString(str_val);
            }
            if (std.mem.eql(u8, method.method_name, "flush")) {
                return self.emitStdoutFlush();
            }
        }

        // Check for Stderr methods
        if (self.isStderrExpr(method.object)) {
            if (std.mem.eql(u8, method.method_name, "write")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const buf_val = try self.emitExpr(method.args[0]);
                return self.emitStderrWrite(buf_val, method.args[0]);
            }
            if (std.mem.eql(u8, method.method_name, "write_string")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const str_val = try self.emitExpr(method.args[0]);
                return self.emitStderrWriteString(str_val);
            }
            if (std.mem.eql(u8, method.method_name, "flush")) {
                return self.emitStderrFlush();
            }
        }

        // Check for Stdin methods
        if (self.isStdinExpr(method.object)) {
            if (std.mem.eql(u8, method.method_name, "read")) {
                if (method.args.len != 1) return EmitError.InvalidAST;
                const buf_val = try self.emitExpr(method.args[0]);
                return self.emitStdinRead(buf_val, method.args[0]);
            }
        }

        // Check for BufReader methods
        if (self.isBufReaderExpr(method.object)) {
            // Get the alloca pointer for the BufReader
            const br_ptr = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value;
                }
                break :blk null;
            } else null;

            if (br_ptr) |ptr| {
                if (std.mem.eql(u8, method.method_name, "read")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const buf_val = try self.emitExpr(method.args[0]);
                    return self.emitBufReaderRead(ptr, buf_val, method.args[0]);
                }
                if (std.mem.eql(u8, method.method_name, "read_line")) {
                    return self.emitBufReaderReadLine(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "read_to_string")) {
                    return self.emitBufReaderReadToString(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "fill_buf")) {
                    return self.emitBufReaderFillBuf(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "consume")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const n = try self.emitExpr(method.args[0]);
                    return self.emitBufReaderConsume(ptr, n);
                }
                if (std.mem.eql(u8, method.method_name, "into_inner")) {
                    return self.emitBufReaderIntoInner(ptr);
                }
            }
        }

        // Check for BufWriter methods
        if (self.isBufWriterExpr(method.object)) {
            // Get the alloca pointer for the BufWriter
            const bw_ptr = if (method.object == .identifier) blk: {
                if (self.named_values.get(method.object.identifier.name)) |local| {
                    break :blk local.value;
                }
                break :blk null;
            } else null;

            if (bw_ptr) |ptr| {
                if (std.mem.eql(u8, method.method_name, "write")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const buf_val = try self.emitExpr(method.args[0]);
                    return self.emitBufWriterWrite(ptr, buf_val, method.args[0]);
                }
                if (std.mem.eql(u8, method.method_name, "write_string")) {
                    if (method.args.len != 1) return EmitError.InvalidAST;
                    const str_val = try self.emitExpr(method.args[0]);
                    return self.emitBufWriterWriteString(ptr, str_val);
                }
                if (std.mem.eql(u8, method.method_name, "flush")) {
                    return self.emitBufWriterFlush(ptr);
                }
                if (std.mem.eql(u8, method.method_name, "into_inner")) {
                    return self.emitBufWriterIntoInner(ptr);
                }
            }
        }

        // For other methods, fall back to a placeholder for now
        // (User-defined struct methods are checked earlier, before Cell methods)
        // TODO: Implement remaining method types
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Get the struct name from an expression (for method call resolution).
    /// Looks up the struct type name from our cached struct_types map.
    fn getStructNameFromExpr(self: *Emitter, expr: ast.Expr) ?[]const u8 {
        switch (expr) {
            .identifier => |ident| {
                // Look up the variable to get its struct_type_name directly
                if (self.named_values.get(ident.name)) |local| {
                    if (local.struct_type_name) |name| {
                        return name;
                    }
                }
                return null;
            },
            .struct_literal => |lit| {
                // For struct literals, get the name from the type_name
                if (lit.type_name) |type_name| {
                    switch (type_name) {
                        .named => |n| return n.name,
                        .generic_apply => |g| {
                            // For generic types like Pair[i32, i32], we need the mangled name
                            // which would already be in struct_types
                            if (g.base == .named) {
                                return g.base.named.name;
                            }
                            return null;
                        },
                        else => return null,
                    }
                }
                return null;
            },
            .field => |_| {
                // Field access returns a value, harder to track type
                return null;
            },
            else => return null,
        }
    }

    /// Emit a call to a user-defined struct method.
    fn emitUserDefinedMethod(
        self: *Emitter,
        method: *ast.MethodCall,
        object: llvm.ValueRef,
        struct_name: []const u8,
        struct_method: TypeChecker.StructMethod,
    ) EmitError!llvm.ValueRef {
        // Determine the mangled function name
        // For generic structs, the struct_name already contains the monomorphization (e.g., "Pair$i32$i32")
        // The method name becomes "Pair$i32$i32_get_first"
        var fn_name_buf = std.ArrayListUnmanaged(u8){};
        defer fn_name_buf.deinit(self.allocator);
        fn_name_buf.appendSlice(self.allocator, struct_name) catch return EmitError.OutOfMemory;
        fn_name_buf.append(self.allocator, '_') catch return EmitError.OutOfMemory;
        fn_name_buf.appendSlice(self.allocator, method.method_name) catch return EmitError.OutOfMemory;

        const fn_name = self.allocator.dupeZ(u8, fn_name_buf.items) catch return EmitError.OutOfMemory;
        defer self.allocator.free(fn_name);

        // Get the function from the module
        const callee = self.module.getNamedFunction(fn_name) orelse {
            // Function not found - it might not have been emitted yet
            // This is an error in our compilation order
            return EmitError.InvalidAST;
        };

        // Build arguments: self (if needed) + actual arguments
        var args = std.ArrayListUnmanaged(llvm.ValueRef){};
        defer args.deinit(self.allocator);

        // Add 'self' if method has it
        if (struct_method.has_self) {
            // Check if self is a reference parameter (&self or &mut self)
            // If so, we need to pass a pointer instead of the loaded value
            const func_type = struct_method.func_type;
            const self_is_ref = func_type == .function and
                func_type.function.params.len > 0 and
                func_type.function.params[0] == .reference;

            if (self_is_ref) {
                // For reference self, get the alloca pointer for the object
                const self_ptr = switch (method.object) {
                    .identifier => |ident| blk: {
                        if (self.named_values.get(ident.name)) |local| {
                            // If the variable is a reference parameter (ref T or inout T),
                            // the alloca contains a pointer - we need to load it
                            if (local.is_reference) {
                                break :blk self.builder.buildLoad(local.ty, local.value, "ref.load");
                            }
                            break :blk local.value; // This is the alloca pointer
                        }
                        // Fallback: store object to a temp and return pointer
                        const obj_type = llvm.typeOf(object);
                        const alloca = self.builder.buildAlloca(obj_type, "self.tmp");
                        _ = self.builder.buildStore(object, alloca);
                        break :blk alloca;
                    },
                    else => blk: {
                        // For non-identifier objects (field access, etc.), create temp
                        const obj_type = llvm.typeOf(object);
                        const alloca = self.builder.buildAlloca(obj_type, "self.tmp");
                        _ = self.builder.buildStore(object, alloca);
                        break :blk alloca;
                    },
                };
                args.append(self.allocator, self_ptr) catch return EmitError.OutOfMemory;
            } else {
                // For value self, pass the loaded object
                args.append(self.allocator, object) catch return EmitError.OutOfMemory;
            }
        }

        // Add other arguments
        for (method.args) |arg| {
            const arg_val = try self.emitExpr(arg);
            args.append(self.allocator, arg_val) catch return EmitError.OutOfMemory;
        }

        // Call the method
        const fn_type = llvm.c.LLVMGlobalGetValueType(callee);

        // Check if return type is void - LLVM doesn't allow naming void results
        const ret_type = llvm.c.LLVMGetReturnType(fn_type);
        const is_void = llvm.c.LLVMGetTypeKind(ret_type) == llvm.c.LLVMVoidTypeKind;
        const call_name: [:0]const u8 = if (is_void) "" else "method.result";

        return self.builder.buildCall(
            fn_type,
            callee,
            args.items,
            call_name,
        );
    }

    /// Emit Rc.new(value) - allocates an Rc and stores the value.
    fn emitRcNew(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) {
            return EmitError.InvalidAST;
        }

        // Emit the value to be wrapped
        const value = try self.emitExpr(method.args[0]);
        const value_type = llvm.typeOf(value);

        // Declare the runtime function if not already
        const rc_alloc_fn = self.getOrDeclareRcAlloc();

        // Call klar_rc_alloc(value_size, value_align)
        // For now, use sizeof based on type kind
        const value_size: u64 = switch (llvm.getTypeKind(value_type)) {
            llvm.c.LLVMIntegerTypeKind => @as(u64, llvm.c.LLVMGetIntTypeWidth(value_type)) / 8,
            llvm.c.LLVMFloatTypeKind => 4,
            llvm.c.LLVMDoubleTypeKind => 8,
            llvm.c.LLVMPointerTypeKind => 8, // Assume 64-bit pointers
            else => 8, // Default to 8 bytes
        };
        const value_align: u64 = value_size; // Assume natural alignment

        var args = [_]llvm.ValueRef{
            llvm.Const.int64(self.ctx, @intCast(value_size)),
            llvm.Const.int64(self.ctx, @intCast(value_align)),
        };
        const fn_type = llvm.c.LLVMGlobalGetValueType(rc_alloc_fn);
        const ptr = self.builder.buildCall(
            fn_type,
            rc_alloc_fn,
            &args,
            "rc.alloc",
        );

        // Store the value at the returned pointer (opaque pointer in LLVM 15+)
        _ = self.builder.buildStore(value, ptr);

        // Return the pointer (Rc[T] is represented as a pointer)
        return ptr;
    }

    /// Emit rc.clone() - increments reference count.
    fn emitRcClone(self: *Emitter, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        // Declare the runtime function
        const rc_clone_fn = self.getOrDeclareRcClone();

        // Call klar_rc_clone(ptr)
        var args = [_]llvm.ValueRef{object};
        return self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(rc_clone_fn),
            rc_clone_fn,
            &args,
            "rc.clone",
        );
    }

    /// Emit rc.downgrade() - creates a Weak reference.
    fn emitRcDowngrade(self: *Emitter, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        // Declare the runtime function
        const rc_downgrade_fn = self.getOrDeclareRcDowngrade();

        // Call klar_rc_downgrade(ptr)
        var args = [_]llvm.ValueRef{object};
        return self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(rc_downgrade_fn),
            rc_downgrade_fn,
            &args,
            "rc.downgrade",
        );
    }

    /// Emit weak.upgrade() - attempts to get Rc from Weak.
    fn emitWeakUpgrade(self: *Emitter, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        // Declare the runtime function
        const weak_upgrade_fn = self.getOrDeclareWeakUpgrade();

        // Call klar_weak_upgrade(ptr) - returns null if Rc is gone
        var args = [_]llvm.ValueRef{object};
        const result_ptr = self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(weak_upgrade_fn),
            weak_upgrade_fn,
            &args,
            "weak.upgrade",
        );

        // Convert to optional: check if null
        const is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, result_ptr, llvm.c.LLVMConstNull(llvm.typeOf(result_ptr)), "is.null");

        // Create optional struct { i1, ptr }
        const ptr_type = llvm.Types.pointer(self.ctx);
        var struct_types = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), ptr_type };
        const opt_type = llvm.c.LLVMStructTypeInContext(self.ctx.ref, &struct_types, 2, 0);

        const opt_alloca = self.builder.buildAlloca(opt_type, "upgrade.opt");

        // Set tag: 1 if not null (Some), 0 if null (None)
        const tag = self.builder.buildNot(is_null, "tag");
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &tag_indices, "opt.tag.ptr");
        _ = self.builder.buildStore(tag, tag_ptr);

        // Set value (the pointer)
        var val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const val_ptr = self.builder.buildGEP(opt_type, opt_alloca, &val_indices, "opt.val.ptr");
        _ = self.builder.buildStore(result_ptr, val_ptr);

        // Load and return the optional
        return self.builder.buildLoad(opt_type, opt_alloca, "upgrade.result");
    }

    // ========================================================================
    // Arc (Atomic Reference Counting) - Thread-safe shared ownership
    // ========================================================================

    /// Emit Arc.new(value) - allocates an Arc with atomic reference counts.
    fn emitArcNew(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) {
            return EmitError.InvalidAST;
        }

        // Emit the value to be wrapped
        const value = try self.emitExpr(method.args[0]);
        const value_type = llvm.typeOf(value);

        // Declare the Arc runtime function if not already
        const arc_alloc_fn = self.getOrDeclareArcAlloc();

        // Calculate value size based on type
        const value_size: u64 = switch (llvm.getTypeKind(value_type)) {
            llvm.c.LLVMIntegerTypeKind => @as(u64, llvm.c.LLVMGetIntTypeWidth(value_type)) / 8,
            llvm.c.LLVMFloatTypeKind => 4,
            llvm.c.LLVMDoubleTypeKind => 8,
            llvm.c.LLVMPointerTypeKind => 8, // Assume 64-bit pointers
            else => 8, // Default to 8 bytes
        };
        const value_align: u64 = value_size; // Assume natural alignment

        var args = [_]llvm.ValueRef{
            llvm.Const.int64(self.ctx, @intCast(value_size)),
            llvm.Const.int64(self.ctx, @intCast(value_align)),
        };
        const fn_type = llvm.c.LLVMGlobalGetValueType(arc_alloc_fn);
        const ptr = self.builder.buildCall(
            fn_type,
            arc_alloc_fn,
            &args,
            "arc.alloc",
        );

        // Store the value at the returned pointer
        _ = self.builder.buildStore(value, ptr);

        // Return the pointer (Arc[T] is represented as a pointer)
        return ptr;
    }

    /// Emit arc.clone() - atomically increments reference count.
    fn emitArcClone(self: *Emitter, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        // Declare the runtime function
        const arc_clone_fn = self.getOrDeclareArcClone();

        // Call klar_arc_clone(ptr)
        var args = [_]llvm.ValueRef{object};
        return self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(arc_clone_fn),
            arc_clone_fn,
            &args,
            "arc.clone",
        );
    }

    /// Emit arc.downgrade() - creates a WeakArc reference.
    fn emitArcDowngrade(self: *Emitter, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        // Declare the runtime function
        const arc_downgrade_fn = self.getOrDeclareArcDowngrade();

        // Call klar_arc_downgrade(ptr)
        var args = [_]llvm.ValueRef{object};
        return self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(arc_downgrade_fn),
            arc_downgrade_fn,
            &args,
            "arc.downgrade",
        );
    }

    /// Emit weak_arc.upgrade() - attempts to atomically get an Arc from WeakArc.
    fn emitWeakArcUpgrade(self: *Emitter, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        // Declare the runtime function
        const weak_arc_upgrade_fn = self.getOrDeclareWeakArcUpgrade();

        // Call klar_weak_arc_upgrade(ptr) - returns null if Arc is gone
        var args = [_]llvm.ValueRef{object};
        const result_ptr = self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(weak_arc_upgrade_fn),
            weak_arc_upgrade_fn,
            &args,
            "weak_arc.upgrade",
        );

        // Convert to optional: check if null
        const is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, result_ptr, llvm.c.LLVMConstNull(llvm.typeOf(result_ptr)), "is.null");

        // Create optional struct { i1, ptr }
        const ptr_type = llvm.Types.pointer(self.ctx);
        var struct_types = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), ptr_type };
        const opt_type = llvm.c.LLVMStructTypeInContext(self.ctx.ref, &struct_types, 2, 0);

        const opt_alloca = self.builder.buildAlloca(opt_type, "upgrade.opt");

        // Set tag: 1 if not null (Some), 0 if null (None)
        const tag = self.builder.buildNot(is_null, "tag");
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &tag_indices, "opt.tag.ptr");
        _ = self.builder.buildStore(tag, tag_ptr);

        // Set value (the pointer)
        var val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const val_ptr = self.builder.buildGEP(opt_type, opt_alloca, &val_indices, "opt.val.ptr");
        _ = self.builder.buildStore(result_ptr, val_ptr);

        // Load and return the optional
        return self.builder.buildLoad(opt_type, opt_alloca, "upgrade.result");
    }

    /// Emit Cell.new(value) - creates a Cell containing the value.
    /// Cell is represented as a pointer to stack-allocated storage.
    fn emitCellNew(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) {
            return EmitError.InvalidAST;
        }

        // Emit the value to be stored in the cell
        const value = try self.emitExpr(method.args[0]);
        const value_type = llvm.typeOf(value);

        // Allocate stack space for the cell's value
        const cell_alloca = self.builder.buildAlloca(value_type, "cell.storage");

        // Store the initial value
        _ = self.builder.buildStore(value, cell_alloca);

        // Return the pointer to the cell (Cell[T] is represented as a pointer)
        return cell_alloca;
    }

    /// Emit cell.get() - returns a copy of the value in the cell.
    fn emitCellGet(self: *Emitter, method: *ast.MethodCall, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        // The object is a pointer to the cell's storage
        // We need to determine the type to load
        const inner_type = self.inferCellInnerType(method.object);
        return self.builder.buildLoad(inner_type, object, "cell.get");
    }

    /// Emit cell.set(value) - stores a new value in the cell.
    fn emitCellSet(self: *Emitter, method: *ast.MethodCall, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        if (method.args.len != 1) {
            return EmitError.InvalidAST;
        }

        // Emit the new value
        const new_value = try self.emitExpr(method.args[0]);

        // Store the new value in the cell
        _ = self.builder.buildStore(new_value, object);

        // set() returns void, but we need to return something
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit cell.replace(value) - stores new value, returns old value.
    fn emitCellReplace(self: *Emitter, method: *ast.MethodCall, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        if (method.args.len != 1) {
            return EmitError.InvalidAST;
        }

        // Load the old value first
        const inner_type = self.inferCellInnerType(method.object);
        const old_value = self.builder.buildLoad(inner_type, object, "cell.old");

        // Emit and store the new value
        const new_value = try self.emitExpr(method.args[0]);
        _ = self.builder.buildStore(new_value, object);

        // Return the old value
        return old_value;
    }

    /// Infer the inner type of a Cell expression.
    fn inferCellInnerType(self: *Emitter, expr: ast.Expr) llvm.TypeRef {
        // Check if it's an identifier with tracked inner type
        if (expr == .identifier) {
            const id = expr.identifier;
            if (self.named_values.get(id.name)) |local| {
                if (local.inner_type) |inner| {
                    return inner;
                }
            }
        }

        // For Cell.new(value), the inner type is the type of value
        if (expr == .method_call) {
            const method = expr.method_call;
            if (method.object == .identifier) {
                const obj_name = method.object.identifier.name;
                if (std.mem.eql(u8, obj_name, "Cell") and std.mem.eql(u8, method.method_name, "new")) {
                    if (method.args.len > 0) {
                        return self.inferExprType(method.args[0]) catch llvm.Types.int32(self.ctx);
                    }
                }
            }
        }

        // Default to i32
        return llvm.Types.int32(self.ctx);
    }

    /// Emit a closure expression.
    /// Closures are represented as a struct { fn_ptr, env_ptr } where:
    /// - fn_ptr points to the lifted function
    /// - env_ptr points to captured variables (null if no captures)
    fn emitClosure(self: *Emitter, closure: *ast.Closure) EmitError!llvm.ValueRef {
        // Generate unique name for this closure's lifted function
        const closure_id = self.closure_counter;
        self.closure_counter += 1;

        // Build closure name
        var name_buf: [64]u8 = undefined;
        const name_slice = std.fmt.bufPrint(&name_buf, "__klar_closure_{d}", .{closure_id}) catch
            return EmitError.OutOfMemory;
        const fn_name = self.allocator.dupeZ(u8, name_slice) catch return EmitError.OutOfMemory;
        defer self.allocator.free(fn_name);

        // Determine return type
        const return_type = try self.typeExprToLLVM(closure.return_type);

        // Build parameter types for the lifted function
        // First parameter is the environment pointer (for captured variables)
        var param_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer param_types.deinit(self.allocator);

        // Add environment pointer as first parameter
        param_types.append(self.allocator, llvm.Types.pointer(self.ctx)) catch return EmitError.OutOfMemory;

        // Add closure's declared parameters
        for (closure.params) |param| {
            const param_ty = try self.typeExprToLLVM(param.type_);
            param_types.append(self.allocator, param_ty) catch return EmitError.OutOfMemory;
        }

        // Create function type
        const fn_type = llvm.Types.function(return_type, param_types.items, false);

        // Create the lifted function
        const lifted_fn = llvm.addFunction(self.module, fn_name, fn_type);
        llvm.setFunctionCallConv(lifted_fn, self.calling_convention.toLLVM());

        // Save current state before emitting the lifted function body
        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;
        const saved_named_values = self.named_values;
        const saved_return_type = self.current_return_type;
        const saved_terminator = self.has_terminator;

        // Set up new context for lifted function
        self.named_values = std.StringHashMap(LocalValue).init(self.allocator);
        self.current_function = lifted_fn;
        self.has_terminator = false;

        // Set up return type info
        const rt = closure.return_type;
        const is_opt = rt == .optional or (rt == .generic_apply and
            rt.generic_apply.base == .named and
            std.mem.eql(u8, rt.generic_apply.base.named.name, "Option"));
        const is_res = rt == .result or (rt == .generic_apply and
            rt.generic_apply.base == .named and
            std.mem.eql(u8, rt.generic_apply.base.named.name, "Result"));

        // Extract inner types based on representation
        var inner_type: ?llvm.TypeRef = null;
        var ok_type: ?llvm.TypeRef = null;
        var err_type: ?llvm.TypeRef = null;

        if (is_opt) {
            if (rt == .optional) {
                inner_type = try self.typeExprToLLVM(rt.optional.inner);
            } else if (rt == .generic_apply and rt.generic_apply.args.len >= 1) {
                inner_type = try self.typeExprToLLVM(rt.generic_apply.args[0]);
            }
        }
        if (is_res) {
            if (rt == .result) {
                ok_type = try self.typeExprToLLVM(rt.result.ok_type);
                err_type = try self.typeExprToLLVM(rt.result.err_type);
            } else if (rt == .generic_apply and rt.generic_apply.args.len >= 2) {
                ok_type = try self.typeExprToLLVM(rt.generic_apply.args[0]);
                err_type = try self.typeExprToLLVM(rt.generic_apply.args[1]);
            }
        }

        self.current_return_type = .{
            .llvm_type = return_type,
            .is_optional = is_opt,
            .is_result = is_res,
            .inner_type = inner_type,
            .ok_type = ok_type,
            .err_type = err_type,
        };
        self.current_return_klar_type = self.resolveExpectedType(rt);

        // Create entry block for lifted function
        const entry_bb = llvm.appendBasicBlock(self.ctx, lifted_fn, "entry");
        self.builder.positionAtEnd(entry_bb);

        // Get environment pointer (first parameter)
        const env_ptr = llvm.getParam(lifted_fn, 0);

        // Load captured variables from environment and add to named_values.
        // The environment is a heap-allocated struct with values stored directly (not pointers).
        if (closure.captures) |captures| {
            // Build the environment struct type (must match what createClosureEnvironment built).
            // For now, assume all captures are i32. TODO: pass type info through AST.
            var field_types: [32]llvm.TypeRef = undefined;
            for (0..captures.len) |i| {
                field_types[i] = llvm.Types.int32(self.ctx);
            }
            const env_struct_type = llvm.Types.struct_(self.ctx, field_types[0..captures.len], false);

            for (captures, 0..) |capture, i| {
                // GEP to get pointer to the value field in the env struct
                var indices = [_]llvm.ValueRef{
                    llvm.Const.int32(self.ctx, 0),
                    llvm.Const.int32(self.ctx, @intCast(i)),
                };
                const field_ptr = self.builder.buildGEP(
                    env_struct_type,
                    env_ptr,
                    &indices,
                    "cap.field.ptr",
                );

                // Load the value from the env struct into a local alloca
                const cap_ty = llvm.Types.int32(self.ctx);
                const local_alloca = self.builder.buildAlloca(cap_ty, "cap.local");
                const cap_value = self.builder.buildLoad(cap_ty, field_ptr, "cap.value");
                _ = self.builder.buildStore(cap_value, local_alloca);

                // Store the alloca as the named value (will be loaded when accessed)
                self.named_values.put(capture.name, .{
                    .value = local_alloca,
                    .is_alloca = true,
                    .ty = cap_ty,
                    .is_signed = true,
                }) catch return EmitError.OutOfMemory;
            }
        }

        // Add closure parameters to named_values
        for (closure.params, 0..) |param, i| {
            const param_value = llvm.getParam(lifted_fn, @intCast(i + 1)); // +1 for env ptr
            const param_ty = try self.typeExprToLLVM(param.type_);

            // Allocate stack space for parameter
            const param_name = self.allocator.dupeZ(u8, param.name) catch return EmitError.OutOfMemory;
            defer self.allocator.free(param_name);

            const alloca = self.builder.buildAlloca(param_ty, param_name);
            _ = self.builder.buildStore(param_value, alloca);

            self.named_values.put(param.name, .{
                .value = alloca,
                .is_alloca = true,
                .ty = param_ty,
                .is_signed = self.isTypeExprSigned(param.type_),
            }) catch return EmitError.OutOfMemory;
        }

        // Emit the closure body
        const body_value = try self.emitExpr(closure.body);

        // Add return if not terminated
        if (!self.has_terminator) {
            _ = self.builder.buildRet(body_value);
        }

        // Restore original context
        self.named_values.deinit();
        self.named_values = saved_named_values;
        self.current_function = saved_func;
        self.current_return_type = saved_return_type;
        self.has_terminator = saved_terminator;
        if (saved_bb) |bb| {
            self.builder.positionAtEnd(bb);
        }

        // Now create the closure value in the calling context
        // Closure struct: { fn_ptr: ptr, env_ptr: ptr }
        const closure_struct_type = self.getClosureStructType();

        // Allocate closure struct
        const closure_alloca = self.builder.buildAlloca(closure_struct_type, "closure");

        // Store function pointer
        var fn_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "closure.fn.ptr");
        _ = self.builder.buildStore(lifted_fn, fn_ptr_gep);

        // Create and store environment (captured variables)
        const env_value = try self.createClosureEnvironment(closure.captures);
        var env_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "closure.env.ptr");
        _ = self.builder.buildStore(env_value, env_ptr_gep);

        // Return the closure struct (loaded)
        return self.builder.buildLoad(closure_struct_type, closure_alloca, "closure.val");
    }

    /// Create the environment struct for captured variables.
    /// Allocates the environment on the heap so closures can be returned from functions.
    fn createClosureEnvironment(self: *Emitter, captures: ?[]const ast.CapturedVar) EmitError!llvm.ValueRef {
        if (captures == null or captures.?.len == 0) {
            // No captures - return null pointer
            return llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        }

        const captures_list = captures.?;

        // Build a struct type containing all captured values (by value, not by pointer).
        // This allows closures to be returned from functions without dangling pointers.
        var field_types: [32]llvm.TypeRef = undefined;
        if (captures_list.len > 32) return EmitError.OutOfMemory;

        for (captures_list, 0..) |capture, i| {
            if (self.named_values.get(capture.name)) |local| {
                field_types[i] = local.ty;
            } else {
                // Fallback to i32 if not found
                field_types[i] = llvm.Types.int32(self.ctx);
            }
        }

        const env_struct_type = llvm.Types.struct_(self.ctx, field_types[0..captures_list.len], false);

        // Calculate size of the struct: each i32 is 4 bytes, no padding needed for homogeneous structs
        // TODO: Use proper target data layout when capturing non-i32 types
        const size_of_env: u64 = captures_list.len * 4;

        // Allocate on the heap using malloc
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{llvm.Const.int64(self.ctx, @intCast(size_of_env))};
        const env_ptr = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(malloc_fn),
            malloc_fn,
            &malloc_args,
            1,
            "env.heap",
        );

        // Copy each captured value into the heap-allocated struct
        for (captures_list, 0..) |capture, i| {
            if (self.named_values.get(capture.name)) |local| {
                // GEP to the i-th field in the environment struct
                var indices = [_]llvm.ValueRef{
                    llvm.Const.int32(self.ctx, 0),
                    llvm.Const.int32(self.ctx, @intCast(i)),
                };
                const field_ptr = self.builder.buildGEP(env_struct_type, env_ptr, &indices, "env.field");

                // Load the value from the local variable and store it in the env
                const value = self.builder.buildLoad(local.ty, local.value, "cap.load");
                _ = self.builder.buildStore(value, field_ptr);
            }
        }

        // Return pointer to heap-allocated environment
        return env_ptr;
    }

    /// Check if a type expression represents a signed type.
    fn isTypeExprSigned(self: *Emitter, type_expr: ast.TypeExpr) bool {
        _ = self;
        return switch (type_expr) {
            .named => |n| {
                // Unsigned types
                if (std.mem.startsWith(u8, n.name, "u")) return false;
                return true;
            },
            else => true,
        };
    }

    // Runtime function declarations

    fn getOrDeclareRcAlloc(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_rc_alloc";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: *anyopaque klar_rc_alloc(usize value_size, usize value_align)
        // Layout: [strong_count:i64][weak_count:i64][value:value_size]
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ i64_type, i64_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 2, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Parameters
        const value_size = llvm.c.LLVMGetParam(func, 0);
        _ = llvm.c.LLVMGetParam(func, 1); // value_align (unused for now)

        // Calculate total size: 16 (header) + value_size
        const header_size = llvm.Const.int64(self.ctx, 16);
        const total_size = llvm.c.LLVMBuildAdd(self.builder.ref, header_size, value_size, "total_size");

        // Call malloc
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{total_size};
        const raw_ptr = llvm.c.LLVMBuildCall2(self.builder.ref, llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, 1, "malloc_result");

        // Store strong_count = 1 at offset 0
        const strong_ptr = llvm.c.LLVMBuildBitCast(self.builder.ref, raw_ptr, llvm.c.LLVMPointerType(i64_type, 0), "strong_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, llvm.Const.int64(self.ctx, 1), strong_ptr);

        // Store weak_count = 1 at offset 8
        const eight = llvm.Const.int64(self.ctx, 8);
        const weak_ptr_int = llvm.c.LLVMBuildAdd(self.builder.ref, llvm.c.LLVMBuildPtrToInt(self.builder.ref, raw_ptr, i64_type, "ptr_int"), eight, "weak_off");
        const weak_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, weak_ptr_int, llvm.c.LLVMPointerType(i64_type, 0), "weak_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, llvm.Const.int64(self.ctx, 1), weak_ptr);

        // Return pointer to value (offset 16)
        const sixteen = llvm.Const.int64(self.ctx, 16);
        const val_ptr_int = llvm.c.LLVMBuildAdd(self.builder.ref, llvm.c.LLVMBuildPtrToInt(self.builder.ref, raw_ptr, i64_type, "ptr_int2"), sixteen, "val_off");
        const val_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, val_ptr_int, ptr_type, "val_ptr");

        _ = llvm.c.LLVMBuildRet(self.builder.ref, val_ptr);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareMalloc(self: *Emitter) llvm.ValueRef {
        const fn_name = "malloc";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{i64_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareRealloc(self: *Emitter) llvm.ValueRef {
        const fn_name = "realloc";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // void* realloc(void* ptr, size_t size)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 2, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareRcClone(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_rc_clone";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: *anyopaque klar_rc_clone(*anyopaque ptr)
        // Increments strong_count (at header offset -16 from value ptr) and returns ptr
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, param_types.len, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Get value pointer parameter
        const value_ptr = llvm.c.LLVMGetParam(func, 0);

        // Calculate header address: value_ptr - 16
        const ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, value_ptr, i64_type, "ptr_int");
        const header_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 16), "header_off");
        const strong_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, llvm.c.LLVMPointerType(i64_type, 0), "strong_ptr");

        // Load, increment, store strong_count
        const strong_count = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, strong_ptr, "strong_count");
        const new_count = llvm.c.LLVMBuildAdd(self.builder.ref, strong_count, llvm.Const.int64(self.ctx, 1), "new_count");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, new_count, strong_ptr);

        // Return the original pointer
        _ = llvm.c.LLVMBuildRet(self.builder.ref, value_ptr);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareRcDowngrade(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_rc_downgrade";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: *anyopaque klar_rc_downgrade(*anyopaque ptr)
        // Increments weak_count (at header offset -8 from value ptr) and returns ptr
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, param_types.len, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Get value pointer parameter
        const value_ptr = llvm.c.LLVMGetParam(func, 0);

        // Calculate weak_count address: value_ptr - 8 (header is at -16, weak_count is at +8 in header)
        const ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, value_ptr, i64_type, "ptr_int");
        const weak_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 8), "weak_off");
        const weak_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, weak_off, llvm.c.LLVMPointerType(i64_type, 0), "weak_ptr");

        // Load, increment, store weak_count
        const weak_count = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, weak_ptr, "weak_count");
        const new_count = llvm.c.LLVMBuildAdd(self.builder.ref, weak_count, llvm.Const.int64(self.ctx, 1), "new_count");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, new_count, weak_ptr);

        // Return the original pointer
        _ = llvm.c.LLVMBuildRet(self.builder.ref, value_ptr);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareWeakUpgrade(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_weak_upgrade";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: *anyopaque klar_weak_upgrade(*anyopaque ptr)
        // Returns ptr if strong_count > 0 (and increments it), else returns null
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, param_types.len, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const success_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "success");
        const fail_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "fail");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Get value pointer parameter
        const value_ptr = llvm.c.LLVMGetParam(func, 0);

        // Calculate strong_count address: value_ptr - 16
        const ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, value_ptr, i64_type, "ptr_int");
        const header_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 16), "header_off");
        const strong_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, llvm.c.LLVMPointerType(i64_type, 0), "strong_ptr");

        // Load strong_count and check if > 0
        const strong_count = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, strong_ptr, "strong_count");
        const is_alive = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntUGT, strong_count, llvm.Const.int64(self.ctx, 0), "is_alive");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_alive, success_bb, fail_bb);

        // Success: increment strong_count and return ptr
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, success_bb);
        const new_count = llvm.c.LLVMBuildAdd(self.builder.ref, strong_count, llvm.Const.int64(self.ctx, 1), "new_count");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, new_count, strong_ptr);
        _ = llvm.c.LLVMBuildRet(self.builder.ref, value_ptr);

        // Fail: return null
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, fail_bb);
        _ = llvm.c.LLVMBuildRet(self.builder.ref, llvm.c.LLVMConstNull(ptr_type));

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareRcDrop(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_rc_drop";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: void klar_rc_drop(*anyopaque ptr, usize size, usize align, *fn destructor)
        // Decrements strong_count. If 0, calls destructor (if not null), decrements weak_count.
        // If weak_count also 0, frees the allocation.
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i64_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, param_types.len, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create basic blocks
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const strong_zero_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "strong_zero");
        const call_dtor_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "call_dtor");
        const after_dtor_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "after_dtor");
        const free_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "free");
        const done_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "done");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Get parameters
        const value_ptr = llvm.c.LLVMGetParam(func, 0);
        _ = llvm.c.LLVMGetParam(func, 1); // value_size (for free calculation)
        _ = llvm.c.LLVMGetParam(func, 2); // value_align (unused)
        const destructor = llvm.c.LLVMGetParam(func, 3);

        // Calculate strong_count address: value_ptr - 16
        const ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, value_ptr, i64_type, "ptr_int");
        const header_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 16), "header_off");
        const strong_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, llvm.c.LLVMPointerType(i64_type, 0), "strong_ptr");

        // Load, decrement, store strong_count
        const strong_count = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, strong_ptr, "strong_count");
        const new_strong = llvm.c.LLVMBuildSub(self.builder.ref, strong_count, llvm.Const.int64(self.ctx, 1), "new_strong");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, new_strong, strong_ptr);

        // Check if strong_count == 0
        const is_zero = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, new_strong, llvm.Const.int64(self.ctx, 0), "is_zero");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_zero, strong_zero_bb, done_bb);

        // strong_zero: call destructor if not null, then decrement weak_count
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, strong_zero_bb);
        const dtor_null = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, destructor, llvm.c.LLVMConstNull(ptr_type), "dtor_null");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, dtor_null, after_dtor_bb, call_dtor_bb);

        // call_dtor: call destructor(value_ptr)
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, call_dtor_bb);
        var dtor_param_types = [_]llvm.TypeRef{ptr_type};
        const dtor_fn_type = llvm.c.LLVMFunctionType(void_type, &dtor_param_types, 1, 0);
        var dtor_args = [_]llvm.ValueRef{value_ptr};
        _ = llvm.c.LLVMBuildCall2(self.builder.ref, dtor_fn_type, destructor, &dtor_args, 1, "");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, after_dtor_bb);

        // after_dtor: decrement weak_count
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, after_dtor_bb);
        const weak_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 8), "weak_off");
        const weak_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, weak_off, llvm.c.LLVMPointerType(i64_type, 0), "weak_ptr");
        const weak_count = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, weak_ptr, "weak_count");
        const new_weak = llvm.c.LLVMBuildSub(self.builder.ref, weak_count, llvm.Const.int64(self.ctx, 1), "new_weak");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, new_weak, weak_ptr);

        // Check if weak_count == 0
        const weak_zero = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, new_weak, llvm.Const.int64(self.ctx, 0), "weak_zero");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, weak_zero, free_bb, done_bb);

        // free: call free on the header pointer
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, free_bb);
        const header_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, ptr_type, "header_ptr");
        const free_fn = self.getOrDeclareFree();
        var free_args = [_]llvm.ValueRef{header_ptr};
        _ = llvm.c.LLVMBuildCall2(self.builder.ref, llvm.c.LLVMGlobalGetValueType(free_fn), free_fn, &free_args, 1, "");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_bb);

        // done: return
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_bb);
        _ = llvm.c.LLVMBuildRetVoid(self.builder.ref);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareFree(self: *Emitter) llvm.ValueRef {
        const fn_name = "free";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        const ptr_type = llvm.Types.pointer(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    // ========================================================================
    // Arc (Atomic Reference Counting) Runtime Function Implementations
    // ========================================================================
    // These implement thread-safe atomic reference counting using LLVM atomics.
    // Arc uses the same memory layout as Rc: [strong_count:i64][weak_count:i64][value]
    // but uses atomic operations for thread safety.

    fn getOrDeclareArcAlloc(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_arc_alloc";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: *anyopaque klar_arc_alloc(usize value_size, usize value_align)
        // Same layout as Rc: [strong_count:i64][weak_count:i64][value:value_size]
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ i64_type, i64_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 2, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Parameters
        const value_size = llvm.c.LLVMGetParam(func, 0);
        _ = llvm.c.LLVMGetParam(func, 1); // value_align (unused for now)

        // Calculate total size: 16 (header) + value_size
        const header_size = llvm.Const.int64(self.ctx, 16);
        const total_size = llvm.c.LLVMBuildAdd(self.builder.ref, header_size, value_size, "total_size");

        // Call malloc
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{total_size};
        const raw_ptr = llvm.c.LLVMBuildCall2(self.builder.ref, llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, 1, "malloc_result");

        // Store strong_count = 1 at offset 0 (using atomic store for consistency)
        const strong_ptr = llvm.c.LLVMBuildBitCast(self.builder.ref, raw_ptr, llvm.c.LLVMPointerType(i64_type, 0), "strong_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, llvm.Const.int64(self.ctx, 1), strong_ptr);

        // Store weak_count = 1 at offset 8
        const eight = llvm.Const.int64(self.ctx, 8);
        const weak_ptr_int = llvm.c.LLVMBuildAdd(self.builder.ref, llvm.c.LLVMBuildPtrToInt(self.builder.ref, raw_ptr, i64_type, "ptr_int"), eight, "weak_off");
        const weak_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, weak_ptr_int, llvm.c.LLVMPointerType(i64_type, 0), "weak_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, llvm.Const.int64(self.ctx, 1), weak_ptr);

        // Return pointer to value (offset 16)
        const sixteen = llvm.Const.int64(self.ctx, 16);
        const val_ptr_int = llvm.c.LLVMBuildAdd(self.builder.ref, llvm.c.LLVMBuildPtrToInt(self.builder.ref, raw_ptr, i64_type, "ptr_int2"), sixteen, "val_off");
        const val_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, val_ptr_int, ptr_type, "val_ptr");

        _ = llvm.c.LLVMBuildRet(self.builder.ref, val_ptr);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareArcClone(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_arc_clone";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: *anyopaque klar_arc_clone(*anyopaque ptr)
        // Atomically increments strong_count and returns ptr
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, param_types.len, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Get value pointer parameter
        const value_ptr = llvm.c.LLVMGetParam(func, 0);

        // Calculate header address: value_ptr - 16
        const ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, value_ptr, i64_type, "ptr_int");
        const header_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 16), "header_off");
        const strong_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, llvm.c.LLVMPointerType(i64_type, 0), "strong_ptr");

        // Atomic increment: atomicrmw add i64* %strong_ptr, i64 1 monotonic
        _ = llvm.c.LLVMBuildAtomicRMW(
            self.builder.ref,
            llvm.c.LLVMAtomicRMWBinOpAdd,
            strong_ptr,
            llvm.Const.int64(self.ctx, 1),
            llvm.c.LLVMAtomicOrderingMonotonic,
            0, // not single threaded
        );

        // Return the original pointer
        _ = llvm.c.LLVMBuildRet(self.builder.ref, value_ptr);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareArcDowngrade(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_arc_downgrade";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: *anyopaque klar_arc_downgrade(*anyopaque ptr)
        // Atomically increments weak_count (at header offset -8 from value ptr) and returns ptr
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, param_types.len, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Get value pointer parameter
        const value_ptr = llvm.c.LLVMGetParam(func, 0);

        // Calculate weak_count address: value_ptr - 8
        const ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, value_ptr, i64_type, "ptr_int");
        const weak_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 8), "weak_off");
        const weak_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, weak_off, llvm.c.LLVMPointerType(i64_type, 0), "weak_ptr");

        // Atomic increment weak_count
        _ = llvm.c.LLVMBuildAtomicRMW(
            self.builder.ref,
            llvm.c.LLVMAtomicRMWBinOpAdd,
            weak_ptr,
            llvm.Const.int64(self.ctx, 1),
            llvm.c.LLVMAtomicOrderingMonotonic,
            0,
        );

        // Return the original pointer
        _ = llvm.c.LLVMBuildRet(self.builder.ref, value_ptr);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareWeakArcUpgrade(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_weak_arc_upgrade";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: *anyopaque klar_weak_arc_upgrade(*anyopaque ptr)
        // Atomically increments strong_count if > 0, returns ptr or null
        // This uses a compare-and-swap loop for thread safety
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, param_types.len, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create basic blocks for CAS loop
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const loop_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop");
        const success_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "success");
        const fail_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "fail");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Get value pointer parameter
        const value_ptr = llvm.c.LLVMGetParam(func, 0);

        // Calculate strong_count address: value_ptr - 16
        const ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, value_ptr, i64_type, "ptr_int");
        const header_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 16), "header_off");
        const strong_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, llvm.c.LLVMPointerType(i64_type, 0), "strong_ptr");

        // Initial load with acquire ordering
        const initial_count = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, strong_ptr, "initial_count");
        llvm.c.LLVMSetOrdering(initial_count, llvm.c.LLVMAtomicOrderingAcquire);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_bb);

        // Loop: check if count > 0 and try CAS
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_bb);
        const current_phi = llvm.c.LLVMBuildPhi(self.builder.ref, i64_type, "current");

        // Check if count > 0
        const is_alive = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntUGT, current_phi, llvm.Const.int64(self.ctx, 0), "is_alive");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_alive, success_bb, fail_bb);

        // Success: try to increment with CAS
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, success_bb);
        const new_count = llvm.c.LLVMBuildAdd(self.builder.ref, current_phi, llvm.Const.int64(self.ctx, 1), "new_count");

        // Use cmpxchg for thread-safe increment
        const cmpxchg_result = llvm.c.LLVMBuildAtomicCmpXchg(
            self.builder.ref,
            strong_ptr,
            current_phi,
            new_count,
            llvm.c.LLVMAtomicOrderingAcquireRelease,
            llvm.c.LLVMAtomicOrderingMonotonic,
            0, // not single threaded
        );

        // Extract success flag and value
        const success_flag = llvm.c.LLVMBuildExtractValue(self.builder.ref, cmpxchg_result, 1, "success_flag");
        const loaded_val = llvm.c.LLVMBuildExtractValue(self.builder.ref, cmpxchg_result, 0, "loaded_val");

        // If CAS succeeded, return ptr; otherwise retry with loaded value
        const ret_or_retry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "ret_success");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, success_flag, ret_or_retry_bb, loop_bb);

        // Return success
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, ret_or_retry_bb);
        _ = llvm.c.LLVMBuildRet(self.builder.ref, value_ptr);

        // Fail: return null
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, fail_bb);
        _ = llvm.c.LLVMBuildRet(self.builder.ref, llvm.c.LLVMConstNull(ptr_type));

        // Add phi incoming values
        var phi_values = [_]llvm.ValueRef{ initial_count, loaded_val };
        var phi_blocks = [_]llvm.c.LLVMBasicBlockRef{ entry_bb, success_bb };
        llvm.c.LLVMAddIncoming(current_phi, &phi_values, &phi_blocks, 2);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareArcDrop(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_arc_drop";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: void klar_arc_drop(*anyopaque ptr, usize size, usize align, *fn destructor)
        // Atomically decrements strong_count. If 0, calls destructor, decrements weak_count.
        // If weak_count also 0, frees the allocation.
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i64_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, param_types.len, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create basic blocks
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const strong_zero_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "strong_zero");
        const call_dtor_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "call_dtor");
        const after_dtor_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "after_dtor");
        const free_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "free");
        const done_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "done");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Get parameters
        const value_ptr = llvm.c.LLVMGetParam(func, 0);
        _ = llvm.c.LLVMGetParam(func, 1); // value_size
        _ = llvm.c.LLVMGetParam(func, 2); // value_align
        const destructor = llvm.c.LLVMGetParam(func, 3);

        // Calculate strong_count address: value_ptr - 16
        const ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, value_ptr, i64_type, "ptr_int");
        const header_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 16), "header_off");
        const strong_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, llvm.c.LLVMPointerType(i64_type, 0), "strong_ptr");

        // Atomic decrement with release ordering
        const prev_strong = llvm.c.LLVMBuildAtomicRMW(
            self.builder.ref,
            llvm.c.LLVMAtomicRMWBinOpSub,
            strong_ptr,
            llvm.Const.int64(self.ctx, 1),
            llvm.c.LLVMAtomicOrderingRelease,
            0,
        );

        // Check if we were the last strong reference (prev was 1)
        const was_one = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, prev_strong, llvm.Const.int64(self.ctx, 1), "was_one");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, was_one, strong_zero_bb, done_bb);

        // strong_zero: acquire fence, call destructor if not null, decrement weak_count
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, strong_zero_bb);
        // Acquire fence to synchronize with other threads' releases
        _ = llvm.c.LLVMBuildFence(self.builder.ref, llvm.c.LLVMAtomicOrderingAcquire, 0, "");

        const dtor_null = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, destructor, llvm.c.LLVMConstNull(ptr_type), "dtor_null");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, dtor_null, after_dtor_bb, call_dtor_bb);

        // call_dtor: call destructor(value_ptr)
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, call_dtor_bb);
        var dtor_param_types = [_]llvm.TypeRef{ptr_type};
        const dtor_fn_type = llvm.c.LLVMFunctionType(void_type, &dtor_param_types, 1, 0);
        var dtor_args = [_]llvm.ValueRef{value_ptr};
        _ = llvm.c.LLVMBuildCall2(self.builder.ref, dtor_fn_type, destructor, &dtor_args, 1, "");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, after_dtor_bb);

        // after_dtor: atomic decrement weak_count
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, after_dtor_bb);
        const weak_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 8), "weak_off");
        const weak_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, weak_off, llvm.c.LLVMPointerType(i64_type, 0), "weak_ptr");

        const prev_weak = llvm.c.LLVMBuildAtomicRMW(
            self.builder.ref,
            llvm.c.LLVMAtomicRMWBinOpSub,
            weak_ptr,
            llvm.Const.int64(self.ctx, 1),
            llvm.c.LLVMAtomicOrderingRelease,
            0,
        );

        // Check if weak_count was 1 (now 0)
        const weak_was_one = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, prev_weak, llvm.Const.int64(self.ctx, 1), "weak_was_one");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, weak_was_one, free_bb, done_bb);

        // free: free the header pointer
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, free_bb);
        // Acquire fence before freeing
        _ = llvm.c.LLVMBuildFence(self.builder.ref, llvm.c.LLVMAtomicOrderingAcquire, 0, "");
        const header_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, ptr_type, "header_ptr");
        const free_fn = self.getOrDeclareFree();
        var free_args = [_]llvm.ValueRef{header_ptr};
        _ = llvm.c.LLVMBuildCall2(self.builder.ref, llvm.c.LLVMGlobalGetValueType(free_fn), free_fn, &free_args, 1, "");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_bb);

        // done: return
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_bb);
        _ = llvm.c.LLVMBuildRetVoid(self.builder.ref);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    fn getOrDeclareWeakArcDrop(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_weak_arc_drop";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Define: void klar_weak_arc_drop(*anyopaque ptr, usize size, usize align)
        // Atomically decrements weak_count. If 0 and strong_count is 0, frees allocation.
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i64_type };
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 3, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create basic blocks
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const check_strong_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "check_strong");
        const free_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "free");
        const done_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "done");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);

        // Get parameters
        const value_ptr = llvm.c.LLVMGetParam(func, 0);
        _ = llvm.c.LLVMGetParam(func, 1); // value_size
        _ = llvm.c.LLVMGetParam(func, 2); // value_align

        // Calculate addresses
        const ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, value_ptr, i64_type, "ptr_int");
        const weak_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 8), "weak_off");
        const weak_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, weak_off, llvm.c.LLVMPointerType(i64_type, 0), "weak_ptr");

        // Atomic decrement weak_count
        const prev_weak = llvm.c.LLVMBuildAtomicRMW(
            self.builder.ref,
            llvm.c.LLVMAtomicRMWBinOpSub,
            weak_ptr,
            llvm.Const.int64(self.ctx, 1),
            llvm.c.LLVMAtomicOrderingRelease,
            0,
        );

        // Check if weak_count was 1
        const weak_was_one = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, prev_weak, llvm.Const.int64(self.ctx, 1), "weak_was_one");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, weak_was_one, check_strong_bb, done_bb);

        // check_strong: check if strong_count is also 0
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_strong_bb);
        // Acquire fence
        _ = llvm.c.LLVMBuildFence(self.builder.ref, llvm.c.LLVMAtomicOrderingAcquire, 0, "");

        const header_off = llvm.c.LLVMBuildSub(self.builder.ref, ptr_int, llvm.Const.int64(self.ctx, 16), "header_off");
        const strong_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, llvm.c.LLVMPointerType(i64_type, 0), "strong_ptr");
        const strong_count = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, strong_ptr, "strong_count");
        llvm.c.LLVMSetOrdering(strong_count, llvm.c.LLVMAtomicOrderingAcquire);

        const strong_zero = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, strong_count, llvm.Const.int64(self.ctx, 0), "strong_zero");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, strong_zero, free_bb, done_bb);

        // free: free the header pointer
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, free_bb);
        const header_ptr = llvm.c.LLVMBuildIntToPtr(self.builder.ref, header_off, ptr_type, "header_ptr");
        const free_fn = self.getOrDeclareFree();
        var free_args = [_]llvm.ValueRef{header_ptr};
        _ = llvm.c.LLVMBuildCall2(self.builder.ref, llvm.c.LLVMGlobalGetValueType(free_fn), free_fn, &free_args, 1, "");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_bb);

        // done: return
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_bb);
        _ = llvm.c.LLVMBuildRetVoid(self.builder.ref);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    /// Emit an interpolated string expression.
    /// For each part, emit either a string literal or the expression converted to string.
    /// Uses snprintf to build the final string in a stack buffer.
    fn emitInterpolatedString(self: *Emitter, interp: *ast.InterpolatedString) EmitError!llvm.ValueRef {
        if (interp.parts.len == 0) {
            return self.builder.buildGlobalStringPtr("", "empty_interp");
        }

        // Simple case: single string literal part
        if (interp.parts.len == 1) {
            switch (interp.parts[0]) {
                .string => |s| {
                    const str_z = self.allocator.dupeZ(u8, s) catch return EmitError.OutOfMemory;
                    defer self.allocator.free(str_z);
                    return self.builder.buildGlobalStringPtr(str_z, "interp_str");
                },
                .expr => |e| {
                    // Single expression - emit as format string with printf-style format
                    return self.emitExprAsString(e);
                },
            }
        }

        // Multiple parts: build format string and args for snprintf
        // We'll use a fixed-size stack buffer and snprintf
        var format_parts = std.ArrayListUnmanaged(u8){};
        defer format_parts.deinit(self.allocator);

        var expr_values = std.ArrayListUnmanaged(llvm.ValueRef){};
        defer expr_values.deinit(self.allocator);

        for (interp.parts) |part| {
            switch (part) {
                .string => |s| {
                    // Escape any % in the string for printf format
                    for (s) |c| {
                        if (c == '%') {
                            format_parts.append(self.allocator, '%') catch return EmitError.OutOfMemory;
                            format_parts.append(self.allocator, '%') catch return EmitError.OutOfMemory;
                        } else {
                            format_parts.append(self.allocator, c) catch return EmitError.OutOfMemory;
                        }
                    }
                },
                .expr => |e| {
                    // Emit the expression and determine format specifier
                    const val = try self.emitExpr(e);
                    expr_values.append(self.allocator, val) catch return EmitError.OutOfMemory;

                    // Determine the format specifier based on the expression type
                    // First check semantic type for char (which is i32 at LLVM level)
                    const format_spec: []const u8 = if (self.isCharExpr(e))
                        "%c" // char type - print as character
                    else blk: {
                        const val_type = llvm.c.LLVMTypeOf(val);
                        const type_kind = llvm.c.LLVMGetTypeKind(val_type);

                        break :blk switch (type_kind) {
                            llvm.c.LLVMIntegerTypeKind => inner: {
                                const bit_width = llvm.c.LLVMGetIntTypeWidth(val_type);
                                if (bit_width == 1) {
                                    // Bool - we need special handling
                                    break :inner "%d";
                                } else if (bit_width <= 32) {
                                    break :inner "%d";
                                } else {
                                    break :inner "%lld";
                                }
                            },
                            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => "%g",
                            llvm.c.LLVMPointerTypeKind => "%s",
                            else => "%d", // Default to int
                        };
                    };

                    for (format_spec) |c| {
                        format_parts.append(self.allocator, c) catch return EmitError.OutOfMemory;
                    }
                },
            }
        }

        // Create the format string
        format_parts.append(self.allocator, 0) catch return EmitError.OutOfMemory; // null terminate
        const format_str = self.builder.buildGlobalStringPtr(format_parts.items[0 .. format_parts.items.len - 1 :0], "interp_fmt");

        // Allocate a buffer on the stack for the result
        const buffer_size: u64 = 1024;
        const i8_type = llvm.Types.int8(self.ctx);
        const buffer_type = llvm.Types.array(i8_type, buffer_size);
        const buffer = self.builder.buildAlloca(buffer_type, "interp_buf");

        // Get pointer to buffer start
        var indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const buffer_ptr = self.builder.buildGEP(buffer_type, buffer, &indices, "buf_ptr");

        // Call snprintf(buffer, size, format, args...)
        const snprintf_fn = self.getOrDeclareSnprintf();
        const i64_type = llvm.Types.int64(self.ctx);
        const size_val = llvm.Const.int(i64_type, buffer_size, false);

        var call_args = std.ArrayListUnmanaged(llvm.ValueRef){};
        defer call_args.deinit(self.allocator);
        call_args.append(self.allocator, buffer_ptr) catch return EmitError.OutOfMemory;
        call_args.append(self.allocator, size_val) catch return EmitError.OutOfMemory;
        call_args.append(self.allocator, format_str) catch return EmitError.OutOfMemory;
        for (expr_values.items) |val| {
            call_args.append(self.allocator, val) catch return EmitError.OutOfMemory;
        }

        const fn_type = llvm.c.LLVMGlobalGetValueType(snprintf_fn);
        _ = self.builder.buildCall(fn_type, snprintf_fn, call_args.items, "");

        return buffer_ptr;
    }

    /// Emit a builtin call like @typeName, @typeInfo, @hasField, etc.
    /// Also handles user-defined comptime function calls via @name(...) syntax.
    /// These are evaluated at compile time and the results are stored in type_checker.
    fn emitBuiltinCall(self: *Emitter, bc: *ast.BuiltinCall) EmitError!llvm.ValueRef {
        // Look up the precomputed result from the type checker
        if (self.type_checker) |tc| {
            // Check for user-defined comptime function call results first
            if (tc.comptime_builtin_values.get(bc)) |comptime_value| {
                return self.emitComptimeValue(comptime_value);
            }
            // Check for string results (e.g., @typeName)
            if (tc.comptime_strings.get(bc)) |computed_string| {
                // Emit as a global string constant
                const str_z = self.allocator.dupeZ(u8, computed_string) catch return EmitError.OutOfMemory;
                defer self.allocator.free(str_z);
                return self.builder.buildGlobalStringPtr(str_z, "comptime_str");
            }
            // Check for boolean results (e.g., @hasField)
            if (tc.comptime_bools.get(bc)) |computed_bool| {
                return llvm.Const.int1(self.ctx, computed_bool);
            }
            // Check for integer results (e.g., @sizeOf, @alignOf)
            if (tc.comptime_ints.get(bc)) |computed_int| {
                return llvm.Const.int32(self.ctx, @intCast(computed_int));
            }
            // Check for @repeat(value, count) results
            if (tc.comptime_repeats.get(bc)) |repeat_info| {
                return self.emitRepeat(repeat_info);
            }
        }
        // Fallback: return 0 if not found
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit @repeat(value, count) as an array with the value repeated count times.
    fn emitRepeat(self: *Emitter, repeat_info: TypeChecker.RepeatInfo) EmitError!llvm.ValueRef {
        const element_llvm_type = self.typeToLLVM(repeat_info.element_type);
        const array_type = llvm.Types.array(element_llvm_type, repeat_info.count);

        // Allocate the array
        const array_alloca = self.builder.buildAlloca(array_type, "repeat_arr");

        // Emit the value once
        const value = try self.emitExpr(repeat_info.value_expr);

        // For byte types (i8, u8) with large counts, use memset for efficiency
        // This avoids generating N individual store instructions which can crash LLVM
        const is_byte_type = if (repeat_info.element_type == .primitive)
            (repeat_info.element_type.primitive == .i8_ or repeat_info.element_type.primitive == .u8_)
        else
            false;

        if (is_byte_type and repeat_info.count > 64) {
            // Use memset for byte arrays
            const memset_fn = self.getOrDeclareMemset();
            const size = llvm.Const.int64(self.ctx, @intCast(repeat_info.count));
            // Zero-extend i8 value to i32 for memset's int parameter
            const value_i32 = self.builder.buildZExt(value, llvm.Types.int32(self.ctx), "memset_val");
            var memset_args = [_]llvm.ValueRef{ array_alloca, value_i32, size };
            _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memset_fn), memset_fn, &memset_args, "");
        } else {
            // Store the value at each index (for small arrays or non-byte types)
            for (0..repeat_info.count) |i| {
                var indices = [_]llvm.ValueRef{
                    llvm.Const.int32(self.ctx, 0),
                    llvm.Const.int32(self.ctx, @intCast(i)),
                };
                const elem_ptr = self.builder.buildGEP(array_type, array_alloca, &indices, "repeat_elem");
                _ = self.builder.buildStore(value, elem_ptr);
            }
        }

        // Load and return the array
        return self.builder.buildLoad(array_type, array_alloca, "repeat_val");
    }

    /// Emit @repeat directly into a destination pointer, avoiding intermediate load/store.
    /// This is used for large arrays to avoid stack overflow from loading entire arrays as values.
    fn emitRepeatInto(self: *Emitter, repeat_info: TypeChecker.RepeatInfo, dest_ptr: llvm.ValueRef) EmitError!void {
        const element_llvm_type = self.typeToLLVM(repeat_info.element_type);
        const array_type = llvm.Types.array(element_llvm_type, repeat_info.count);

        // Emit the value once
        const value = try self.emitExpr(repeat_info.value_expr);

        // For byte types (i8, u8) with large counts, use memset for efficiency
        const is_byte_type = if (repeat_info.element_type == .primitive)
            (repeat_info.element_type.primitive == .i8_ or repeat_info.element_type.primitive == .u8_)
        else
            false;

        if (is_byte_type and repeat_info.count > 64) {
            // Use memset for byte arrays - write directly to destination
            const memset_fn = self.getOrDeclareMemset();
            const size = llvm.Const.int64(self.ctx, @intCast(repeat_info.count));
            // Zero-extend i8 value to i32 for memset's int parameter
            const value_i32 = self.builder.buildZExt(value, llvm.Types.int32(self.ctx), "memset_val");
            var memset_args = [_]llvm.ValueRef{ dest_ptr, value_i32, size };
            _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memset_fn), memset_fn, &memset_args, "");
        } else {
            // Store the value at each index
            for (0..repeat_info.count) |i| {
                var indices = [_]llvm.ValueRef{
                    llvm.Const.int32(self.ctx, 0),
                    llvm.Const.int32(self.ctx, @intCast(i)),
                };
                const elem_ptr = self.builder.buildGEP(array_type, dest_ptr, &indices, "repeat_elem");
                _ = self.builder.buildStore(value, elem_ptr);
            }
        }
        // No load - caller already has the destination pointer
    }

    /// Check if an expression is a large @repeat that should use direct initialization.
    /// Returns the RepeatInfo if it's a large array (> 4096 bytes for byte types), null otherwise.
    fn tryGetLargeRepeatInfo(self: *Emitter, expr: ast.Expr) ?TypeChecker.RepeatInfo {
        // Check if it's a builtin call
        if (expr != .builtin_call) return null;
        const bc = expr.builtin_call;

        // Check if it's @repeat
        if (!std.mem.eql(u8, bc.name, "repeat")) return null;

        // Get the repeat info from type checker
        const tc = self.type_checker orelse return null;
        const repeat_info = tc.comptime_repeats.get(bc) orelse return null;

        // Check if it's a byte type
        const is_byte_type = if (repeat_info.element_type == .primitive)
            (repeat_info.element_type.primitive == .i8_ or repeat_info.element_type.primitive == .u8_)
        else
            false;

        // Threshold: 4096 bytes for byte arrays
        // For non-byte types, use element count * 8 (assuming max 8 bytes per element)
        const size_threshold: usize = 4096;
        const estimated_size = if (is_byte_type)
            repeat_info.count
        else
            repeat_info.count * 8;

        if (estimated_size > size_threshold) {
            return repeat_info;
        }
        return null;
    }

    /// Emit a ComptimeValue as an LLVM constant.
    fn emitComptimeValue(self: *Emitter, comptime_value: TypeChecker.ComptimeValue) EmitError!llvm.ValueRef {
        return switch (comptime_value) {
            .int => |i| if (i.is_i32)
                llvm.Const.int32(self.ctx, @intCast(i.value))
            else
                llvm.Const.int64(self.ctx, @intCast(i.value)),
            .float => |f| llvm.Const.float64(self.ctx, f),
            .bool_ => |b| llvm.Const.int1(self.ctx, b),
            .string => |s| blk: {
                const str_z = self.allocator.dupeZ(u8, s) catch return EmitError.OutOfMemory;
                defer self.allocator.free(str_z);
                break :blk self.builder.buildGlobalStringPtr(str_z, "comptime_str");
            },
            .void_ => llvm.Const.int32(self.ctx, 0),
            .struct_ => |cs| blk: {
                // Get the LLVM struct type
                const struct_info = self.struct_types.get(cs.type_name) orelse {
                    break :blk llvm.Const.int32(self.ctx, 0); // Fallback
                };
                const struct_type = struct_info.llvm_type;

                // Build constant field values in the correct order
                var field_values = std.ArrayListUnmanaged(llvm.ValueRef){};
                defer field_values.deinit(self.allocator);

                // Iterate through struct fields in declaration order
                for (struct_info.field_names) |field_name| {
                    if (cs.fields.get(field_name)) |field_cv| {
                        const field_val = try self.emitComptimeValue(field_cv);
                        field_values.append(self.allocator, field_val) catch return EmitError.OutOfMemory;
                    } else {
                        // Field not found - use zero
                        field_values.append(self.allocator, llvm.Const.int32(self.ctx, 0)) catch return EmitError.OutOfMemory;
                    }
                }

                // Create constant struct
                break :blk llvm.Const.namedStruct(struct_type, field_values.items);
            },
            .array => |arr| blk: {
                // Get the LLVM element type
                const element_llvm_type = self.typeToLLVM(arr.element_type);

                // Recursively emit each element as a constant
                var element_values = std.ArrayListUnmanaged(llvm.ValueRef){};
                defer element_values.deinit(self.allocator);

                for (arr.elements) |elem| {
                    const elem_val = try self.emitComptimeValue(elem);
                    element_values.append(self.allocator, elem_val) catch return EmitError.OutOfMemory;
                }

                // Create constant array
                break :blk llvm.Const.array(element_llvm_type, element_values.items);
            },
        };
    }

    /// Emit a comptime block.
    /// These are evaluated at compile time by the type checker and the results are stored.
    fn emitComptimeBlock(self: *Emitter, cb: *ast.ComptimeBlock) EmitError!llvm.ValueRef {
        // Look up the precomputed result from the type checker
        if (self.type_checker) |tc| {
            if (tc.comptime_values.get(cb)) |comptime_value| {
                return self.emitComptimeValue(comptime_value);
            }
        }
        // Fallback: return 0 if not found (should not happen if type checking passed)
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit an expression and convert it to a string for interpolation.
    /// Returns a pointer to a string representation.
    fn emitExprAsString(self: *Emitter, expr: ast.Expr) EmitError!llvm.ValueRef {
        const val = try self.emitExpr(expr);
        const val_type = llvm.c.LLVMTypeOf(val);
        const type_kind = llvm.c.LLVMGetTypeKind(val_type);

        // If already a pointer (string), return as-is
        if (type_kind == llvm.c.LLVMPointerTypeKind) {
            return val;
        }

        // For other types, use sprintf to convert
        const buffer_size: u64 = 64;
        const i8_type = llvm.Types.int8(self.ctx);
        const buffer_type = llvm.Types.array(i8_type, buffer_size);
        const buffer = self.builder.buildAlloca(buffer_type, "tostr_buf");

        var indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const buffer_ptr = self.builder.buildGEP(buffer_type, buffer, &indices, "buf_ptr");

        // Check semantic type for char first (which is i32 at LLVM level)
        const format_spec: [:0]const u8 = if (self.isCharExpr(expr))
            "%c" // char type - print as character
        else switch (type_kind) {
            llvm.c.LLVMIntegerTypeKind => blk: {
                const bit_width = llvm.c.LLVMGetIntTypeWidth(val_type);
                if (bit_width <= 32) {
                    break :blk "%d";
                } else {
                    break :blk "%lld";
                }
            },
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => "%g",
            else => "%d",
        };

        const format_str = self.builder.buildGlobalStringPtr(format_spec, "tostr_fmt");

        const snprintf_fn = self.getOrDeclareSnprintf();
        const i64_type = llvm.Types.int64(self.ctx);
        const size_val = llvm.Const.int(i64_type, buffer_size, false);

        var call_args = [_]llvm.ValueRef{ buffer_ptr, size_val, format_str, val };
        const fn_type = llvm.c.LLVMGlobalGetValueType(snprintf_fn);
        _ = self.builder.buildCall(fn_type, snprintf_fn, &call_args, "");

        return buffer_ptr;
    }

    fn getOrDeclareSnprintf(self: *Emitter) llvm.ValueRef {
        const fn_name = "snprintf";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int snprintf(char *str, size_t size, const char *format, ...)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, ptr_type };
        // variadic = 1 (true)
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 3, 1);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Emit a print or println call using libc puts/printf
    fn emitPrint(self: *Emitter, args: []const ast.Expr, newline: bool) EmitError!llvm.ValueRef {
        if (args.len == 0) {
            // No arguments - just print newline if println
            if (newline) {
                const puts_fn = self.getOrDeclarePuts();
                const empty_str = self.builder.buildGlobalStringPtr("", "empty");
                var call_args = [_]llvm.ValueRef{empty_str};
                const fn_type = llvm.c.LLVMGlobalGetValueType(puts_fn);
                return self.builder.buildCall(fn_type, puts_fn, &call_args, "");
            }
            return llvm.Const.int32(self.ctx, 0);
        }

        // Check if argument is String type - if so, we need to get the struct pointer
        // and extract field 0 (the data pointer) for puts/printf
        var arg_value: llvm.ValueRef = undefined;
        if (self.isStringDataExpr(args[0])) {
            // For String types, we need the alloca pointer, not the loaded value
            const str_ptr = if (args[0] == .identifier) blk: {
                if (self.named_values.get(args[0].identifier.name)) |local| {
                    break :blk local.value; // This is the alloca pointer
                }
                // Identifier not found, emit expression and store to temp
                const obj_val = try self.emitExpr(args[0]);
                const string_type = self.getStringStructType();
                const tmp_alloca = self.builder.buildAlloca(string_type, "print.str.tmp");
                _ = self.builder.buildStore(obj_val, tmp_alloca);
                break :blk tmp_alloca;
            } else blk: {
                // Non-identifier (e.g., method call result like x.to_string())
                const obj_val = try self.emitExpr(args[0]);
                const string_type = self.getStringStructType();
                const tmp_alloca = self.builder.buildAlloca(string_type, "print.str.tmp");
                _ = self.builder.buildStore(obj_val, tmp_alloca);
                break :blk tmp_alloca;
            };
            // String struct is { ptr, len, capacity }
            // Extract field 0 (the data pointer) for puts/printf
            const string_type = self.getStringStructType();
            const ptr_type = llvm.Types.pointer(self.ctx);
            const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "print.str_ptr_ptr");
            arg_value = self.builder.buildLoad(ptr_type, ptr_ptr, "print.str_ptr");
        } else {
            // Regular string literal - emit directly
            arg_value = try self.emitExpr(args[0]);
        }

        if (newline) {
            // Use puts for println (automatically adds newline)
            const puts_fn = self.getOrDeclarePuts();
            var call_args = [_]llvm.ValueRef{arg_value};
            const fn_type = llvm.c.LLVMGlobalGetValueType(puts_fn);
            return self.builder.buildCall(fn_type, puts_fn, &call_args, "");
        } else {
            // Use printf for print (no newline)
            const printf_fn = self.getOrDeclarePrintf();
            var call_args = [_]llvm.ValueRef{arg_value};
            const fn_type = llvm.c.LLVMGlobalGetValueType(printf_fn);
            return self.builder.buildCall(fn_type, printf_fn, &call_args, "");
        }
    }

    /// Emit a readline call that reads a line from stdin
    fn emitReadline(self: *Emitter) EmitError!llvm.ValueRef {
        // Allocate buffer on stack for fgets
        const buffer_size: u32 = 4096;
        const i8_type = llvm.Types.int8(self.ctx);
        const buffer_type = llvm.c.LLVMArrayType(i8_type, buffer_size);
        const buffer = self.builder.buildAlloca(buffer_type, "readline_buf");

        // Get pointer to first element
        const zero = llvm.Const.int32(self.ctx, 0);
        var indices = [_]llvm.ValueRef{ zero, zero };
        const buffer_ptr = self.builder.buildGEP(buffer_type, buffer, &indices, "buf_ptr");

        // Call fgets(buffer, size, stdin)
        const fgets_fn = self.getOrDeclareFgets();
        const stdin_fn = self.getOrDeclareStdin();
        const stdin_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stdin_fn), stdin_fn, &[_]llvm.ValueRef{}, "stdin");
        const size = llvm.Const.int32(self.ctx, @intCast(buffer_size));
        var call_args = [_]llvm.ValueRef{ buffer_ptr, size, stdin_ptr };
        const fn_type = llvm.c.LLVMGlobalGetValueType(fgets_fn);
        const result = self.builder.buildCall(fn_type, fgets_fn, &call_args, "fgets_result");

        // If fgets returns null (EOF), set buffer to empty string
        const current_func = self.current_function orelse return EmitError.InvalidAST;
        const is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, result, llvm.Const.null_(llvm.Types.pointer(self.ctx)), "is_null");
        const eof_bb = llvm.appendBasicBlock(self.ctx, current_func, "readline.eof");
        const strip_bb = llvm.appendBasicBlock(self.ctx, current_func, "readline.strip");
        const done_bb = llvm.appendBasicBlock(self.ctx, current_func, "readline.done");

        _ = self.builder.buildCondBr(is_null, eof_bb, strip_bb);

        // EOF block - set buffer to empty string
        self.builder.positionAtEnd(eof_bb);
        _ = self.builder.buildStore(llvm.Const.int8(self.ctx, 0), buffer_ptr);
        _ = self.builder.buildBr(done_bb);

        // Strip newline block
        self.builder.positionAtEnd(strip_bb);
        // Get string length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{buffer_ptr};
        const strlen_type = llvm.c.LLVMGlobalGetValueType(strlen_fn);
        const len = self.builder.buildCall(strlen_type, strlen_fn, &strlen_args, "len");

        // Check if len > 0 and last char is newline
        const zero_i64 = llvm.Const.int64(self.ctx, 0);
        const one_i64 = llvm.Const.int64(self.ctx, 1);
        const has_chars = self.builder.buildICmp(llvm.c.LLVMIntSGT, len, zero_i64, "has_chars");

        const check_newline_bb = llvm.appendBasicBlock(self.ctx, current_func, "readline.check_nl");
        _ = self.builder.buildCondBr(has_chars, check_newline_bb, done_bb);

        // Check for newline
        self.builder.positionAtEnd(check_newline_bb);
        const last_idx = self.builder.buildSub(len, one_i64, "last_idx");
        var last_indices = [_]llvm.ValueRef{last_idx};
        const last_char_ptr = self.builder.buildGEP(i8_type, buffer_ptr, &last_indices, "last_char_ptr");
        const last_char = self.builder.buildLoad(i8_type, last_char_ptr, "last_char");
        const newline = llvm.Const.int8(self.ctx, '\n');
        const is_newline = self.builder.buildICmp(llvm.c.LLVMIntEQ, last_char, newline, "is_newline");

        const strip_nl_bb = llvm.appendBasicBlock(self.ctx, current_func, "readline.strip_nl");
        _ = self.builder.buildCondBr(is_newline, strip_nl_bb, done_bb);

        // Strip the newline by setting it to null
        self.builder.positionAtEnd(strip_nl_bb);
        _ = self.builder.buildStore(llvm.Const.int8(self.ctx, 0), last_char_ptr);
        _ = self.builder.buildBr(done_bb);

        // Done - return buffer pointer (strings in Klar native are char*)
        self.builder.positionAtEnd(done_bb);
        return buffer_ptr;
    }

    fn getOrDeclarePuts(self: *Emitter) llvm.ValueRef {
        const fn_name = "puts";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int puts(const char *s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareFgets(self: *Emitter) llvm.ValueRef {
        const fn_name = "fgets";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // char* fgets(char* str, int num, FILE* stream)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i32_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclarePrintf(self: *Emitter) llvm.ValueRef {
        const fn_name = "printf";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int printf(const char *format, ...)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        // variadic = 1 (true)
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 1, 1);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Emit a panic call that prints an error message and aborts
    fn emitPanic(self: *Emitter, args: []const ast.Expr) EmitError!llvm.ValueRef {
        // Print "panic: " prefix
        const fprintf_fn = self.getOrDeclareFprintf();
        const stderr_fn = self.getOrDeclareStderr();
        const stderr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stderr_fn), stderr_fn, &[_]llvm.ValueRef{}, "stderr");

        const panic_prefix = self.builder.buildGlobalStringPtr("panic: ", "panic_prefix");
        var prefix_args = [_]llvm.ValueRef{ stderr, panic_prefix };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fprintf_fn), fprintf_fn, &prefix_args, "");

        // Print the message if provided
        if (args.len > 0) {
            const msg = try self.emitExpr(args[0]);
            var msg_args = [_]llvm.ValueRef{ stderr, msg };
            _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fprintf_fn), fprintf_fn, &msg_args, "");
        }

        // Print newline
        const newline_str = self.builder.buildGlobalStringPtr("\n", "newline");
        var nl_args = [_]llvm.ValueRef{ stderr, newline_str };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fprintf_fn), fprintf_fn, &nl_args, "");

        // Call abort
        const abort_fn = self.getOrDeclareAbort();
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(abort_fn), abort_fn, &[_]llvm.ValueRef{}, "");

        // Add unreachable since abort doesn't return
        _ = self.builder.buildUnreachable();

        // Mark that we have a terminator so no more code is emitted after this
        self.has_terminator = true;

        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit an assert that panics if condition is false
    fn emitAssert(self: *Emitter, args: []const ast.Expr) EmitError!llvm.ValueRef {
        if (args.len == 0) {
            return llvm.Const.int32(self.ctx, 0);
        }

        const func = self.current_function orelse return EmitError.InvalidAST;

        // Evaluate the condition
        const cond = try self.emitExpr(args[0]);

        // Create blocks
        const fail_bb = llvm.appendBasicBlock(self.ctx, func, "assert.fail");
        const continue_bb = llvm.appendBasicBlock(self.ctx, func, "assert.continue");

        // Branch based on condition
        _ = self.builder.buildCondBr(cond, continue_bb, fail_bb);

        // Emit failure block
        self.builder.positionAtEnd(fail_bb);

        // Print assertion failure message to stderr
        const fprintf_fn = self.getOrDeclareFprintf();
        const stderr_fn = self.getOrDeclareStderr();
        const stderr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stderr_fn), stderr_fn, &[_]llvm.ValueRef{}, "stderr");

        const fail_msg = self.builder.buildGlobalStringPtr("assertion failed\n", "assert_msg");
        var fail_args = [_]llvm.ValueRef{ stderr, fail_msg };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fprintf_fn), fprintf_fn, &fail_args, "");

        // Call abort
        const abort_fn = self.getOrDeclareAbort();
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(abort_fn), abort_fn, &[_]llvm.ValueRef{}, "");
        _ = self.builder.buildUnreachable();

        // Continue block - assertion passed
        self.builder.positionAtEnd(continue_bb);

        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit assert_eq that compares two values and panics with details on failure
    fn emitAssertEq(self: *Emitter, args: []const ast.Expr) EmitError!llvm.ValueRef {
        if (args.len != 2) {
            return llvm.Const.int32(self.ctx, 0);
        }

        const func = self.current_function orelse return EmitError.InvalidAST;

        // Evaluate both arguments
        const left = try self.emitExpr(args[0]);
        const right = try self.emitExpr(args[1]);

        // Get the type for comparison
        const left_type = llvm.typeOf(left);
        const type_kind = llvm.c.LLVMGetTypeKind(left_type);

        // Create comparison based on type
        const cond = switch (type_kind) {
            llvm.c.LLVMIntegerTypeKind => self.builder.buildICmp(llvm.c.LLVMIntEQ, left, right, "assert_eq.cmp"),
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => self.builder.buildFCmp(llvm.c.LLVMRealOEQ, left, right, "assert_eq.cmp"),
            llvm.c.LLVMPointerTypeKind => self.builder.buildICmp(llvm.c.LLVMIntEQ, left, right, "assert_eq.cmp"),
            else => self.builder.buildICmp(llvm.c.LLVMIntEQ, left, right, "assert_eq.cmp"),
        };

        // Create blocks
        const fail_bb = llvm.appendBasicBlock(self.ctx, func, "assert_eq.fail");
        const continue_bb = llvm.appendBasicBlock(self.ctx, func, "assert_eq.continue");

        // Branch based on condition
        _ = self.builder.buildCondBr(cond, continue_bb, fail_bb);

        // Emit failure block
        self.builder.positionAtEnd(fail_bb);

        // Print assertion failure message to stderr with values
        const fprintf_fn = self.getOrDeclareFprintf();
        const stderr_fn = self.getOrDeclareStderr();
        const stderr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stderr_fn), stderr_fn, &[_]llvm.ValueRef{}, "stderr");

        // Format string based on type
        const fmt_str = switch (type_kind) {
            llvm.c.LLVMIntegerTypeKind => self.builder.buildGlobalStringPtr("assertion failed: left = %lld, right = %lld\n", "assert_eq_fmt"),
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => self.builder.buildGlobalStringPtr("assertion failed: left = %g, right = %g\n", "assert_eq_fmt"),
            llvm.c.LLVMPointerTypeKind => self.builder.buildGlobalStringPtr("assertion failed: left = %p, right = %p\n", "assert_eq_fmt"),
            else => self.builder.buildGlobalStringPtr("assertion failed: values not equal\n", "assert_eq_fmt"),
        };

        // For integer types, extend to i64 for printf compatibility
        var left_val = left;
        var right_val = right;
        if (type_kind == llvm.c.LLVMIntegerTypeKind) {
            const i64_type = llvm.Types.int64(self.ctx);
            const bit_width = llvm.c.LLVMGetIntTypeWidth(left_type);
            if (bit_width < 64) {
                left_val = llvm.c.LLVMBuildSExt(self.builder.ref, left, i64_type, "left_ext");
                right_val = llvm.c.LLVMBuildSExt(self.builder.ref, right, i64_type, "right_ext");
            }
        }

        var fail_args = [_]llvm.ValueRef{ stderr, fmt_str, left_val, right_val };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fprintf_fn), fprintf_fn, &fail_args, "");

        // Call abort
        const abort_fn = self.getOrDeclareAbort();
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(abort_fn), abort_fn, &[_]llvm.ValueRef{}, "");
        _ = self.builder.buildUnreachable();

        // Continue block - assertion passed
        self.builder.positionAtEnd(continue_bb);

        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit dbg(value) - prints value with debug info and returns value
    fn emitDbg(self: *Emitter, args: []const ast.Expr) EmitError!llvm.ValueRef {
        if (args.len != 1) {
            return llvm.Const.int32(self.ctx, 0);
        }

        // Emit the argument
        const value = try self.emitExpr(args[0]);
        const value_type = llvm.typeOf(value);
        const type_kind = llvm.c.LLVMGetTypeKind(value_type);

        // Print to stderr
        const fprintf_fn = self.getOrDeclareFprintf();
        const stderr_fn = self.getOrDeclareStderr();
        const stderr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stderr_fn), stderr_fn, &[_]llvm.ValueRef{}, "stderr");

        // Format string based on type
        const fmt_str = switch (type_kind) {
            llvm.c.LLVMIntegerTypeKind => blk: {
                const bit_width = llvm.c.LLVMGetIntTypeWidth(value_type);
                if (bit_width == 1) {
                    break :blk self.builder.buildGlobalStringPtr("[dbg] %s\n", "dbg_fmt");
                }
                break :blk self.builder.buildGlobalStringPtr("[dbg] %lld\n", "dbg_fmt");
            },
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => self.builder.buildGlobalStringPtr("[dbg] %g\n", "dbg_fmt"),
            llvm.c.LLVMPointerTypeKind => self.builder.buildGlobalStringPtr("[dbg] %p\n", "dbg_fmt"),
            else => self.builder.buildGlobalStringPtr("[dbg] <value>\n", "dbg_fmt"),
        };

        // For integer types, extend to i64 for printf compatibility (except bool)
        var print_val = value;
        if (type_kind == llvm.c.LLVMIntegerTypeKind) {
            const bit_width = llvm.c.LLVMGetIntTypeWidth(value_type);
            if (bit_width == 1) {
                // Bool - use conditional to select "true" or "false"
                const true_str = self.builder.buildGlobalStringPtr("true", "true_str");
                const false_str = self.builder.buildGlobalStringPtr("false", "false_str");
                print_val = self.builder.buildSelect(value, true_str, false_str, "bool_str");
            } else if (bit_width < 64) {
                const i64_type = llvm.Types.int64(self.ctx);
                print_val = llvm.c.LLVMBuildSExt(self.builder.ref, value, i64_type, "val_ext");
            }
        }

        var dbg_args = [_]llvm.ValueRef{ stderr, fmt_str, print_val };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fprintf_fn), fprintf_fn, &dbg_args, "");

        // Return the original value (pass-through)
        return value;
    }

    /// Emit debug(value) - returns string representation of any value
    /// Uses type info from type checker to generate appropriate formatting
    fn emitDebug(self: *Emitter, call: *ast.Call) EmitError!llvm.ValueRef {
        if (call.args.len != 1) {
            return self.builder.buildGlobalStringPtr("<debug: invalid args>", "debug_err");
        }

        // Emit the argument value
        const value = try self.emitExpr(call.args[0]);

        // Get the Klar type from type checker
        if (self.type_checker) |checker| {
            if (checker.debug_call_types.get(call)) |klar_type| {
                return self.emitDebugValue(value, klar_type);
            }
        }

        // Fallback: format based on LLVM type
        return self.emitDebugValueFromLLVM(value);
    }

    /// Emit debug formatting for a value based on Klar type info
    fn emitDebugValue(self: *Emitter, value: llvm.ValueRef, klar_type: types.Type) EmitError!llvm.ValueRef {
        return switch (klar_type) {
            .primitive => |prim| self.emitDebugPrimitive(value, prim),
            .struct_ => |struct_info| self.emitDebugStruct(value, struct_info),
            .enum_ => |enum_info| self.emitDebugEnum(value, enum_info),
            .array => |arr_info| self.emitDebugArray(value, arr_info),
            .tuple => |tuple_info| self.emitDebugTuple(value, tuple_info),
            .optional => |opt_info| self.emitDebugOptional(value, opt_info),
            .function => self.builder.buildGlobalStringPtr("<function>", "debug_fn"),
            .reference => self.emitDebugPointer(value),
            else => self.emitDebugValueFromLLVM(value),
        };
    }

    /// Emit debug formatting for primitive types
    fn emitDebugPrimitive(self: *Emitter, value: llvm.ValueRef, prim: types.Primitive) EmitError!llvm.ValueRef {
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const buffer_size: u32 = 64;
        const buf_type = llvm.c.LLVMArrayType(i8_type, buffer_size);
        const buf = self.builder.buildAlloca(buf_type, "debug.buf");
        const indices = [2]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const buf_ptr = self.builder.buildGEP(buf_type, buf, &indices, "debug.buf_ptr");

        const snprintf_fn = self.getOrDeclareSnprintf();
        const fn_type = llvm.c.LLVMGlobalGetValueType(snprintf_fn);
        const size_val = llvm.Const.int(i64_type, buffer_size, false);

        switch (prim) {
            .bool_ => {
                // Format as "true" or "false"
                const true_str = self.builder.buildGlobalStringPtr("true", "debug.true");
                const false_str = self.builder.buildGlobalStringPtr("false", "debug.false");
                return self.builder.buildSelect(value, true_str, false_str, "debug.bool");
            },
            .char_ => {
                // Format as 'c'
                const fmt = self.builder.buildGlobalStringPtr("'%c'", "debug.char_fmt");
                var val32 = value;
                const value_type = llvm.typeOf(value);
                const bit_width = llvm.c.LLVMGetIntTypeWidth(value_type);
                if (bit_width != 32) {
                    val32 = llvm.c.LLVMBuildTrunc(self.builder.ref, value, i32_type, "debug.char_trunc");
                }
                var args = [_]llvm.ValueRef{ buf_ptr, size_val, fmt, val32 };
                _ = self.builder.buildCall(fn_type, snprintf_fn, &args, "");
                return buf_ptr;
            },
            .string_ => {
                // Format as "string"
                const fmt = self.builder.buildGlobalStringPtr("\"%s\"", "debug.str_fmt");
                var args = [_]llvm.ValueRef{ buf_ptr, size_val, fmt, value };
                _ = self.builder.buildCall(fn_type, snprintf_fn, &args, "");
                return buf_ptr;
            },
            .f32_, .f64_ => {
                // Format as floating point
                const fmt = self.builder.buildGlobalStringPtr("%g", "debug.float_fmt");
                // Promote f32 to f64 for printf
                var val64 = value;
                const value_type = llvm.typeOf(value);
                if (llvm.c.LLVMGetTypeKind(value_type) == llvm.c.LLVMFloatTypeKind) {
                    val64 = llvm.c.LLVMBuildFPExt(self.builder.ref, value, llvm.Types.float64(self.ctx), "debug.fpext");
                }
                var args = [_]llvm.ValueRef{ buf_ptr, size_val, fmt, val64 };
                _ = self.builder.buildCall(fn_type, snprintf_fn, &args, "");
                return buf_ptr;
            },
            else => {
                // Integer types
                const fmt = self.builder.buildGlobalStringPtr("%lld", "debug.int_fmt");
                // Extend to i64 for printf
                const value_type = llvm.typeOf(value);
                var val64 = value;
                if (llvm.c.LLVMGetTypeKind(value_type) == llvm.c.LLVMIntegerTypeKind) {
                    const bit_width = llvm.c.LLVMGetIntTypeWidth(value_type);
                    if (bit_width < 64) {
                        val64 = llvm.c.LLVMBuildSExt(self.builder.ref, value, i64_type, "debug.sext");
                    }
                }
                var args = [_]llvm.ValueRef{ buf_ptr, size_val, fmt, val64 };
                _ = self.builder.buildCall(fn_type, snprintf_fn, &args, "");
                return buf_ptr;
            },
        }
    }

    /// Emit debug formatting for struct types
    fn emitDebugStruct(self: *Emitter, value: llvm.ValueRef, struct_info: *types.StructType) EmitError!llvm.ValueRef {
        _ = value; // Full implementation would iterate fields
        // For now, return "StructName { ... }"
        var buf: [256]u8 = undefined;
        const name = struct_info.name;
        const result = std.fmt.bufPrintZ(&buf, "{s} {{ ... }}", .{name}) catch "{s} {{ ... }}";
        return self.builder.buildGlobalStringPtr(result, "debug.struct");
    }

    /// Emit debug formatting for enum types
    fn emitDebugEnum(self: *Emitter, value: llvm.ValueRef, enum_info: *types.EnumType) EmitError!llvm.ValueRef {
        _ = value;
        // For now, return "EnumName.?"
        // Full implementation would switch on tag
        var buf: [256]u8 = undefined;
        const name = enum_info.name;
        const result = std.fmt.bufPrintZ(&buf, "{s}.?", .{name}) catch "{s}.?";
        return self.builder.buildGlobalStringPtr(result, "debug.enum");
    }

    /// Emit debug formatting for array types
    fn emitDebugArray(self: *Emitter, value: llvm.ValueRef, arr_info: *types.ArrayType) EmitError!llvm.ValueRef {
        _ = value;
        _ = arr_info;
        // For now, return "[...]"
        return self.builder.buildGlobalStringPtr("[...]", "debug.array");
    }

    /// Emit debug formatting for tuple types
    fn emitDebugTuple(self: *Emitter, value: llvm.ValueRef, tuple_info: *types.TupleType) EmitError!llvm.ValueRef {
        _ = value;
        _ = tuple_info;
        // For now, return "(...)"
        return self.builder.buildGlobalStringPtr("(...)", "debug.tuple");
    }

    /// Emit debug formatting for optional types
    fn emitDebugOptional(self: *Emitter, value: llvm.ValueRef, inner_type: *types.Type) EmitError!llvm.ValueRef {
        _ = inner_type;
        // Check if value is Some or None
        // For now, just return "Some(...)" or "None" based on tag
        const value_type = llvm.typeOf(value);
        const type_kind = llvm.c.LLVMGetTypeKind(value_type);

        if (type_kind == llvm.c.LLVMStructTypeKind) {
            // Extract tag (first field)
            const tag = self.builder.buildExtractValue(value, 0, "debug.opt_tag");
            const some_str = self.builder.buildGlobalStringPtr("Some(...)", "debug.some");
            const none_str = self.builder.buildGlobalStringPtr("None", "debug.none");
            // Tag 0 = None, 1 = Some
            const is_some = self.builder.buildICmp(llvm.c.LLVMIntNE, tag, llvm.Const.int8(self.ctx, 0), "debug.is_some");
            return self.builder.buildSelect(is_some, some_str, none_str, "debug.opt");
        }
        return self.builder.buildGlobalStringPtr("?", "debug.opt_unknown");
    }

    /// Emit debug formatting for pointer/reference types
    fn emitDebugPointer(self: *Emitter, value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i8_type = llvm.Types.int8(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const buffer_size: u32 = 32;
        const buf_type = llvm.c.LLVMArrayType(i8_type, buffer_size);
        const buf = self.builder.buildAlloca(buf_type, "debug.ptr_buf");
        const indices = [2]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const buf_ptr = self.builder.buildGEP(buf_type, buf, &indices, "debug.ptr_buf_ptr");

        const snprintf_fn = self.getOrDeclareSnprintf();
        const fn_type = llvm.c.LLVMGlobalGetValueType(snprintf_fn);
        const size_val = llvm.Const.int(i64_type, buffer_size, false);
        const fmt = self.builder.buildGlobalStringPtr("%p", "debug.ptr_fmt");

        var args = [_]llvm.ValueRef{ buf_ptr, size_val, fmt, value };
        _ = self.builder.buildCall(fn_type, snprintf_fn, &args, "");
        return buf_ptr;
    }

    /// Fallback: emit debug formatting based on LLVM type alone
    fn emitDebugValueFromLLVM(self: *Emitter, value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const value_type = llvm.typeOf(value);
        const type_kind = llvm.c.LLVMGetTypeKind(value_type);

        return switch (type_kind) {
            llvm.c.LLVMIntegerTypeKind => blk: {
                const bit_width = llvm.c.LLVMGetIntTypeWidth(value_type);
                if (bit_width == 1) {
                    // Bool
                    const true_str = self.builder.buildGlobalStringPtr("true", "debug.true");
                    const false_str = self.builder.buildGlobalStringPtr("false", "debug.false");
                    break :blk self.builder.buildSelect(value, true_str, false_str, "debug.bool");
                }
                // Integer
                break :blk try self.emitDebugPrimitive(value, .i64_);
            },
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => try self.emitDebugPrimitive(value, .f64_),
            llvm.c.LLVMPointerTypeKind => self.builder.buildGlobalStringPtr("<ptr>", "debug.ptr"),
            llvm.c.LLVMStructTypeKind => self.builder.buildGlobalStringPtr("<struct>", "debug.struct"),
            llvm.c.LLVMArrayTypeKind => self.builder.buildGlobalStringPtr("<array>", "debug.array"),
            llvm.c.LLVMVoidTypeKind => self.builder.buildGlobalStringPtr("void", "debug.void"),
            else => self.builder.buildGlobalStringPtr("<unknown>", "debug.unknown"),
        };
    }

    /// Emit type_name(value) - returns the type name as a string
    fn emitTypeName(self: *Emitter, args: []const ast.Expr) EmitError!llvm.ValueRef {
        if (args.len != 1) {
            return self.builder.buildGlobalStringPtr("unknown", "type_name");
        }

        // Emit the argument to get its type
        const value = try self.emitExpr(args[0]);
        const value_type = llvm.typeOf(value);
        const type_kind = llvm.c.LLVMGetTypeKind(value_type);

        // Return type name string based on LLVM type
        const type_name = switch (type_kind) {
            llvm.c.LLVMIntegerTypeKind => blk: {
                const bit_width = llvm.c.LLVMGetIntTypeWidth(value_type);
                break :blk switch (bit_width) {
                    1 => "bool",
                    8 => "i8",
                    16 => "i16",
                    32 => "i32",
                    64 => "i64",
                    128 => "i128",
                    else => "int",
                };
            },
            llvm.c.LLVMFloatTypeKind => "f32",
            llvm.c.LLVMDoubleTypeKind => "f64",
            llvm.c.LLVMPointerTypeKind => "ptr",
            llvm.c.LLVMStructTypeKind => "struct",
            llvm.c.LLVMArrayTypeKind => "array",
            llvm.c.LLVMVoidTypeKind => "void",
            else => "unknown",
        };

        return self.builder.buildGlobalStringPtr(type_name, "type_name_str");
    }

    /// Emit len(value) - returns the length of a string or array
    fn emitLen(self: *Emitter, args: []const ast.Expr) EmitError!llvm.ValueRef {
        if (args.len != 1) {
            return llvm.Const.int32(self.ctx, 0);
        }

        // Emit the argument
        const value = try self.emitExpr(args[0]);
        const value_type = llvm.typeOf(value);
        const type_kind = llvm.c.LLVMGetTypeKind(value_type);

        // For arrays, return the compile-time length
        if (type_kind == llvm.c.LLVMArrayTypeKind) {
            const arr_len = llvm.c.LLVMGetArrayLength2(value_type);
            return llvm.Const.int32(self.ctx, @intCast(arr_len));
        }

        // For strings (pointers), use strlen and truncate to i32
        if (type_kind == llvm.c.LLVMPointerTypeKind) {
            const strlen_fn = self.getOrDeclareStrlen();
            var strlen_args = [_]llvm.ValueRef{value};
            const len_i64 = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &strlen_args, "strlen");
            // Truncate from size_t (i64) to i32
            const i32_type = llvm.Types.int32(self.ctx);
            return llvm.c.LLVMBuildTrunc(self.builder.ref, len_i64, i32_type, "strlen_i32");
        }

        // For other types, return 0
        return llvm.Const.int32(self.ctx, 0);
    }

    // =========================================================================
    // FFI Pointer Functions
    // =========================================================================

    /// Emit is_null(ptr: COptPtr[T]) -> bool
    /// Compares the pointer to null and returns the result.
    fn emitIsNull(self: *Emitter, call: *ast.Call) EmitError!llvm.ValueRef {
        if (call.args.len != 1) {
            return llvm.Const.int1(self.ctx, false);
        }
        const ptr = try self.emitExpr(call.args[0]);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        return self.builder.buildICmp(llvm.c.LLVMIntEQ, ptr, null_ptr, "is_null");
    }

    /// Emit unwrap_ptr(ptr: COptPtr[T]) -> CPtr[T]
    /// Returns the pointer unchanged (assumes caller validated it's not null).
    /// In debug builds, we could add a null check assertion.
    fn emitUnwrapPtr(self: *Emitter, call: *ast.Call) EmitError!llvm.ValueRef {
        if (call.args.len != 1) {
            return llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        }
        // Just return the pointer - semantically COptPtr and CPtr have the same representation.
        // The safety check should have been done by the programmer.
        return try self.emitExpr(call.args[0]);
    }

    /// Emit read(ptr: CPtr[T]) -> T
    /// Loads the value at the pointer location.
    fn emitRead(self: *Emitter, call: *ast.Call) EmitError!llvm.ValueRef {
        if (call.args.len != 1) {
            return llvm.Const.int32(self.ctx, 0);
        }
        const ptr = try self.emitExpr(call.args[0]);

        // Get the type that the pointer points to from the type checker
        const pointed_to_type = self.getPointedToType(call.args[0]);
        const llvm_type = self.typeToLLVM(pointed_to_type);

        return self.builder.buildLoad(llvm_type, ptr, "ptr.read");
    }

    /// Emit write(ptr: CPtr[T], value: T) -> void
    /// Stores the value at the pointer location.
    fn emitWrite(self: *Emitter, call: *ast.Call) EmitError!llvm.ValueRef {
        if (call.args.len != 2) {
            // Return void (undef)
            return llvm.c.LLVMGetUndef(llvm.Types.void_(self.ctx));
        }
        const ptr = try self.emitExpr(call.args[0]);
        const value = try self.emitExpr(call.args[1]);

        _ = self.builder.buildStore(value, ptr);
        // Return void (represented as undef in LLVM IR)
        return llvm.c.LLVMGetUndef(llvm.Types.void_(self.ctx));
    }

    /// Emit offset(ptr: CPtr[T], count: isize) -> CPtr[T]
    /// Returns a pointer offset by count elements.
    fn emitOffset(self: *Emitter, call: *ast.Call) EmitError!llvm.ValueRef {
        if (call.args.len != 2) {
            return llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        }
        const ptr = try self.emitExpr(call.args[0]);
        const count = try self.emitExpr(call.args[1]);

        // Get the type that the pointer points to for proper stride calculation
        const pointed_to_type = self.getPointedToType(call.args[0]);
        const llvm_type = self.typeToLLVM(pointed_to_type);

        // Use getelementptr to do pointer arithmetic
        var indices = [_]llvm.ValueRef{count};
        return llvm.c.LLVMBuildGEP2(self.builder.ref, llvm_type, ptr, &indices, 1, "ptr.offset");
    }

    /// Emit ref_to_ptr(value: ref T) -> CPtr[T]
    /// Converts a Klar reference to a raw pointer.
    fn emitRefToPtr(self: *Emitter, call: *ast.Call) EmitError!llvm.ValueRef {
        if (call.args.len != 1) {
            return llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        }
        // A reference in Klar is already a pointer at the LLVM level
        // So we just emit the expression and return it
        return try self.emitExpr(call.args[0]);
    }

    fn emitPtrCast(self: *Emitter, call: *ast.Call) EmitError!llvm.ValueRef {
        if (call.args.len != 1) {
            return llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        }
        // With LLVM opaque pointers, ptr_cast is a no-op at the IR level.
        // The pointer value stays the same, only the semantic type changes.
        // The type checker has already validated the cast and determined the result type.
        return try self.emitExpr(call.args[0]);
    }

    /// Get the pointed-to type from a CPtr expression.
    /// Uses stored semantic type or type checker to look up the actual type.
    fn getPointedToType(self: *Emitter, expr: ast.Expr) types.Type {
        // First, try to get the type from named_values if this is an identifier
        if (expr == .identifier) {
            const id = expr.identifier;
            if (self.named_values.get(id.name)) |local| {
                if (local.semantic_type) |sem_type| {
                    if (sem_type == .cptr) {
                        return sem_type.cptr.inner;
                    } else if (sem_type == .copt_ptr) {
                        return sem_type.copt_ptr.inner;
                    }
                }
            }
        }

        // Fallback: try the type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .cptr) {
                return expr_type.cptr.inner;
            } else if (expr_type == .copt_ptr) {
                return expr_type.copt_ptr.inner;
            }
        }
        // Fallback to i8 if we can't determine the type
        return types.Type{ .primitive = .i8_ };
    }

    fn getOrDeclareStrlen(self: *Emitter) llvm.ValueRef {
        const fn_name = "strlen";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // size_t strlen(const char *s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const size_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(size_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Declare strstr if not already declared.
    fn getOrDeclareStrstr(self: *Emitter) llvm.ValueRef {
        const fn_name = "strstr";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // char *strstr(const char *haystack, const char *needle)
        const ptr_type = llvm.Types.pointer(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 2, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Declare strncmp if not already declared.
    fn getOrDeclareStrncmp(self: *Emitter) llvm.ValueRef {
        const fn_name = "strncmp";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int strncmp(const char *s1, const char *s2, size_t n)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const size_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type, size_type };
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Check if an expression is a string type.
    /// Checks string literals directly and uses named_values for identifiers.
    fn isStringExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .literal => |lit| {
                // String literals are always string type
                return lit.kind == .string;
            },
            .identifier => |id| {
                // Check if we have type info for this identifier in named_values
                if (self.named_values.get(id.name)) |local| {
                    // Check if the LLVM type is a pointer (strings are pointers)
                    // and we've marked this as a string type
                    if (local.is_string) {
                        return true;
                    }
                }
                // Fallback: use type checker if available
                if (self.type_checker) |tc| {
                    // We need to cast away const since checkExpr modifies internal state
                    // This is safe because the type checker has already processed the AST
                    const tc_mut = @constCast(tc);
                    const expr_type = tc_mut.checkExpr(expr);
                    return expr_type == .primitive and expr_type.primitive == .string_;
                }
                return false;
            },
            .interpolated_string => {
                // Interpolated strings are always string type
                return true;
            },
            .method_call => |m| {
                // If the method returns a string (like trim, to_uppercase, etc.),
                // the result is a string
                if (std.mem.eql(u8, m.method_name, "trim") or
                    std.mem.eql(u8, m.method_name, "to_uppercase") or
                    std.mem.eql(u8, m.method_name, "to_lowercase"))
                {
                    // Only if the object is also a string
                    return self.isStringExpr(m.object);
                }
                return false;
            },
            .field => |f| {
                // Field access on a struct - look up the struct's field type
                if (f.object == .identifier) {
                    const obj_id = f.object.identifier;
                    if (self.named_values.get(obj_id.name)) |local| {
                        if (local.struct_type_name) |struct_name| {
                            // Look up the struct type in the type checker's registered structs
                            if (self.type_checker) |tc| {
                                // First check generic struct definitions (non-generic structs)
                                for (tc.generic_struct_types.items) |struct_type| {
                                    if (std.mem.eql(u8, struct_type.name, struct_name)) {
                                        // Found the struct - look up the field
                                        for (struct_type.fields) |field| {
                                            if (std.mem.eql(u8, field.name, f.field_name)) {
                                                return field.type_ == .primitive and field.type_.primitive == .string_;
                                            }
                                        }
                                    }
                                }
                                // Then check monomorphized struct instances (for generic structs like Container$i32)
                                for (tc.monomorphized_structs.items) |mono| {
                                    if (std.mem.eql(u8, mono.mangled_name, struct_name)) {
                                        // Found the monomorphized struct - look up the field
                                        for (mono.concrete_type.fields) |field| {
                                            if (std.mem.eql(u8, field.name, f.field_name)) {
                                                return field.type_ == .primitive and field.type_.primitive == .string_;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            },
            else => {
                // For other expressions, use type checker if available
                if (self.type_checker) |tc| {
                    const tc_mut = @constCast(tc);
                    const expr_type = tc_mut.checkExpr(expr);
                    return expr_type == .primitive and expr_type.primitive == .string_;
                }
                return false;
            },
        }
    }

    /// Check if an expression is a slice type (dynamic array without fixed size).
    /// Slices are represented as { ptr, len } structs and require runtime length checks.
    fn isSliceExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    // A slice is an array type without a fixed size
                    if (local.is_array and local.array_size == null) {
                        return true;
                    }
                }
            },
            .field => |f| {
                // For field access, check the field type in the struct
                // Get the struct type from the object expression
                if (f.object == .identifier) {
                    if (self.named_values.get(f.object.identifier.name)) |local| {
                        if (local.struct_type_name) |struct_name| {
                            if (self.getFieldType(struct_name, f.field_name)) |field_type| {
                                return field_type == .slice;
                            }
                        }
                    }
                }
                // Fallthrough to type checker
            },
            else => {},
        }
        // Fallback: use type checker if available
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            return expr_type == .slice;
        }
        return false;
    }

    /// Check if an expression is an array or slice type.
    /// Both fixed-size arrays and dynamic slices are handled by the same method implementations.
    fn isArrayExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                // Check if we have array info for this identifier in named_values
                if (self.named_values.get(id.name)) |local| {
                    // Include both fixed-size arrays (array_size != null) and slices (array_size == null)
                    if (local.is_array) {
                        return true;
                    }
                }
            },
            .array_literal => {
                // Array literals are always fixed-size array type
                return true;
            },
            else => {},
        }
        // Fallback: use type checker if available (may not work during emission)
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            return expr_type == .array or expr_type == .slice;
        }
        return false;
    }

    /// Check if an expression is an integer type.
    fn isIntegerExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .literal => |lit| {
                return lit.kind == .int;
            },
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    // Check if the LLVM type is an integer type
                    const kind = llvm.getTypeKind(local.ty);
                    return kind == llvm.c.LLVMIntegerTypeKind;
                }
                return false;
            },
            .field => |f| {
                // For field access, check the field type in the struct
                if (f.object == .identifier) {
                    if (self.named_values.get(f.object.identifier.name)) |local| {
                        if (local.struct_type_name) |struct_name| {
                            if (self.getFieldType(struct_name, f.field_name)) |field_type| {
                                return field_type.isInteger();
                            }
                        }
                    }
                }
                // Fall through to type checker at end
            },
            .binary, .unary => {
                // Use type checker to determine if result is integer
                if (self.type_checker) |tc| {
                    const tc_mut = @constCast(tc);
                    const expr_type = tc_mut.checkExpr(expr);
                    return expr_type.isInteger();
                }
                return false;
            },
            .method_call => |m| {
                // Methods like abs, min, max on integers return integers
                if (std.mem.eql(u8, m.method_name, "abs") or
                    std.mem.eql(u8, m.method_name, "min") or
                    std.mem.eql(u8, m.method_name, "max"))
                {
                    return self.isIntegerExpr(m.object);
                }
                // .len() on arrays/slices/lists/strings always returns i32
                if (std.mem.eql(u8, m.method_name, "len")) {
                    return true;
                }
                return false;
            },
            else => {},
        }
        // Fallback: use type checker if available
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            return expr_type.isInteger();
        }
        return false;
    }

    /// Check if an expression is a char type.
    fn isCharExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .literal => |lit| {
                return lit.kind == .char;
            },
            .identifier => |id| {
                // Check stored semantic type in named_values
                if (self.named_values.get(id.name)) |local| {
                    if (local.semantic_type) |st| {
                        return st == .primitive and st.primitive == .char_;
                    }
                }
                // Fallback: use type checker
                if (self.type_checker) |tc| {
                    const tc_mut = @constCast(tc);
                    const expr_type = tc_mut.checkExpr(expr);
                    return expr_type == .primitive and expr_type.primitive == .char_;
                }
                return false;
            },
            .method_call => |m| {
                // Methods like to_lowercase, to_uppercase on chars return chars
                if (std.mem.eql(u8, m.method_name, "to_lowercase") or
                    std.mem.eql(u8, m.method_name, "to_uppercase"))
                {
                    return self.isCharExpr(m.object);
                }
                return false;
            },
            else => {},
        }
        // Fallback: use type checker if available
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            return expr_type == .primitive and expr_type.primitive == .char_;
        }
        return false;
    }

    /// Check if an expression is a Range type.
    fn isRangeExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .range => return true,
            .identifier => |id| {
                // Check the stored LLVM type from named_values
                if (self.named_values.get(id.name)) |local| {
                    return self.isRangeType(local.ty);
                }
                return false;
            },
            else => {
                // For other expressions, check via emitted type
                // This handles method chains and other complex expressions
                return false;
            },
        }
    }

    /// Check if an LLVM type is a Range type by checking its structure.
    /// Range has layout: { i32, i32, i32, i1 } (start, end, current, inclusive)
    fn isRangeType(self: *Emitter, ty: llvm.TypeRef) bool {
        _ = self;
        const type_kind = llvm.getTypeKind(ty);
        if (type_kind != llvm.c.LLVMStructTypeKind) return false;

        // Range struct has exactly 4 fields: i32, i32, i32, i1
        const num_fields = llvm.c.LLVMCountStructElementTypes(ty);
        if (num_fields != 4) return false;

        // Check field types
        const field0 = llvm.c.LLVMStructGetTypeAtIndex(ty, 0);
        const field1 = llvm.c.LLVMStructGetTypeAtIndex(ty, 1);
        const field2 = llvm.c.LLVMStructGetTypeAtIndex(ty, 2);
        const field3 = llvm.c.LLVMStructGetTypeAtIndex(ty, 3);

        // Fields 0-2 should be i32, field 3 should be i1
        const kind0 = llvm.getTypeKind(field0);
        const kind1 = llvm.getTypeKind(field1);
        const kind2 = llvm.getTypeKind(field2);
        const kind3 = llvm.getTypeKind(field3);

        if (kind0 != llvm.c.LLVMIntegerTypeKind or kind1 != llvm.c.LLVMIntegerTypeKind or
            kind2 != llvm.c.LLVMIntegerTypeKind or kind3 != llvm.c.LLVMIntegerTypeKind)
        {
            return false;
        }

        // Check bit widths: first 3 should be 32, last should be 1
        const width0 = llvm.c.LLVMGetIntTypeWidth(field0);
        const width1 = llvm.c.LLVMGetIntTypeWidth(field1);
        const width2 = llvm.c.LLVMGetIntTypeWidth(field2);
        const width3 = llvm.c.LLVMGetIntTypeWidth(field3);

        return width0 == 32 and width1 == 32 and width2 == 32 and width3 == 1;
    }

    /// Check if an expression is a List type.
    fn isListExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                // Check the stored LLVM type structure
                if (self.named_values.get(id.name)) |local| {
                    // Exclude String types - String and List have same LLVM structure
                    // but String has is_string_data flag set
                    if (local.is_string_data) {
                        return false;
                    }
                    // Check LLVM type structure first
                    if (self.isListType(local.ty)) {
                        return true;
                    }
                    // Fallback: check via type checker
                    if (self.type_checker) |tc| {
                        const tc_mut = @constCast(tc);
                        const expr_type = tc_mut.checkExpr(expr);
                        return expr_type == .list;
                    }
                }
                return false;
            },
            else => {
                // For other expressions, check via type checker
                if (self.type_checker) |tc| {
                    const tc_mut = @constCast(tc);
                    const expr_type = tc_mut.checkExpr(expr);
                    return expr_type == .list;
                }
                return false;
            },
        }
    }

    /// Check if an LLVM type is a List type by checking its structure.
    /// List has layout: { ptr, i32, i32 } (ptr, len, capacity)
    fn isListType(self: *Emitter, ty: llvm.TypeRef) bool {
        _ = self;
        const type_kind = llvm.getTypeKind(ty);
        if (type_kind != llvm.c.LLVMStructTypeKind) return false;

        // List struct has exactly 3 fields: ptr, i32, i32
        const num_fields = llvm.c.LLVMCountStructElementTypes(ty);
        if (num_fields != 3) return false;

        // Check field types
        const field0 = llvm.c.LLVMStructGetTypeAtIndex(ty, 0);
        const field1 = llvm.c.LLVMStructGetTypeAtIndex(ty, 1);
        const field2 = llvm.c.LLVMStructGetTypeAtIndex(ty, 2);

        // Field 0 should be pointer, fields 1-2 should be i32
        const kind0 = llvm.getTypeKind(field0);
        const kind1 = llvm.getTypeKind(field1);
        const kind2 = llvm.getTypeKind(field2);

        if (kind0 != llvm.c.LLVMPointerTypeKind) return false;
        if (kind1 != llvm.c.LLVMIntegerTypeKind or kind2 != llvm.c.LLVMIntegerTypeKind) return false;

        // Check bit widths: should be 32
        const width1 = llvm.c.LLVMGetIntTypeWidth(field1);
        const width2 = llvm.c.LLVMGetIntTypeWidth(field2);

        return width1 == 32 and width2 == 32;
    }

    /// Check if an expression is a Map type.
    fn isMapExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                // Check the stored is_map flag
                if (self.named_values.get(id.name)) |local| {
                    // Check is_set first - Set has same LLVM layout as Map
                    if (local.is_set) {
                        return false;
                    }
                    if (local.is_map) {
                        return true;
                    }
                    // Structural check: Map has 4 fields { ptr, i32, i32, i32 }
                    // This catches pattern-bound Map variables where is_map flag wasn't set
                    if (local.ty != null and self.isMapType(local.ty.?)) {
                        // Type checker fallback to distinguish Map from Set (same structure)
                        if (self.type_checker) |tc| {
                            const tc_mut = @constCast(tc);
                            const expr_type = tc_mut.checkExpr(expr);
                            // If type checker says it's a set, it's not a map
                            if (expr_type == .set) {
                                return false;
                            }
                            // If type checker says it's a map or is inconclusive, trust structural check
                            return true;
                        }
                        // No type checker - trust structural check
                        return true;
                    }
                    // Final fallback: check via type checker
                    if (self.type_checker) |tc| {
                        const tc_mut = @constCast(tc);
                        const expr_type = tc_mut.checkExpr(expr);
                        return expr_type == .map;
                    }
                }
                return false;
            },
            else => {
                // For other expressions, check via type checker
                if (self.type_checker) |tc| {
                    const tc_mut = @constCast(tc);
                    const expr_type = tc_mut.checkExpr(expr);
                    return expr_type == .map;
                }
                return false;
            },
        }
    }

    /// Check if an LLVM type is a Map type by checking its structure.
    /// Map has layout: { ptr, i32, i32, i32 } (entries, len, capacity, tombstone_count)
    fn isMapType(self: *Emitter, ty: llvm.TypeRef) bool {
        _ = self;
        const type_kind = llvm.getTypeKind(ty);
        if (type_kind != llvm.c.LLVMStructTypeKind) return false;

        // Map struct has exactly 4 fields: ptr, i32, i32, i32
        const num_fields = llvm.c.LLVMCountStructElementTypes(ty);
        if (num_fields != 4) return false;

        // Check field types
        const field0 = llvm.c.LLVMStructGetTypeAtIndex(ty, 0);
        const field1 = llvm.c.LLVMStructGetTypeAtIndex(ty, 1);
        const field2 = llvm.c.LLVMStructGetTypeAtIndex(ty, 2);
        const field3 = llvm.c.LLVMStructGetTypeAtIndex(ty, 3);

        // Field 0 should be pointer, fields 1-3 should be i32
        const kind0 = llvm.getTypeKind(field0);
        const kind1 = llvm.getTypeKind(field1);
        const kind2 = llvm.getTypeKind(field2);
        const kind3 = llvm.getTypeKind(field3);

        if (kind0 != llvm.c.LLVMPointerTypeKind) return false;
        if (kind1 != llvm.c.LLVMIntegerTypeKind) return false;
        if (kind2 != llvm.c.LLVMIntegerTypeKind) return false;
        if (kind3 != llvm.c.LLVMIntegerTypeKind) return false;

        // Check bit widths: should be 32
        const width1 = llvm.c.LLVMGetIntTypeWidth(field1);
        const width2 = llvm.c.LLVMGetIntTypeWidth(field2);
        const width3 = llvm.c.LLVMGetIntTypeWidth(field3);

        return width1 == 32 and width2 == 32 and width3 == 32;
    }

    /// Check if an expression is a Set type.
    fn isSetExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                // Check the stored is_set flag
                if (self.named_values.get(id.name)) |local| {
                    if (local.is_set) {
                        return true;
                    }
                    // Fallback: check via type checker
                    if (self.type_checker) |tc| {
                        const tc_mut = @constCast(tc);
                        const expr_type = tc_mut.checkExpr(expr);
                        return expr_type == .set;
                    }
                }
                return false;
            },
            else => {
                // For other expressions, check via type checker
                if (self.type_checker) |tc| {
                    const tc_mut = @constCast(tc);
                    const expr_type = tc_mut.checkExpr(expr);
                    return expr_type == .set;
                }
                return false;
            },
        }
    }

    /// Get the element type from a Set expression.
    fn getSetElementType(self: *Emitter, expr: ast.Expr) ?types.Type {
        // First check stored type info
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.set_element_type) |elem_type| {
                        return elem_type;
                    }
                }
            },
            else => {},
        }
        // Fallback: check via type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .set) {
                return expr_type.set.element;
            }
        }
        return null;
    }

    /// Get a pointer to a Set argument (for methods that take Set as argument).
    /// If the argument is a variable, returns its alloca pointer.
    /// Otherwise, emits the value and stores it in a temporary alloca.
    fn getSetArgPtr(self: *Emitter, arg: ast.Expr) EmitError!llvm.ValueRef {
        // If it's an identifier, get the alloca pointer directly
        switch (arg) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    return local.value; // This is the alloca pointer
                }
            },
            else => {},
        }
        // Otherwise, emit the value and store in a temporary alloca
        const set_type = self.getSetStructType();
        const value = try self.emitExpr(arg);
        const temp_alloca = self.builder.buildAlloca(set_type, "set_arg_tmp");
        _ = self.builder.buildStore(value, temp_alloca);
        return temp_alloca;
    }

    /// Check if an expression is a File type.
    fn isFileExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    return local.is_file;
                }
            },
            else => {},
        }
        return false;
    }

    /// Check if an expression is a Stdout type.
    fn isStdoutExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    return local.is_stdout;
                }
            },
            else => {},
        }
        return false;
    }

    /// Check if an expression is a Stderr type.
    fn isStderrExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    return local.is_stderr;
                }
            },
            else => {},
        }
        return false;
    }

    /// Check if an expression is a Stdin type.
    fn isStdinExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    return local.is_stdin;
                }
            },
            else => {},
        }
        return false;
    }

    /// Check if an expression is a BufReader type.
    fn isBufReaderExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    return local.is_buf_reader;
                }
            },
            else => {},
        }
        return false;
    }

    /// Check if an expression is a BufWriter type.
    fn isBufWriterExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    return local.is_buf_writer;
                }
            },
            else => {},
        }
        return false;
    }

    /// Check if an expression is a String (heap-allocated) type.
    fn isStringDataExpr(self: *Emitter, expr: ast.Expr) bool {
        switch (expr) {
            // Check if this is an identifier with stored is_string_data flag
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.is_string_data) {
                        return true;
                    }
                }
            },
            // Check for String static constructors and String-returning methods
            .method_call => |mc| {
                // String static methods: String.new(), String.from(), String.with_capacity()
                if (mc.object == .identifier) {
                    const name = mc.object.identifier.name;
                    if (std.mem.eql(u8, name, "String")) {
                        if (std.mem.eql(u8, mc.method_name, "new") or
                            std.mem.eql(u8, mc.method_name, "from") or
                            std.mem.eql(u8, mc.method_name, "with_capacity"))
                        {
                            return true;
                        }
                    }
                }
                // String instance methods that return String: concat(), clone()
                if (self.isStringDataExpr(mc.object)) {
                    if (std.mem.eql(u8, mc.method_name, "concat") or
                        std.mem.eql(u8, mc.method_name, "clone"))
                    {
                        return true;
                    }
                }
            },
            else => {},
        }
        // Fallback: check via type checker (for non-identifier expressions)
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            return expr_type == .string_data;
        }
        return false;
    }

    /// Check if an expression is a CStr (FFI: null-terminated C string) type.
    fn isCstrExpr(self: *Emitter, expr: ast.Expr) bool {
        // Check for method call that returns CStr (like as_cstr)
        if (expr == .method_call) {
            const m = expr.method_call;
            if (std.mem.eql(u8, m.method_name, "as_cstr")) {
                return false; // This returns CStr but the object is not CStr
            }
            if (std.mem.eql(u8, m.method_name, "from_ptr")) {
                return false; // This returns CStr but the object is CStr type identifier
            }
        }
        // Check for identifier with CStr semantic type
        if (expr == .identifier) {
            if (self.named_values.get(expr.identifier.name)) |local| {
                if (local.semantic_type) |sem| {
                    return sem == .cstr;
                }
            }
        }
        // Fallback: check via type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            return expr_type == .cstr;
        }
        return false;
    }

    /// Check if an expression is a CStrOwned (FFI: owned null-terminated C string) type.
    fn isCstrOwnedExpr(self: *Emitter, expr: ast.Expr) bool {
        // Check for method call that returns CStrOwned (like to_cstr)
        if (expr == .method_call) {
            const m = expr.method_call;
            if (std.mem.eql(u8, m.method_name, "to_cstr")) {
                return true; // to_cstr() returns CStrOwned
            }
        }
        // Check for identifier with CStrOwned semantic type
        if (expr == .identifier) {
            if (self.named_values.get(expr.identifier.name)) |local| {
                if (local.semantic_type) |sem| {
                    return sem == .cstr_owned;
                }
            }
        }
        // Fallback: check via type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            return expr_type == .cstr_owned;
        }
        return false;
    }

    /// Check if an expression is a primitive string (string literal) type.
    fn isPrimitiveStringExpr(self: *Emitter, expr: ast.Expr) bool {
        // Check for string literal directly
        if (expr == .literal and expr.literal.kind == .string) {
            return true;
        }
        // Check for identifier with is_string flag
        if (expr == .identifier) {
            if (self.named_values.get(expr.identifier.name)) |local| {
                if (local.is_string) {
                    return true;
                }
            }
        }
        // Fallback: check via type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            return expr_type == .primitive and expr_type.primitive == .string_;
        }
        return false;
    }

    /// Get the element type for a List expression.
    fn getListElementType(self: *Emitter, expr: ast.Expr) ?types.Type {
        // First check if this is an identifier with stored list element type
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.list_element_type) |elem_type| {
                        return elem_type;
                    }
                }
            },
            else => {},
        }
        // Fallback: use type checker to get the list element type
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .list) {
                return expr_type.list.element;
            }
        }
        return null;
    }

    /// Get Map key type from an expression.
    fn getMapKeyType(self: *Emitter, expr: ast.Expr) ?types.Type {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.map_key_type) |key_type| {
                        return key_type;
                    }
                }
            },
            else => {},
        }
        // Fallback: use type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .map) {
                return expr_type.map.key;
            }
        }
        return null;
    }

    /// Get Map value type from an expression.
    fn getMapValueType(self: *Emitter, expr: ast.Expr) ?types.Type {
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.map_value_type) |value_type| {
                        return value_type;
                    }
                }
            },
            else => {},
        }
        // Fallback: use type checker
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .map) {
                return expr_type.map.value;
            }
        }
        return null;
    }

    /// Get array element type from an expression.
    fn getArrayElementType(self: *Emitter, expr: ast.Expr) ?types.Type {
        // First check named_values for identifiers
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.is_array) {
                        return local.array_element_type;
                    }
                }
            },
            else => {},
        }
        // Fallback: use type checker if available
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .array) {
                return expr_type.array.element;
            }
            if (expr_type == .slice) {
                return expr_type.slice.element;
            }
        }
        return null;
    }

    /// Get array length from an expression (for fixed-size arrays).
    fn getArraySize(self: *Emitter, expr: ast.Expr) ?usize {
        // First check named_values for identifiers
        switch (expr) {
            .identifier => |id| {
                if (self.named_values.get(id.name)) |local| {
                    if (local.is_array) {
                        return local.array_size; // null for slices
                    }
                }
            },
            else => {},
        }
        // Fallback: use type checker if available
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            const expr_type = tc_mut.checkExpr(expr);
            if (expr_type == .array) {
                return expr_type.array.size;
            }
        }
        return null;
    }

    /// Emit string.len() - returns length as i32.
    fn emitStringLen(self: *Emitter, str: llvm.ValueRef) EmitError!llvm.ValueRef {
        const strlen_fn = self.getOrDeclareStrlen();
        var args = [_]llvm.ValueRef{str};
        const len_i64 = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &args, "strlen");
        // Truncate from size_t (i64) to i32
        const i32_type = llvm.Types.int32(self.ctx);
        return llvm.c.LLVMBuildTrunc(self.builder.ref, len_i64, i32_type, "strlen_i32");
    }

    /// Emit string.is_empty() - returns true if len == 0.
    fn emitStringIsEmpty(self: *Emitter, str: llvm.ValueRef) EmitError!llvm.ValueRef {
        const strlen_fn = self.getOrDeclareStrlen();
        var args = [_]llvm.ValueRef{str};
        const len = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &args, "strlen");
        // Compare len == 0
        const zero = llvm.Const.int64(self.ctx, 0);
        return self.builder.buildICmp(llvm.c.LLVMIntEQ, len, zero, "is_empty");
    }

    /// Emit string.contains(pattern) - returns true if pattern is found in string.
    fn emitStringContains(self: *Emitter, str: llvm.ValueRef, pattern: llvm.ValueRef) EmitError!llvm.ValueRef {
        const strstr_fn = self.getOrDeclareStrstr();
        var args = [_]llvm.ValueRef{ str, pattern };
        const result = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strstr_fn), strstr_fn, &args, "strstr");
        // strstr returns NULL if not found, non-NULL if found
        const null_ptr = llvm.c.LLVMConstPointerNull(llvm.Types.pointer(self.ctx));
        return self.builder.buildICmp(llvm.c.LLVMIntNE, result, null_ptr, "contains");
    }

    /// Emit string.starts_with(prefix) - returns true if string starts with prefix.
    fn emitStringStartsWith(self: *Emitter, str: llvm.ValueRef, prefix: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Get the length of the prefix
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{prefix};
        const prefix_len = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &strlen_args, "prefix_len");

        // Compare using strncmp(str, prefix, prefix_len) == 0
        const strncmp_fn = self.getOrDeclareStrncmp();
        var strncmp_args = [_]llvm.ValueRef{ str, prefix, prefix_len };
        const cmp_result = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strncmp_fn), strncmp_fn, &strncmp_args, "strncmp");

        const zero = llvm.Const.int32(self.ctx, 0);
        return self.builder.buildICmp(llvm.c.LLVMIntEQ, cmp_result, zero, "starts_with");
    }

    /// Emit string.ends_with(suffix) - returns true if string ends with suffix.
    fn emitStringEndsWith(self: *Emitter, str: llvm.ValueRef, suffix: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Get the lengths
        const strlen_fn = self.getOrDeclareStrlen();

        var str_args = [_]llvm.ValueRef{str};
        const str_len = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &str_args, "str_len");

        var suffix_args = [_]llvm.ValueRef{suffix};
        const suffix_len = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &suffix_args, "suffix_len");

        // Check if suffix is longer than string (would be false)
        const suffix_longer = self.builder.buildICmp(llvm.c.LLVMIntUGT, suffix_len, str_len, "suffix_longer");

        // Calculate offset = str_len - suffix_len
        const offset = llvm.c.LLVMBuildSub(self.builder.ref, str_len, suffix_len, "offset");

        // Get pointer to end of string: str + offset
        const i8_type = llvm.Types.int8(self.ctx);
        var indices = [_]llvm.ValueRef{offset};
        const end_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, str, &indices, 1, "end_ptr");

        // Compare using strcmp(end_ptr, suffix) == 0
        const strcmp_fn = self.getOrDeclareStrcmp();
        var strcmp_args = [_]llvm.ValueRef{ end_ptr, suffix };
        const cmp_result = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strcmp_fn), strcmp_fn, &strcmp_args, "strcmp");

        const zero = llvm.Const.int32(self.ctx, 0);
        const ends_match = self.builder.buildICmp(llvm.c.LLVMIntEQ, cmp_result, zero, "ends_match");

        // Result: !suffix_longer && ends_match
        const suffix_not_longer = llvm.c.LLVMBuildNot(self.builder.ref, suffix_longer, "suffix_not_longer");
        return self.builder.buildAnd(suffix_not_longer, ends_match, "ends_with");
    }

    /// Emit string.trim() - returns a new string with leading/trailing whitespace removed.
    /// Calls the klar_string_trim runtime function.
    fn emitStringTrim(self: *Emitter, str: llvm.ValueRef) EmitError!llvm.ValueRef {
        const trim_fn = self.getOrDeclareStringTrim();
        var args = [_]llvm.ValueRef{str};
        return llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(trim_fn),
            trim_fn,
            &args,
            1,
            "trimmed",
        );
    }

    /// Emit string.to_uppercase() - returns a new string with all characters uppercased.
    /// Calls the klar_string_to_uppercase runtime function.
    fn emitStringToUppercase(self: *Emitter, str: llvm.ValueRef) EmitError!llvm.ValueRef {
        const upper_fn = self.getOrDeclareStringToUppercase();
        var args = [_]llvm.ValueRef{str};
        return llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(upper_fn),
            upper_fn,
            &args,
            1,
            "uppercased",
        );
    }

    /// Emit string.to_lowercase() - returns a new string with all characters lowercased.
    /// Calls the klar_string_to_lowercase runtime function.
    fn emitStringToLowercase(self: *Emitter, str: llvm.ValueRef) EmitError!llvm.ValueRef {
        const lower_fn = self.getOrDeclareStringToLowercase();
        var args = [_]llvm.ValueRef{str};
        return llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(lower_fn),
            lower_fn,
            &args,
            1,
            "lowercased",
        );
    }

    /// Emit string.bytes() - returns a slice of u8 containing the string's bytes.
    /// The slice points directly to the string's data (no allocation).
    fn emitStringBytes(self: *Emitter, str: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Get the string length using strlen
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{str};
        const len = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(strlen_fn),
            strlen_fn,
            &strlen_args,
            1,
            "str.len",
        );

        // Create a slice struct type: { ptr, i64 }
        var slice_fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx), // data pointer
            llvm.Types.int64(self.ctx), // length
        };
        const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);

        // Build the slice struct value using alloca + store + load pattern
        const slice_ptr = self.builder.buildAlloca(slice_type, "bytes_slice_ptr");

        // Store pointer field (index 0)
        const ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, slice_ptr, 0, "ptr_field");
        _ = self.builder.buildStore(str, ptr_field);

        // Store length field (index 1)
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, slice_ptr, 1, "len_field");
        _ = self.builder.buildStore(len, len_field);

        // Load the complete slice struct
        return self.builder.buildLoad(slice_type, slice_ptr, "bytes_slice");
    }

    /// Emit string.chars() - returns a slice of char containing the string's unicode codepoints.
    /// This calls a runtime function that decodes UTF-8 and allocates the result.
    fn emitStringChars(self: *Emitter, str: llvm.ValueRef) EmitError!llvm.ValueRef {
        const chars_fn = self.getOrDeclareStringChars();
        var args = [_]llvm.ValueRef{str};
        return llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(chars_fn),
            chars_fn,
            &args,
            1,
            "chars_slice",
        );
    }

    /// Emit string.slice(start, end) - extract substring with clamping.
    /// Calls the klar_string_slice runtime function.
    fn emitStringSlice(self: *Emitter, str: llvm.ValueRef, start: llvm.ValueRef, end: llvm.ValueRef) EmitError!llvm.ValueRef {
        const slice_fn = self.getOrDeclareStringSlice();
        // Convert start and end to i64 if necessary
        const i64_type = llvm.Types.int64(self.ctx);
        const start_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, start, i64_type, "start_i64");
        const end_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, end, i64_type, "end_i64");
        var args = [_]llvm.ValueRef{ str, start_i64, end_i64 };
        return llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(slice_fn),
            slice_fn,
            &args,
            3,
            "sliced",
        );
    }

    // ========================================================================
    // Integer Methods
    // ========================================================================

    /// Emit integer.abs() - returns absolute value.
    /// For signed integers, computes abs(x) = x < 0 ? -x : x
    /// For unsigned integers, just returns x.
    fn emitIntAbs(self: *Emitter, value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const value_type = llvm.typeOf(value);
        const bit_width = llvm.c.LLVMGetIntTypeWidth(value_type);

        // Check if this is a signed type by seeing if it's a standard signed width
        // Klar uses i8, i16, i32, i64 for signed and u8, u16, u32, u64 for unsigned
        // We can't directly tell from LLVM, so we check if the type checker says signed
        // For now, we'll assume it could be signed and compute abs safely

        // Create zero constant for comparison
        const zero = llvm.c.LLVMConstInt(value_type, 0, 0);

        // Check if value < 0 (signed comparison)
        const is_negative = self.builder.buildICmp(llvm.c.LLVMIntSLT, value, zero, "is_neg");

        // Compute -value using sub(0, value)
        const neg_value = llvm.c.LLVMBuildSub(self.builder.ref, zero, value, "neg");

        // Select: is_negative ? -value : value
        _ = bit_width;
        return llvm.c.LLVMBuildSelect(self.builder.ref, is_negative, neg_value, value, "abs");
    }

    /// Emit integer.min(other) - returns minimum of two values.
    fn emitIntMin(self: *Emitter, a: llvm.ValueRef, b: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Compare a < b (signed comparison)
        const cmp = self.builder.buildICmp(llvm.c.LLVMIntSLT, a, b, "min_cmp");
        // Select: a < b ? a : b
        return llvm.c.LLVMBuildSelect(self.builder.ref, cmp, a, b, "min");
    }

    /// Emit integer.max(other) - returns maximum of two values.
    fn emitIntMax(self: *Emitter, a: llvm.ValueRef, b: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Compare a > b (signed comparison)
        const cmp = self.builder.buildICmp(llvm.c.LLVMIntSGT, a, b, "max_cmp");
        // Select: a > b ? a : b
        return llvm.c.LLVMBuildSelect(self.builder.ref, cmp, a, b, "max");
    }

    /// Emit integer.to_string() - converts integer to String.
    /// Returns a String struct { ptr, len, capacity }.
    fn emitIntToString(self: *Emitter, value: llvm.ValueRef, is_64bit: bool) EmitError!llvm.ValueRef {
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Allocate a stack buffer for snprintf (32 bytes is enough for any integer)
        const buf_size: u32 = 32;
        const buf_type = llvm.c.LLVMArrayType(i8_type, buf_size);
        const buf = self.builder.buildAlloca(buf_type, "tostr.buf");

        // Get pointer to first element
        const zero = llvm.Const.int32(self.ctx, 0);
        var indices = [_]llvm.ValueRef{ zero, zero };
        const buf_ptr = self.builder.buildGEP(buf_type, buf, &indices, "tostr.buf_ptr");

        // Build format string based on integer size
        const fmt_str = if (is_64bit)
            self.builder.buildGlobalStringPtr("%lld", "fmt_i64")
        else
            self.builder.buildGlobalStringPtr("%d", "fmt_i32");

        // Call snprintf(buf, size, format, value)
        const snprintf_fn = self.getOrCreateSnprintfFn();
        const size = llvm.Const.int64(self.ctx, buf_size);
        var snprintf_args = [_]llvm.ValueRef{ buf_ptr, size, fmt_str, value };
        const fn_type = llvm.c.LLVMGlobalGetValueType(snprintf_fn);
        const len_result = self.builder.buildCall(fn_type, snprintf_fn, &snprintf_args, "tostr.len");

        // Extend len to i64 for malloc, add 1 for null terminator
        const len_i64 = self.builder.buildSExt(len_result, i64_type, "tostr.len64");
        const one_i64 = llvm.Const.int64(self.ctx, 1);
        const alloc_size = self.builder.buildAdd(len_i64, one_i64, "tostr.alloc_size");

        // Allocate heap memory for the string
        const malloc_fn = self.getOrCreateMallocFn();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const malloc_type = llvm.c.LLVMGlobalGetValueType(malloc_fn);
        const heap_ptr = self.builder.buildCall(malloc_type, malloc_fn, &malloc_args, "tostr.heap");

        // Copy from stack buffer to heap (including null terminator)
        const memcpy_fn = self.getOrCreateMemcpyFn();
        var memcpy_args = [_]llvm.ValueRef{ heap_ptr, buf_ptr, alloc_size };
        const memcpy_type = llvm.c.LLVMGlobalGetValueType(memcpy_fn);
        _ = self.builder.buildCall(memcpy_type, memcpy_fn, &memcpy_args, "");

        // Build String struct { ptr, len, capacity }
        const string_type = self.getStringStructType();
        const result = self.builder.buildAlloca(string_type, "tostr.result");

        // Store ptr (field 0)
        const ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result, 0, "tostr.ptr_field");
        _ = self.builder.buildStore(heap_ptr, ptr_field);

        // Store len (field 1) - truncate to i32
        const len_i32 = self.builder.buildTrunc(len_i64, i32_type, "tostr.len32");
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result, 1, "tostr.len_field");
        _ = self.builder.buildStore(len_i32, len_field);

        // Store capacity (field 2) - same as len+1 truncated to i32
        const cap_i32 = self.builder.buildTrunc(alloc_size, i32_type, "tostr.cap32");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result, 2, "tostr.cap_field");
        _ = self.builder.buildStore(cap_i32, cap_field);

        // Load and return the struct value
        return self.builder.buildLoad(string_type, result, "tostr.string");
    }

    /// Emit char.to_string() - converts char to primitive string.
    /// Returns a pointer to a null-terminated string containing the single character.
    fn emitCharToString(self: *Emitter, char_val: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i8_type = llvm.Types.int8(self.ctx);

        // Allocate 2 bytes on heap for char + null terminator
        const malloc_fn = self.getOrCreateMallocFn();
        const alloc_size = llvm.Const.int64(self.ctx, 2);
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const malloc_type = llvm.c.LLVMGlobalGetValueType(malloc_fn);
        const heap_ptr = self.builder.buildCall(malloc_type, malloc_fn, &malloc_args, "chartostr.heap");

        // Truncate char (i32 codepoint) to i8
        const char_i8 = llvm.c.LLVMBuildTrunc(self.builder.ref, char_val, i8_type, "chartostr.char_i8");

        // Store the character at index 0
        _ = self.builder.buildStore(char_i8, heap_ptr);

        // Store null terminator at index 1
        const one = llvm.Const.int64(self.ctx, 1);
        var null_indices = [_]llvm.ValueRef{one};
        const null_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, heap_ptr, &null_indices, 1, "chartostr.null_ptr");
        _ = self.builder.buildStore(llvm.Const.int(i8_type, 0, false), null_ptr);

        // Return the pointer (primitive string type)
        return heap_ptr;
    }

    // ========================================================================
    // Range Methods
    // ========================================================================

    /// Emit Range.next() - returns Optional[T], Some(current) and increments, or None if exhausted.
    /// Range layout: { start: T, end: T, current: T, inclusive: i1 }
    fn emitRangeNext(self: *Emitter, range_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i32_type = llvm.Types.int32(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);

        // Build range struct type
        var range_fields = [_]llvm.TypeRef{
            i32_type, // start
            i32_type, // end
            i32_type, // current
            i1_type, // inclusive
        };
        const range_ty = llvm.Types.struct_(self.ctx, &range_fields, false);

        // Load current value
        const current_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 2, "range.current.ptr");
        const current = self.builder.buildLoad(i32_type, current_ptr, "range.current");

        // Load end value
        const end_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 1, "range.end.ptr");
        const end_val = self.builder.buildLoad(i32_type, end_ptr, "range.end");

        // Load inclusive flag
        const inclusive_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 3, "range.inclusive.ptr");
        const inclusive = self.builder.buildLoad(i1_type, inclusive_ptr, "range.inclusive");

        // Build Optional[i32] type: { i1 tag, i32 value }
        var opt_fields = [_]llvm.TypeRef{ i1_type, i32_type };
        const opt_ty = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Create basic blocks for branching
        const func = self.current_function orelse return EmitError.InvalidAST;
        const check_inclusive_bb = llvm.appendBasicBlock(self.ctx, func, "range.check_inclusive");
        const some_bb = llvm.appendBasicBlock(self.ctx, func, "range.some");
        const none_bb = llvm.appendBasicBlock(self.ctx, func, "range.none");
        const merge_bb = llvm.appendBasicBlock(self.ctx, func, "range.merge");

        // Check: current < end (non-inclusive case, always valid check)
        const lt_cmp = self.builder.buildICmp(llvm.c.LLVMIntSLT, current, end_val, "range.lt");
        _ = self.builder.buildCondBr(lt_cmp, some_bb, check_inclusive_bb);

        // Check inclusive case: current == end && inclusive
        self.builder.positionAtEnd(check_inclusive_bb);
        const eq_cmp = self.builder.buildICmp(llvm.c.LLVMIntEQ, current, end_val, "range.eq");
        const in_range = llvm.c.LLVMBuildAnd(self.builder.ref, eq_cmp, inclusive, "range.in_range");
        _ = self.builder.buildCondBr(in_range, some_bb, none_bb);

        // Some case: return Some(current), increment current
        self.builder.positionAtEnd(some_bb);
        // Increment current for next iteration
        const one = llvm.Const.int32(self.ctx, 1);
        const next_current = self.builder.buildAdd(current, one, "range.next_current");
        _ = self.builder.buildStore(next_current, current_ptr);
        // Build Some(current) - allocate, store, load
        const some_alloca = self.builder.buildAlloca(opt_ty, "opt.some");
        const some_tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_ty, some_alloca, 0, "opt.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), some_tag_ptr);
        const some_val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_ty, some_alloca, 1, "opt.val.ptr");
        _ = self.builder.buildStore(current, some_val_ptr);
        const some_result = self.builder.buildLoad(opt_ty, some_alloca, "opt.some");
        _ = self.builder.buildBr(merge_bb);

        // None case: return None
        self.builder.positionAtEnd(none_bb);
        const none_alloca = self.builder.buildAlloca(opt_ty, "opt.none");
        const none_tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_ty, none_alloca, 0, "opt.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), none_tag_ptr);
        const none_val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_ty, none_alloca, 1, "opt.val.ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), none_val_ptr);
        const none_result = self.builder.buildLoad(opt_ty, none_alloca, "opt.none");
        _ = self.builder.buildBr(merge_bb);

        // Merge: phi node to select result
        self.builder.positionAtEnd(merge_bb);
        const phi = llvm.c.LLVMBuildPhi(self.builder.ref, opt_ty, "range.next.result");
        var incoming_values = [_]llvm.ValueRef{ some_result, none_result };
        var incoming_blocks = [_]llvm.BasicBlockRef{ some_bb, none_bb };
        llvm.c.LLVMAddIncoming(phi, &incoming_values, &incoming_blocks, 2);

        return phi;
    }

    /// Emit Range.reset() - resets current to start.
    fn emitRangeReset(self: *Emitter, range_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i32_type = llvm.Types.int32(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);

        // Build range struct type
        var range_fields = [_]llvm.TypeRef{
            i32_type, // start
            i32_type, // end
            i32_type, // current
            i1_type, // inclusive
        };
        const range_ty = llvm.Types.struct_(self.ctx, &range_fields, false);

        // Load start value
        const start_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 0, "range.start.ptr");
        const start_val = self.builder.buildLoad(i32_type, start_ptr, "range.start");

        // Store start into current
        const current_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 2, "range.current.ptr");
        _ = self.builder.buildStore(start_val, current_ptr);

        // Return void (represented as 0 in LLVM for now)
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit Range.is_empty() - returns true if current >= end (or > end for inclusive).
    fn emitRangeIsEmpty(self: *Emitter, range_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i32_type = llvm.Types.int32(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);

        // Build range struct type
        var range_fields = [_]llvm.TypeRef{
            i32_type, // start
            i32_type, // end
            i32_type, // current
            i1_type, // inclusive
        };
        const range_ty = llvm.Types.struct_(self.ctx, &range_fields, false);

        // Load current value
        const current_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 2, "range.current.ptr");
        const current = self.builder.buildLoad(i32_type, current_ptr, "range.current");

        // Load end value
        const end_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 1, "range.end.ptr");
        const end_val = self.builder.buildLoad(i32_type, end_ptr, "range.end");

        // Load inclusive flag
        const inclusive_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 3, "range.inclusive.ptr");
        const inclusive = self.builder.buildLoad(i1_type, inclusive_ptr, "range.inclusive");

        // For non-inclusive: is_empty = current >= end
        // For inclusive: is_empty = current > end
        // Combined: is_empty = (current > end) || (!inclusive && current == end)
        const gt_cmp = self.builder.buildICmp(llvm.c.LLVMIntSGT, current, end_val, "range.gt");
        const eq_cmp = self.builder.buildICmp(llvm.c.LLVMIntEQ, current, end_val, "range.eq");
        const not_inclusive = llvm.c.LLVMBuildNot(self.builder.ref, inclusive, "range.not_incl");
        const eq_and_not_incl = llvm.c.LLVMBuildAnd(self.builder.ref, eq_cmp, not_inclusive, "range.eq_and_not_incl");
        return llvm.c.LLVMBuildOr(self.builder.ref, gt_cmp, eq_and_not_incl, "range.is_empty");
    }

    /// Emit Range.len() - returns remaining count as i32.
    fn emitRangeLen(self: *Emitter, range_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i32_type = llvm.Types.int32(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);

        // Build range struct type
        var range_fields = [_]llvm.TypeRef{
            i32_type, // start
            i32_type, // end
            i32_type, // current
            i1_type, // inclusive
        };
        const range_ty = llvm.Types.struct_(self.ctx, &range_fields, false);

        // Load current value
        const current_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 2, "range.current.ptr");
        const current = self.builder.buildLoad(i32_type, current_ptr, "range.current");

        // Load end value
        const end_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 1, "range.end.ptr");
        const end_val = self.builder.buildLoad(i32_type, end_ptr, "range.end");

        // Load inclusive flag
        const inclusive_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, range_ty, range_ptr, 3, "range.inclusive.ptr");
        const inclusive = self.builder.buildLoad(i1_type, inclusive_ptr, "range.inclusive");

        // len = max(0, end - current + (inclusive ? 1 : 0))
        const diff = self.builder.buildSub(end_val, current, "range.diff");
        const inclusive_ext = llvm.c.LLVMBuildZExt(self.builder.ref, inclusive, i32_type, "range.incl_ext");
        const len_raw = self.builder.buildAdd(diff, inclusive_ext, "range.len_raw");

        // Clamp to 0 if negative
        const zero = llvm.Const.int32(self.ctx, 0);
        const is_neg = self.builder.buildICmp(llvm.c.LLVMIntSLT, len_raw, zero, "range.is_neg");
        return llvm.c.LLVMBuildSelect(self.builder.ref, is_neg, zero, len_raw, "range.len");
    }

    // ========================================================================
    // List Methods
    // ========================================================================

    /// Emit List.new[T]() - creates an empty list.
    /// Returns a List struct initialized to { ptr: null, len: 0, capacity: 0 }
    fn emitListNew(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        _ = method;

        // Build list struct type
        const list_type = self.getListStructType();

        // Create an empty list struct { null, 0, 0 } directly
        const null_ptr = llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        const zero_i32 = llvm.Const.int32(self.ctx, 0);

        // Build constant struct value
        var values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32 };
        return llvm.c.LLVMConstNamedStruct(list_type, &values, 3);
    }

    /// Emit List.with_capacity[T](n) - creates a list with pre-allocated capacity.
    /// Returns a List struct with allocated memory for n elements.
    /// Implemented inline: allocates memory using malloc, returns { ptr, 0, capacity }.
    fn emitListWithCapacity(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        // Get element type from type_args
        const type_args = method.type_args orelse return EmitError.InvalidAST;
        if (type_args.len != 1) return EmitError.InvalidAST;

        // Resolve element type using type checker
        const element_type = if (self.type_checker) |tc| blk: {
            const tc_mut = @constCast(tc);
            break :blk tc_mut.resolveTypeExpr(type_args[0]) catch return EmitError.InvalidAST;
        } else return EmitError.InvalidAST;

        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        // Emit the capacity argument
        if (method.args.len != 1) return EmitError.InvalidAST;
        const capacity = try self.emitExpr(method.args[0]);

        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const list_type = self.getListStructType();

        // Convert capacity to i32 if needed (it could be i64)
        const cap_type = llvm.typeOf(capacity);
        const cap_i32 = if (llvm.c.LLVMGetIntTypeWidth(cap_type) > 32)
            llvm.c.LLVMBuildTrunc(self.builder.ref, capacity, i32_type, "cap_i32")
        else
            capacity;

        // Calculate allocation size: capacity * element_size
        const cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, cap_i32, i64_type, "cap_i64");
        const elem_size_val = llvm.Const.int64(self.ctx, @intCast(element_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, cap_i64, elem_size_val, "alloc_size");

        // Call malloc(size)
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const data_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "list.data_ptr");

        // Build the list struct { ptr, len: 0, capacity }
        const list_alloca = self.builder.buildAlloca(list_type, "list.with_cap");

        // Store ptr (field 0)
        const ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 0, "list.ptr_field");
        _ = self.builder.buildStore(data_ptr, ptr_field);

        // Store len = 0 (field 1)
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 1, "list.len_field");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_field);

        // Store capacity (field 2)
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 2, "list.cap_field");
        _ = self.builder.buildStore(cap_i32, cap_field);

        // Load and return the struct value
        return self.builder.buildLoad(list_type, list_alloca, "list.with_cap_val");
    }

    /// Emit list.len() - returns length as i32.
    /// List layout: { ptr, len, capacity } - len is at index 1.
    fn emitListLen(self: *Emitter, list_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const list_type = self.getListStructType();
        const i32_type = llvm.Types.int32(self.ctx);

        // GEP to the len field (index 1)
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "list.len.ptr");
        return self.builder.buildLoad(i32_type, len_ptr, "list.len");
    }

    /// Emit list.is_empty() - returns true if len == 0.
    fn emitListIsEmpty(self: *Emitter, list_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const len = try self.emitListLen(list_ptr);
        const zero = llvm.Const.int32(self.ctx, 0);
        return self.builder.buildICmp(llvm.c.LLVMIntEQ, len, zero, "list.is_empty");
    }

    /// Emit list.capacity() - returns capacity as i32.
    /// List layout: { ptr, len, capacity } - capacity is at index 2.
    fn emitListCapacity(self: *Emitter, list_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const list_type = self.getListStructType();
        const i32_type = llvm.Types.int32(self.ctx);

        // GEP to the capacity field (index 2)
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 2, "list.cap.ptr");
        return self.builder.buildLoad(i32_type, cap_ptr, "list.capacity");
    }

    /// Emit list.push(value) - adds an element to the list.
    /// Implemented inline: checks capacity, grows if needed, stores value, increments len.
    fn emitListPush(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall, value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get element type info
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Load current ptr, len, capacity
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "push.ptr_ptr");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "push.len_ptr");
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 2, "push.cap_ptr");

        const current_ptr = self.builder.buildLoad(ptr_type, ptr_ptr, "push.current_ptr");
        const current_len = self.builder.buildLoad(i32_type, len_ptr, "push.current_len");
        const current_cap = self.builder.buildLoad(i32_type, cap_ptr, "push.current_cap");

        // Check if we need to grow: len >= capacity
        const need_grow = self.builder.buildICmp(llvm.c.LLVMIntSGE, current_len, current_cap, "push.need_grow");

        // Save the current block BEFORE creating new blocks (for PHI node incoming edge)
        const entry_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Create basic blocks for growth path
        const grow_bb = llvm.appendBasicBlock(self.ctx, func, "push.grow");
        const store_bb = llvm.appendBasicBlock(self.ctx, func, "push.store");

        _ = self.builder.buildCondBr(need_grow, grow_bb, store_bb);

        // --- Grow block ---
        self.builder.positionAtEnd(grow_bb);

        // New capacity = max(8, capacity * 2)
        const doubled_cap = llvm.c.LLVMBuildMul(self.builder.ref, current_cap, llvm.Const.int32(self.ctx, 2), "push.doubled");
        const eight = llvm.Const.int32(self.ctx, 8);
        const cmp_eight = self.builder.buildICmp(llvm.c.LLVMIntSGT, doubled_cap, eight, "push.cmp_eight");
        const new_cap = llvm.c.LLVMBuildSelect(self.builder.ref, cmp_eight, doubled_cap, eight, "push.new_cap");

        // Calculate new size in bytes: new_cap * element_size
        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "push.new_cap_i64");
        const elem_size_val = llvm.Const.int64(self.ctx, @intCast(element_size));
        const new_size = llvm.c.LLVMBuildMul(self.builder.ref, new_cap_i64, elem_size_val, "push.new_size");

        // Call realloc(ptr, new_size) - realloc handles null ptr like malloc
        const realloc_fn = self.getOrDeclareRealloc();
        var realloc_args = [_]llvm.ValueRef{ current_ptr, new_size };
        const new_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(realloc_fn), realloc_fn, &realloc_args, "push.new_ptr");

        // Store new ptr and capacity
        _ = self.builder.buildStore(new_ptr, ptr_ptr);
        _ = self.builder.buildStore(new_cap, cap_ptr);

        _ = self.builder.buildBr(store_bb);

        // --- Store block ---
        self.builder.positionAtEnd(store_bb);

        // PHI for the data pointer (either current_ptr or new_ptr from grow)
        // Use saved entry_bb (not LLVMGetPreviousBasicBlock) to correctly handle
        // cases where emitting the value created intermediate basic blocks
        const phi = llvm.c.LLVMBuildPhi(self.builder.ref, ptr_type, "push.data_ptr");
        var incoming_values = [_]llvm.ValueRef{ current_ptr, new_ptr };
        var incoming_blocks = [_]llvm.BasicBlockRef{ entry_bb, grow_bb };
        llvm.c.LLVMAddIncoming(phi, &incoming_values, &incoming_blocks, 2);

        // Calculate address: ptr + len * element_size
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_len, i64_type, "push.len_i64");
        const offset = llvm.c.LLVMBuildMul(self.builder.ref, len_i64, elem_size_val, "push.offset");
        const i8_type = llvm.Types.int8(self.ctx);
        var gep_indices = [_]llvm.ValueRef{offset};
        const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, phi, &gep_indices, 1, "push.elem_ptr");

        // Store the value
        _ = self.builder.buildStore(value, elem_ptr);

        // Increment len and store back
        const new_len = llvm.c.LLVMBuildAdd(self.builder.ref, current_len, llvm.Const.int32(self.ctx, 1), "push.new_len");
        _ = self.builder.buildStore(new_len, len_ptr);

        // Return void (represented as i32 0 for now)
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit list.pop() - removes and returns the last element as Optional.
    fn emitListPop(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const list_pop_fn = self.getOrDeclareListPop();

        // Get element type
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        // Allocate stack space for the output value
        const value_out = self.builder.buildAlloca(element_llvm_type, "pop.value");

        var args = [_]llvm.ValueRef{
            list_ptr,
            llvm.Const.int64(self.ctx, @intCast(element_size)),
            value_out,
        };
        const success = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(list_pop_fn), list_pop_fn, &args, "pop.success");

        // Build optional type: { i1, T }
        const i1_type = llvm.Types.int1(self.ctx);
        var opt_fields = [_]llvm.TypeRef{ i1_type, element_llvm_type };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Allocate the optional result
        const opt_alloca = self.builder.buildAlloca(opt_type, "pop.optional");

        // Store the tag (success bool)
        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 0, "pop.tag_ptr");
        _ = self.builder.buildStore(success, tag_ptr);

        // Store the value (if success)
        const value_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 1, "pop.value_ptr");
        const loaded_value = self.builder.buildLoad(element_llvm_type, value_out, "pop.loaded");
        _ = self.builder.buildStore(loaded_value, value_ptr);

        // Load and return the optional
        return self.builder.buildLoad(opt_type, opt_alloca, "pop.result");
    }

    /// Emit list.get(index) - returns element at index as Optional.
    /// Uses inline LLVM codegen (no runtime function call).
    fn emitListGet(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall, index: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get element type info
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);

        // Load current ptr and len from the list struct
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "get.ptr_ptr");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "get.len_ptr");

        const current_ptr = self.builder.buildLoad(ptr_type, ptr_ptr, "get.current_ptr");
        const current_len = self.builder.buildLoad(i32_type, len_ptr, "get.current_len");

        // Check bounds: index >= 0 and index < len
        const zero = llvm.Const.int32(self.ctx, 0);
        const idx_ge_zero = self.builder.buildICmp(llvm.c.LLVMIntSGE, index, zero, "get.idx_ge_zero");
        const idx_lt_len = self.builder.buildICmp(llvm.c.LLVMIntSLT, index, current_len, "get.idx_lt_len");
        const in_bounds = llvm.c.LLVMBuildAnd(self.builder.ref, idx_ge_zero, idx_lt_len, "get.in_bounds");

        // Build optional type: { i1, T }
        var opt_fields = [_]llvm.TypeRef{ i1_type, element_llvm_type };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Allocate the optional result on the stack
        const opt_alloca = self.builder.buildAlloca(opt_type, "get.optional");

        // Create basic blocks for valid/invalid cases
        const valid_bb = llvm.appendBasicBlock(self.ctx, func, "get.valid");
        const invalid_bb = llvm.appendBasicBlock(self.ctx, func, "get.invalid");
        const merge_bb = llvm.appendBasicBlock(self.ctx, func, "get.merge");

        _ = self.builder.buildCondBr(in_bounds, valid_bb, invalid_bb);

        // --- Valid block: index is in bounds ---
        self.builder.positionAtEnd(valid_bb);

        // Calculate address: ptr + index * element_size
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, index, i64_type, "get.idx_i64");
        const elem_size_val = llvm.Const.int64(self.ctx, @intCast(element_size));
        const offset = llvm.c.LLVMBuildMul(self.builder.ref, idx_i64, elem_size_val, "get.offset");
        var gep_indices = [_]llvm.ValueRef{offset};
        const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, current_ptr, &gep_indices, 1, "get.elem_ptr");

        // Load the value
        const loaded_value = self.builder.buildLoad(element_llvm_type, elem_ptr, "get.loaded");

        // Store success (true) and value
        const tag_ptr_valid = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 0, "get.tag_ptr_valid");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr_valid);
        const value_ptr_valid = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 1, "get.value_ptr_valid");
        _ = self.builder.buildStore(loaded_value, value_ptr_valid);

        _ = self.builder.buildBr(merge_bb);

        // --- Invalid block: index is out of bounds ---
        self.builder.positionAtEnd(invalid_bb);

        // Store failure (false) - value field left uninitialized
        const tag_ptr_invalid = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 0, "get.tag_ptr_invalid");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr_invalid);

        _ = self.builder.buildBr(merge_bb);

        // --- Merge block ---
        self.builder.positionAtEnd(merge_bb);

        // Load and return the optional
        return self.builder.buildLoad(opt_type, opt_alloca, "get.result");
    }

    /// Emit list.clone() - creates a deep copy of the list.
    /// Uses inline LLVM codegen (no runtime function call).
    fn emitListClone(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get element type info
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Load current ptr and len from the source list
        const src_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "clone.src_ptr_ptr");
        const src_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "clone.src_len_ptr");

        const src_ptr = self.builder.buildLoad(ptr_type, src_ptr_ptr, "clone.src_ptr");
        const src_len = self.builder.buildLoad(i32_type, src_len_ptr, "clone.src_len");

        // Allocate result list on the stack
        const result_alloca = self.builder.buildAlloca(list_type, "clone.result");

        // Check if source list is empty
        const zero = llvm.Const.int32(self.ctx, 0);
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, src_len, zero, "clone.is_empty");

        // Create basic blocks
        const empty_bb = llvm.appendBasicBlock(self.ctx, func, "clone.empty");
        const copy_bb = llvm.appendBasicBlock(self.ctx, func, "clone.copy");
        const merge_bb = llvm.appendBasicBlock(self.ctx, func, "clone.merge");

        _ = self.builder.buildCondBr(is_empty, empty_bb, copy_bb);

        // --- Empty block: return empty list ---
        self.builder.positionAtEnd(empty_bb);

        // Store null ptr, 0 len, 0 capacity
        const empty_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "clone.empty_ptr_field");
        _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), empty_ptr_field);
        const empty_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "clone.empty_len_field");
        _ = self.builder.buildStore(zero, empty_len_field);
        const empty_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "clone.empty_cap_field");
        _ = self.builder.buildStore(zero, empty_cap_field);

        _ = self.builder.buildBr(merge_bb);

        // --- Copy block: allocate and copy data ---
        self.builder.positionAtEnd(copy_bb);

        // Calculate allocation size: len * element_size
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, src_len, i64_type, "clone.len_i64");
        const elem_size_val = llvm.Const.int64(self.ctx, @intCast(element_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, len_i64, elem_size_val, "clone.alloc_size");

        // Allocate new memory
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const new_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "clone.new_ptr");

        // Copy data using memcpy
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ new_ptr, src_ptr, alloc_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Store new ptr, same len, capacity = len
        const copy_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "clone.copy_ptr_field");
        _ = self.builder.buildStore(new_ptr, copy_ptr_field);
        const copy_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "clone.copy_len_field");
        _ = self.builder.buildStore(src_len, copy_len_field);
        const copy_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "clone.copy_cap_field");
        _ = self.builder.buildStore(src_len, copy_cap_field);

        _ = self.builder.buildBr(merge_bb);

        // --- Merge block ---
        self.builder.positionAtEnd(merge_bb);

        // Load and return the result list
        return self.builder.buildLoad(list_type, result_alloca, "clone.result_val");
    }

    /// Emit list.drop() - frees the list's memory.
    /// Uses inline LLVM codegen (no runtime function call).
    fn emitListDrop(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get element type info
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        _ = self.getLLVMTypeSize(element_llvm_type); // validate element type

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load the data pointer from the list
        const data_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "drop.data_ptr_ptr");
        const data_ptr = self.builder.buildLoad(ptr_type, data_ptr_ptr, "drop.data_ptr");

        // Check if pointer is null
        const null_ptr = llvm.c.LLVMConstPointerNull(ptr_type);
        const is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, data_ptr, null_ptr, "drop.is_null");

        // Create basic blocks
        const free_bb = llvm.appendBasicBlock(self.ctx, func, "drop.free");
        const done_bb = llvm.appendBasicBlock(self.ctx, func, "drop.done");

        _ = self.builder.buildCondBr(is_null, done_bb, free_bb);

        // --- Free block: ptr is not null, free the memory ---
        self.builder.positionAtEnd(free_bb);

        // Call free(ptr)
        const free_fn = self.getOrDeclareFree();
        var free_args = [_]llvm.ValueRef{data_ptr};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(free_fn), free_fn, &free_args, "");

        // Reset the list to empty state
        const zero = llvm.Const.int32(self.ctx, 0);
        _ = self.builder.buildStore(null_ptr, data_ptr_ptr);
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "drop.len_ptr");
        _ = self.builder.buildStore(zero, len_ptr);
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 2, "drop.cap_ptr");
        _ = self.builder.buildStore(zero, cap_ptr);

        _ = self.builder.buildBr(done_bb);

        // --- Done block ---
        self.builder.positionAtEnd(done_bb);

        // Return void (represented as i32 0)
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit list.take(n) - returns a new list with first n elements.
    fn emitListTake(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall, count: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get element type info
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Load current ptr and len from the source list
        const src_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "take.src_ptr_ptr");
        const src_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "take.src_len_ptr");

        const src_ptr = self.builder.buildLoad(ptr_type, src_ptr_ptr, "take.src_ptr");
        const src_len = self.builder.buildLoad(i32_type, src_len_ptr, "take.src_len");

        // Allocate result list on the stack
        const result_alloca = self.builder.buildAlloca(list_type, "take.result");

        // Compute actual count = min(count, len)
        // Also clamp count to >= 0
        const zero = llvm.Const.int32(self.ctx, 0);
        const count_clamped = llvm.c.LLVMBuildSelect(
            self.builder.ref,
            self.builder.buildICmp(llvm.c.LLVMIntSLT, count, zero, "take.count_neg"),
            zero,
            count,
            "take.count_clamped",
        );
        const actual_count = llvm.c.LLVMBuildSelect(
            self.builder.ref,
            self.builder.buildICmp(llvm.c.LLVMIntSLT, count_clamped, src_len, "take.count_lt_len"),
            count_clamped,
            src_len,
            "take.actual_count",
        );

        // Check if result will be empty
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, actual_count, zero, "take.is_empty");

        // Create basic blocks
        const empty_bb = llvm.appendBasicBlock(self.ctx, func, "take.empty");
        const copy_bb = llvm.appendBasicBlock(self.ctx, func, "take.copy");
        const merge_bb = llvm.appendBasicBlock(self.ctx, func, "take.merge");

        _ = self.builder.buildCondBr(is_empty, empty_bb, copy_bb);

        // --- Empty block: return empty list ---
        self.builder.positionAtEnd(empty_bb);

        const empty_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "take.empty_ptr_field");
        _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), empty_ptr_field);
        const empty_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "take.empty_len_field");
        _ = self.builder.buildStore(zero, empty_len_field);
        const empty_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "take.empty_cap_field");
        _ = self.builder.buildStore(zero, empty_cap_field);

        _ = self.builder.buildBr(merge_bb);

        // --- Copy block: allocate and copy data ---
        self.builder.positionAtEnd(copy_bb);

        // Calculate allocation size: actual_count * element_size
        const count_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, actual_count, i64_type, "take.count_i64");
        const elem_size_val = llvm.Const.int64(self.ctx, @intCast(element_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, count_i64, elem_size_val, "take.alloc_size");

        // Allocate new memory
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const new_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "take.new_ptr");

        // Copy data using memcpy
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ new_ptr, src_ptr, alloc_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Store new ptr, count, capacity = count
        const copy_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "take.copy_ptr_field");
        _ = self.builder.buildStore(new_ptr, copy_ptr_field);
        const copy_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "take.copy_len_field");
        _ = self.builder.buildStore(actual_count, copy_len_field);
        const copy_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "take.copy_cap_field");
        _ = self.builder.buildStore(actual_count, copy_cap_field);

        _ = self.builder.buildBr(merge_bb);

        // --- Merge block ---
        self.builder.positionAtEnd(merge_bb);

        return self.builder.buildLoad(list_type, result_alloca, "take.result_val");
    }

    /// Emit list.skip(n) - returns a new list skipping first n elements.
    fn emitListSkip(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall, count: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get element type info
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Load current ptr and len from the source list
        const src_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "skip.src_ptr_ptr");
        const src_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "skip.src_len_ptr");

        const src_ptr = self.builder.buildLoad(ptr_type, src_ptr_ptr, "skip.src_ptr");
        const src_len = self.builder.buildLoad(i32_type, src_len_ptr, "skip.src_len");

        // Allocate result list on the stack
        const result_alloca = self.builder.buildAlloca(list_type, "skip.result");

        // Compute start = min(count, len), clamped to >= 0
        const zero = llvm.Const.int32(self.ctx, 0);
        const count_clamped = llvm.c.LLVMBuildSelect(
            self.builder.ref,
            self.builder.buildICmp(llvm.c.LLVMIntSLT, count, zero, "skip.count_neg"),
            zero,
            count,
            "skip.count_clamped",
        );
        const start = llvm.c.LLVMBuildSelect(
            self.builder.ref,
            self.builder.buildICmp(llvm.c.LLVMIntSLT, count_clamped, src_len, "skip.count_lt_len"),
            count_clamped,
            src_len,
            "skip.start",
        );

        // Compute result_len = len - start
        const result_len = llvm.c.LLVMBuildSub(self.builder.ref, src_len, start, "skip.result_len");

        // Check if result will be empty
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, result_len, zero, "skip.is_empty");

        // Create basic blocks
        const empty_bb = llvm.appendBasicBlock(self.ctx, func, "skip.empty");
        const copy_bb = llvm.appendBasicBlock(self.ctx, func, "skip.copy");
        const merge_bb = llvm.appendBasicBlock(self.ctx, func, "skip.merge");

        _ = self.builder.buildCondBr(is_empty, empty_bb, copy_bb);

        // --- Empty block: return empty list ---
        self.builder.positionAtEnd(empty_bb);

        const empty_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "skip.empty_ptr_field");
        _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), empty_ptr_field);
        const empty_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "skip.empty_len_field");
        _ = self.builder.buildStore(zero, empty_len_field);
        const empty_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "skip.empty_cap_field");
        _ = self.builder.buildStore(zero, empty_cap_field);

        _ = self.builder.buildBr(merge_bb);

        // --- Copy block: allocate and copy data ---
        self.builder.positionAtEnd(copy_bb);

        // Calculate allocation size: result_len * element_size
        const result_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, result_len, i64_type, "skip.result_len_i64");
        const elem_size_val = llvm.Const.int64(self.ctx, @intCast(element_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, result_len_i64, elem_size_val, "skip.alloc_size");

        // Allocate new memory
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const new_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "skip.new_ptr");

        // Calculate source offset: start * element_size
        const start_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, start, i64_type, "skip.start_i64");
        const src_offset = llvm.c.LLVMBuildMul(self.builder.ref, start_i64, elem_size_val, "skip.src_offset");
        const i8_type = llvm.Types.int8(self.ctx);
        var gep_indices = [_]llvm.ValueRef{src_offset};
        const src_start_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, src_ptr, &gep_indices, 1, "skip.src_start_ptr");

        // Copy data using memcpy
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ new_ptr, src_start_ptr, alloc_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Store new ptr, result_len, capacity = result_len
        const copy_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "skip.copy_ptr_field");
        _ = self.builder.buildStore(new_ptr, copy_ptr_field);
        const copy_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "skip.copy_len_field");
        _ = self.builder.buildStore(result_len, copy_len_field);
        const copy_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "skip.copy_cap_field");
        _ = self.builder.buildStore(result_len, copy_cap_field);

        _ = self.builder.buildBr(merge_bb);

        // --- Merge block ---
        self.builder.positionAtEnd(merge_bb);

        return self.builder.buildLoad(list_type, result_alloca, "skip.result_val");
    }

    /// Emit a function reference or closure as a closure struct value.
    /// If the expression is a plain function identifier, create a wrapper with closure calling convention.
    /// If it's already a closure, return it as-is.
    fn emitFunctionOrClosure(self: *Emitter, expr: ast.Expr) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const closure_struct_type = self.getClosureStructType();

        // Check if this is a function identifier (top-level function reference)
        if (expr == .identifier) {
            const func_name = expr.identifier.name;

            // Check if it's in named_values (local closure variable)
            if (self.named_values.get(func_name)) |local| {
                if (local.is_alloca) {
                    const name = self.allocator.dupeZ(u8, func_name) catch return EmitError.OutOfMemory;
                    defer self.allocator.free(name);
                    return self.builder.buildLoad(local.ty, local.value, name);
                }
                return local.value;
            }

            // Not in named_values - it's a top-level function reference
            // Get the function pointer from the module
            const name_z = self.allocator.dupeZ(u8, func_name) catch return EmitError.OutOfMemory;
            defer self.allocator.free(name_z);

            const orig_func = self.module.getNamedFunction(name_z) orelse {
                // Function not found, return a null closure
                const closure_alloca = self.builder.buildAlloca(closure_struct_type, "fn_closure.tmp");
                var fn_ptr_indices = [_]llvm.ValueRef{
                    llvm.Const.int32(self.ctx, 0),
                    llvm.Const.int32(self.ctx, 0),
                };
                const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "fn_closure.fn_ptr");
                _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), fn_ptr_gep);
                var env_ptr_indices = [_]llvm.ValueRef{
                    llvm.Const.int32(self.ctx, 0),
                    llvm.Const.int32(self.ctx, 1),
                };
                const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "fn_closure.env_ptr");
                _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), env_ptr_gep);
                return self.builder.buildLoad(closure_struct_type, closure_alloca, "fn_closure.val");
            };

            // Create a wrapper function with closure calling convention
            // The wrapper takes (env_ptr, args...) and calls the original function with just (args...)
            const orig_fn_type = llvm.getGlobalValueType(orig_func);
            const orig_return_type = llvm.getReturnType(orig_fn_type);
            const orig_param_count = llvm.c.LLVMCountParamTypes(orig_fn_type);

            // Build wrapper parameter types: [ptr (env), original params...]
            var wrapper_param_types = std.ArrayListUnmanaged(llvm.TypeRef){};
            defer wrapper_param_types.deinit(self.allocator);
            wrapper_param_types.append(self.allocator, ptr_type) catch return EmitError.OutOfMemory; // env_ptr

            // Get original param types
            var orig_param_types: [16]llvm.TypeRef = undefined;
            if (orig_param_count > 16) return EmitError.UnsupportedFeature;
            llvm.c.LLVMGetParamTypes(orig_fn_type, &orig_param_types);
            for (0..orig_param_count) |i| {
                wrapper_param_types.append(self.allocator, orig_param_types[i]) catch return EmitError.OutOfMemory;
            }

            const wrapper_fn_type = llvm.Types.function(orig_return_type, wrapper_param_types.items, false);

            // Generate unique wrapper name
            var wrapper_name_buf: [128]u8 = undefined;
            const wrapper_name = std.fmt.bufPrintZ(&wrapper_name_buf, "{s}__closure_wrapper", .{func_name}) catch return EmitError.OutOfMemory;

            // Check if wrapper already exists
            const wrapper_func = self.module.getNamedFunction(wrapper_name) orelse blk: {
                // Create the wrapper function
                const new_wrapper = llvm.addFunction(self.module, wrapper_name, wrapper_fn_type);

                // Save current insert point
                const saved_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

                // Create entry block for wrapper
                const entry = llvm.appendBasicBlock(self.ctx, new_wrapper, "entry");
                self.builder.positionAtEnd(entry);

                // Build call to original function (skip env_ptr argument)
                var call_args = std.ArrayListUnmanaged(llvm.ValueRef){};
                defer call_args.deinit(self.allocator);
                for (0..orig_param_count) |i| {
                    // Skip param 0 (env_ptr), use params 1..
                    const param = llvm.c.LLVMGetParam(new_wrapper, @intCast(i + 1));
                    call_args.append(self.allocator, param) catch return EmitError.OutOfMemory;
                }

                const result = self.builder.buildCall(orig_fn_type, orig_func, call_args.items, "call_orig");

                // Return the result
                if (llvm.getTypeKind(orig_return_type) == llvm.c.LLVMVoidTypeKind) {
                    _ = self.builder.buildRetVoid();
                } else {
                    _ = self.builder.buildRet(result);
                }

                // Restore insert point
                if (saved_block) |sb| {
                    self.builder.positionAtEnd(sb);
                }

                break :blk new_wrapper;
            };

            // Create a closure struct with the wrapper function pointer and null environment
            const closure_alloca = self.builder.buildAlloca(closure_struct_type, "fn_closure.tmp");
            var fn_ptr_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 0),
            };
            const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "fn_closure.fn_ptr");
            _ = self.builder.buildStore(wrapper_func, fn_ptr_gep);

            var env_ptr_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 1),
            };
            const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "fn_closure.env_ptr");
            _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), env_ptr_gep);

            return self.builder.buildLoad(closure_struct_type, closure_alloca, "fn_closure.val");
        }

        // For closures and other expressions, emit normally
        return try self.emitExpr(expr);
    }

    /// Emit list.filter(predicate) - returns a new list with elements where predicate returns true.
    fn emitListFilter(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall, closure_value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get element type info
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);

        // Load current ptr and len from the source list
        const src_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "filter.src_ptr_ptr");
        const src_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "filter.src_len_ptr");

        const src_ptr = self.builder.buildLoad(ptr_type, src_ptr_ptr, "filter.src_ptr");
        const src_len = self.builder.buildLoad(i32_type, src_len_ptr, "filter.src_len");

        // Allocate result list on the stack (start with empty list)
        const result_alloca = self.builder.buildAlloca(list_type, "filter.result");
        const zero = llvm.Const.int32(self.ctx, 0);

        // Initialize result to empty list
        const init_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "filter.init_ptr_field");
        _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), init_ptr_field);
        const init_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "filter.init_len_field");
        _ = self.builder.buildStore(zero, init_len_field);
        const init_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "filter.init_cap_field");
        _ = self.builder.buildStore(zero, init_cap_field);

        // Extract closure function pointer and environment pointer
        const closure_struct_type = self.getClosureStructType();
        const closure_alloca = self.builder.buildAlloca(closure_struct_type, "filter.closure_tmp");
        _ = self.builder.buildStore(closure_value, closure_alloca);

        var fn_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "filter.fn_ptr_ptr");
        const fn_ptr = self.builder.buildLoad(ptr_type, fn_ptr_gep, "filter.fn_ptr");

        var env_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "filter.env_ptr_ptr");
        const env_ptr = self.builder.buildLoad(ptr_type, env_ptr_gep, "filter.env_ptr");

        // Build function type for closure: fn(env_ptr, element) -> bool
        var param_types = [_]llvm.TypeRef{ ptr_type, element_llvm_type };
        const closure_fn_type = llvm.Types.function(i1_type, &param_types, false);

        // Create loop counter alloca
        const i_alloca = self.builder.buildAlloca(i32_type, "filter.i");
        _ = self.builder.buildStore(zero, i_alloca);

        // Create basic blocks for loop
        const loop_cond_bb = llvm.appendBasicBlock(self.ctx, func, "filter.loop_cond");
        const loop_body_bb = llvm.appendBasicBlock(self.ctx, func, "filter.loop_body");
        const push_bb = llvm.appendBasicBlock(self.ctx, func, "filter.push");
        const loop_inc_bb = llvm.appendBasicBlock(self.ctx, func, "filter.loop_inc");
        const loop_end_bb = llvm.appendBasicBlock(self.ctx, func, "filter.loop_end");

        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop condition ---
        self.builder.positionAtEnd(loop_cond_bb);
        const i_val = self.builder.buildLoad(i32_type, i_alloca, "filter.i_val");
        const loop_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, i_val, src_len, "filter.loop_cond");
        _ = self.builder.buildCondBr(loop_cond, loop_body_bb, loop_end_bb);

        // --- Loop body: load element, call predicate ---
        self.builder.positionAtEnd(loop_body_bb);

        // Calculate element address: src_ptr + i * element_size
        const i_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, i_val, i64_type, "filter.i_i64");
        const elem_size_val = llvm.Const.int64(self.ctx, @intCast(element_size));
        const offset = llvm.c.LLVMBuildMul(self.builder.ref, i_i64, elem_size_val, "filter.offset");
        const i8_type = llvm.Types.int8(self.ctx);
        var gep_indices = [_]llvm.ValueRef{offset};
        const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, src_ptr, &gep_indices, 1, "filter.elem_ptr");
        const elem_val = self.builder.buildLoad(element_llvm_type, elem_ptr, "filter.elem_val");

        // Call predicate closure
        var call_args = [_]llvm.ValueRef{ env_ptr, elem_val };
        const pred_result = self.builder.buildCall(closure_fn_type, fn_ptr, &call_args, "filter.pred_result");

        _ = self.builder.buildCondBr(pred_result, push_bb, loop_inc_bb);

        // --- Push block: add element to result list ---
        self.builder.positionAtEnd(push_bb);

        // Use inline push logic (similar to emitListPush but simplified)
        // Load result list state
        const res_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "filter.res_ptr_ptr");
        const res_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "filter.res_len_ptr");
        const res_cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "filter.res_cap_ptr");

        const res_ptr = self.builder.buildLoad(ptr_type, res_ptr_ptr, "filter.res_ptr");
        const res_len = self.builder.buildLoad(i32_type, res_len_ptr, "filter.res_len");
        const res_cap = self.builder.buildLoad(i32_type, res_cap_ptr, "filter.res_cap");

        // Check if we need to grow
        const need_grow = self.builder.buildICmp(llvm.c.LLVMIntSGE, res_len, res_cap, "filter.need_grow");

        const grow_bb = llvm.appendBasicBlock(self.ctx, func, "filter.grow");
        const store_bb = llvm.appendBasicBlock(self.ctx, func, "filter.store");

        _ = self.builder.buildCondBr(need_grow, grow_bb, store_bb);

        // --- Grow block ---
        self.builder.positionAtEnd(grow_bb);

        const doubled_cap = llvm.c.LLVMBuildMul(self.builder.ref, res_cap, llvm.Const.int32(self.ctx, 2), "filter.doubled");
        const eight = llvm.Const.int32(self.ctx, 8);
        const cmp_eight = self.builder.buildICmp(llvm.c.LLVMIntSGT, doubled_cap, eight, "filter.cmp_eight");
        const new_cap = llvm.c.LLVMBuildSelect(self.builder.ref, cmp_eight, doubled_cap, eight, "filter.new_cap");

        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "filter.new_cap_i64");
        const new_size = llvm.c.LLVMBuildMul(self.builder.ref, new_cap_i64, elem_size_val, "filter.new_size");

        const realloc_fn = self.getOrDeclareRealloc();
        var realloc_args = [_]llvm.ValueRef{ res_ptr, new_size };
        const grown_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(realloc_fn), realloc_fn, &realloc_args, "filter.grown_ptr");

        _ = self.builder.buildStore(grown_ptr, res_ptr_ptr);
        _ = self.builder.buildStore(new_cap, res_cap_ptr);

        _ = self.builder.buildBr(store_bb);

        // --- Store block ---
        self.builder.positionAtEnd(store_bb);

        // PHI for the data pointer
        const phi = llvm.c.LLVMBuildPhi(self.builder.ref, ptr_type, "filter.data_ptr");
        var incoming_values = [_]llvm.ValueRef{ res_ptr, grown_ptr };
        var incoming_blocks = [_]llvm.BasicBlockRef{ push_bb, grow_bb };
        llvm.c.LLVMAddIncoming(phi, &incoming_values, &incoming_blocks, 2);

        // Calculate address for new element
        const res_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, res_len, i64_type, "filter.res_len_i64");
        const store_offset = llvm.c.LLVMBuildMul(self.builder.ref, res_len_i64, elem_size_val, "filter.store_offset");
        var store_gep_indices = [_]llvm.ValueRef{store_offset};
        const store_elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, phi, &store_gep_indices, 1, "filter.store_elem_ptr");

        _ = self.builder.buildStore(elem_val, store_elem_ptr);

        // Increment result length
        const new_res_len = llvm.c.LLVMBuildAdd(self.builder.ref, res_len, llvm.Const.int32(self.ctx, 1), "filter.new_res_len");
        _ = self.builder.buildStore(new_res_len, res_len_ptr);

        _ = self.builder.buildBr(loop_inc_bb);

        // --- Loop increment ---
        self.builder.positionAtEnd(loop_inc_bb);
        const next_i = llvm.c.LLVMBuildAdd(self.builder.ref, i_val, llvm.Const.int32(self.ctx, 1), "filter.next_i");
        _ = self.builder.buildStore(next_i, i_alloca);
        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop end ---
        self.builder.positionAtEnd(loop_end_bb);

        return self.builder.buildLoad(list_type, result_alloca, "filter.result_val");
    }

    /// Emit list.map(transform) - returns a new list with transformed elements.
    fn emitListMap(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall, closure_value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get source element type info
        const src_element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const src_element_llvm_type = self.typeToLLVM(src_element_type);
        const src_element_size = self.getLLVMTypeSize(src_element_llvm_type);

        // Get destination element type from closure's return type
        const dest_element_type = if (self.type_checker) |tc| blk: {
            const tc_mut = @constCast(tc);
            // Get the closure argument's type (fn(T) -> U)
            const closure_type = tc_mut.checkExpr(method.args[0]);
            if (closure_type == .function) {
                break :blk closure_type.function.return_type;
            }
            break :blk src_element_type; // Fallback
        } else src_element_type;

        const dest_element_llvm_type = self.typeToLLVM(dest_element_type);
        const dest_element_size = self.getLLVMTypeSize(dest_element_llvm_type);

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Load current ptr and len from the source list
        const src_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "map.src_ptr_ptr");
        const src_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "map.src_len_ptr");

        const src_ptr = self.builder.buildLoad(ptr_type, src_ptr_ptr, "map.src_ptr");
        const src_len = self.builder.buildLoad(i32_type, src_len_ptr, "map.src_len");

        // Allocate result list on the stack
        const result_alloca = self.builder.buildAlloca(list_type, "map.result");
        const zero = llvm.Const.int32(self.ctx, 0);

        // Check if source list is empty
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, src_len, zero, "map.is_empty");

        // Create basic blocks
        const empty_bb = llvm.appendBasicBlock(self.ctx, func, "map.empty");
        const alloc_bb = llvm.appendBasicBlock(self.ctx, func, "map.alloc");
        const loop_cond_bb = llvm.appendBasicBlock(self.ctx, func, "map.loop_cond");
        const loop_body_bb = llvm.appendBasicBlock(self.ctx, func, "map.loop_body");
        const loop_end_bb = llvm.appendBasicBlock(self.ctx, func, "map.loop_end");

        _ = self.builder.buildCondBr(is_empty, empty_bb, alloc_bb);

        // --- Empty block: return empty list ---
        self.builder.positionAtEnd(empty_bb);

        const empty_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "map.empty_ptr_field");
        _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), empty_ptr_field);
        const empty_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "map.empty_len_field");
        _ = self.builder.buildStore(zero, empty_len_field);
        const empty_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "map.empty_cap_field");
        _ = self.builder.buildStore(zero, empty_cap_field);

        _ = self.builder.buildBr(loop_end_bb);

        // --- Allocate block: pre-allocate result array ---
        self.builder.positionAtEnd(alloc_bb);

        // Extract closure function pointer and environment pointer
        const closure_struct_type = self.getClosureStructType();
        const closure_alloca = self.builder.buildAlloca(closure_struct_type, "map.closure_tmp");
        _ = self.builder.buildStore(closure_value, closure_alloca);

        var fn_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "map.fn_ptr_ptr");
        const fn_ptr = self.builder.buildLoad(ptr_type, fn_ptr_gep, "map.fn_ptr");

        var env_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "map.env_ptr_ptr");
        const env_ptr = self.builder.buildLoad(ptr_type, env_ptr_gep, "map.env_ptr");

        // Build function type for closure: fn(env_ptr, src_element) -> dest_element
        var param_types = [_]llvm.TypeRef{ ptr_type, src_element_llvm_type };
        const closure_fn_type = llvm.Types.function(dest_element_llvm_type, &param_types, false);

        // Allocate memory for result: len * dest_element_size
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, src_len, i64_type, "map.len_i64");
        const dest_elem_size_val = llvm.Const.int64(self.ctx, @intCast(dest_element_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, len_i64, dest_elem_size_val, "map.alloc_size");

        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const dest_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "map.dest_ptr");

        // Store result list header
        const alloc_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "map.alloc_ptr_field");
        _ = self.builder.buildStore(dest_ptr, alloc_ptr_field);
        const alloc_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "map.alloc_len_field");
        _ = self.builder.buildStore(src_len, alloc_len_field);
        const alloc_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "map.alloc_cap_field");
        _ = self.builder.buildStore(src_len, alloc_cap_field);

        // Create loop counter alloca
        const i_alloca = self.builder.buildAlloca(i32_type, "map.i");
        _ = self.builder.buildStore(zero, i_alloca);

        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop condition ---
        self.builder.positionAtEnd(loop_cond_bb);
        const i_val = self.builder.buildLoad(i32_type, i_alloca, "map.i_val");
        const loop_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, i_val, src_len, "map.loop_cond");
        _ = self.builder.buildCondBr(loop_cond, loop_body_bb, loop_end_bb);

        // --- Loop body: transform element ---
        self.builder.positionAtEnd(loop_body_bb);

        // Calculate source element address
        const i_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, i_val, i64_type, "map.i_i64");
        const src_elem_size_val = llvm.Const.int64(self.ctx, @intCast(src_element_size));
        const src_offset = llvm.c.LLVMBuildMul(self.builder.ref, i_i64, src_elem_size_val, "map.src_offset");
        const i8_type = llvm.Types.int8(self.ctx);
        var src_gep_indices = [_]llvm.ValueRef{src_offset};
        const src_elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, src_ptr, &src_gep_indices, 1, "map.src_elem_ptr");
        const src_elem_val = self.builder.buildLoad(src_element_llvm_type, src_elem_ptr, "map.src_elem_val");

        // Call transform closure
        var call_args = [_]llvm.ValueRef{ env_ptr, src_elem_val };
        const dest_elem_val = self.builder.buildCall(closure_fn_type, fn_ptr, &call_args, "map.dest_elem_val");

        // Calculate destination element address
        const dest_offset = llvm.c.LLVMBuildMul(self.builder.ref, i_i64, dest_elem_size_val, "map.dest_offset");
        var dest_gep_indices = [_]llvm.ValueRef{dest_offset};
        const dest_elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, dest_ptr, &dest_gep_indices, 1, "map.dest_elem_ptr");

        _ = self.builder.buildStore(dest_elem_val, dest_elem_ptr);

        // Increment counter
        const next_i = llvm.c.LLVMBuildAdd(self.builder.ref, i_val, llvm.Const.int32(self.ctx, 1), "map.next_i");
        _ = self.builder.buildStore(next_i, i_alloca);
        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop end ---
        self.builder.positionAtEnd(loop_end_bb);

        return self.builder.buildLoad(list_type, result_alloca, "map.result_val");
    }

    /// Emit list.enumerate() - returns a new list of (index, element) tuples.
    fn emitListEnumerate(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get element type info
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Create tuple type: { i32, element_type }
        var tuple_elem_types = [_]llvm.TypeRef{ i32_type, element_llvm_type };
        const tuple_type = llvm.Types.struct_(self.ctx, &tuple_elem_types, false);
        const tuple_size = self.getLLVMTypeSize(tuple_type);

        // Load current ptr and len from the source list
        const src_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "enum.src_ptr_ptr");
        const src_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "enum.src_len_ptr");

        const src_ptr = self.builder.buildLoad(ptr_type, src_ptr_ptr, "enum.src_ptr");
        const src_len = self.builder.buildLoad(i32_type, src_len_ptr, "enum.src_len");

        // Allocate result list on the stack
        const result_alloca = self.builder.buildAlloca(list_type, "enum.result");
        const zero = llvm.Const.int32(self.ctx, 0);

        // Check if source list is empty
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, src_len, zero, "enum.is_empty");

        // Create basic blocks
        const empty_bb = llvm.appendBasicBlock(self.ctx, func, "enum.empty");
        const alloc_bb = llvm.appendBasicBlock(self.ctx, func, "enum.alloc");
        const loop_cond_bb = llvm.appendBasicBlock(self.ctx, func, "enum.loop_cond");
        const loop_body_bb = llvm.appendBasicBlock(self.ctx, func, "enum.loop_body");
        const loop_end_bb = llvm.appendBasicBlock(self.ctx, func, "enum.loop_end");

        _ = self.builder.buildCondBr(is_empty, empty_bb, alloc_bb);

        // --- Empty block: return empty list ---
        self.builder.positionAtEnd(empty_bb);

        const empty_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "enum.empty_ptr_field");
        _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), empty_ptr_field);
        const empty_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "enum.empty_len_field");
        _ = self.builder.buildStore(zero, empty_len_field);
        const empty_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "enum.empty_cap_field");
        _ = self.builder.buildStore(zero, empty_cap_field);

        _ = self.builder.buildBr(loop_end_bb);

        // --- Allocate block: pre-allocate result array ---
        self.builder.positionAtEnd(alloc_bb);

        // Allocate memory for result: len * tuple_size
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, src_len, i64_type, "enum.len_i64");
        const tuple_size_val = llvm.Const.int64(self.ctx, @intCast(tuple_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, len_i64, tuple_size_val, "enum.alloc_size");

        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const dest_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "enum.dest_ptr");

        // Store result list header
        const alloc_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "enum.alloc_ptr_field");
        _ = self.builder.buildStore(dest_ptr, alloc_ptr_field);
        const alloc_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "enum.alloc_len_field");
        _ = self.builder.buildStore(src_len, alloc_len_field);
        const alloc_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "enum.alloc_cap_field");
        _ = self.builder.buildStore(src_len, alloc_cap_field);

        // Create loop counter alloca
        const i_alloca = self.builder.buildAlloca(i32_type, "enum.i");
        _ = self.builder.buildStore(zero, i_alloca);

        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop condition ---
        self.builder.positionAtEnd(loop_cond_bb);
        const i_val = self.builder.buildLoad(i32_type, i_alloca, "enum.i_val");
        const loop_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, i_val, src_len, "enum.loop_cond");
        _ = self.builder.buildCondBr(loop_cond, loop_body_bb, loop_end_bb);

        // --- Loop body: create (index, element) tuple ---
        self.builder.positionAtEnd(loop_body_bb);

        // Calculate source element address
        const i_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, i_val, i64_type, "enum.i_i64");
        const elem_size_val = llvm.Const.int64(self.ctx, @intCast(element_size));
        const src_offset = llvm.c.LLVMBuildMul(self.builder.ref, i_i64, elem_size_val, "enum.src_offset");
        const i8_type = llvm.Types.int8(self.ctx);
        var src_gep_indices = [_]llvm.ValueRef{src_offset};
        const src_elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, src_ptr, &src_gep_indices, 1, "enum.src_elem_ptr");
        const elem_val = self.builder.buildLoad(element_llvm_type, src_elem_ptr, "enum.elem_val");

        // Calculate destination tuple address
        const dest_offset = llvm.c.LLVMBuildMul(self.builder.ref, i_i64, tuple_size_val, "enum.dest_offset");
        var dest_gep_indices = [_]llvm.ValueRef{dest_offset};
        const dest_tuple_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, dest_ptr, &dest_gep_indices, 1, "enum.dest_tuple_ptr");

        // Store index (field 0)
        var idx_field_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const idx_ptr = self.builder.buildGEP(tuple_type, dest_tuple_ptr, &idx_field_indices, "enum.idx_ptr");
        _ = self.builder.buildStore(i_val, idx_ptr);

        // Store element (field 1)
        var elem_field_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const elem_ptr = self.builder.buildGEP(tuple_type, dest_tuple_ptr, &elem_field_indices, "enum.elem_ptr");
        _ = self.builder.buildStore(elem_val, elem_ptr);

        // Increment counter
        const next_i = llvm.c.LLVMBuildAdd(self.builder.ref, i_val, llvm.Const.int32(self.ctx, 1), "enum.next_i");
        _ = self.builder.buildStore(next_i, i_alloca);
        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop end ---
        self.builder.positionAtEnd(loop_end_bb);

        return self.builder.buildLoad(list_type, result_alloca, "enum.result_val");
    }

    /// Emit list.zip(other) - returns a new list of (self[i], other[i]) tuples.
    fn emitListZip(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Get first list element type info
        const element_type1 = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type1 = self.typeToLLVM(element_type1);
        const element_size1 = self.getLLVMTypeSize(element_llvm_type1);

        // Get second list element type info
        const element_type2 = if (self.type_checker) |tc| blk: {
            const tc_mut = @constCast(tc);
            const arg_type = tc_mut.checkExpr(method.args[0]);
            if (arg_type == .list) {
                break :blk arg_type.list.element;
            }
            break :blk element_type1; // Fallback
        } else element_type1;
        const element_llvm_type2 = self.typeToLLVM(element_type2);
        const element_size2 = self.getLLVMTypeSize(element_llvm_type2);

        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Create tuple type: { element_type1, element_type2 }
        var tuple_elem_types = [_]llvm.TypeRef{ element_llvm_type1, element_llvm_type2 };
        const tuple_type = llvm.Types.struct_(self.ctx, &tuple_elem_types, false);
        const tuple_size = self.getLLVMTypeSize(tuple_type);

        // Load ptr and len from first list
        const src1_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 0, "zip.src1_ptr_ptr");
        const src1_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_ptr, 1, "zip.src1_len_ptr");
        const src1_ptr = self.builder.buildLoad(ptr_type, src1_ptr_ptr, "zip.src1_ptr");
        const src1_len = self.builder.buildLoad(i32_type, src1_len_ptr, "zip.src1_len");

        // Get second list pointer
        const list2_ptr = if (method.args[0] == .identifier) blk: {
            if (self.named_values.get(method.args[0].identifier.name)) |local| {
                break :blk local.value;
            }
            const tmp_val = try self.emitExpr(method.args[0]);
            const tmp_alloca = self.builder.buildAlloca(list_type, "zip.list2.tmp");
            _ = self.builder.buildStore(tmp_val, tmp_alloca);
            break :blk tmp_alloca;
        } else blk: {
            const tmp_val = try self.emitExpr(method.args[0]);
            const tmp_alloca = self.builder.buildAlloca(list_type, "zip.list2.tmp");
            _ = self.builder.buildStore(tmp_val, tmp_alloca);
            break :blk tmp_alloca;
        };

        // Load ptr and len from second list
        const src2_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list2_ptr, 0, "zip.src2_ptr_ptr");
        const src2_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list2_ptr, 1, "zip.src2_len_ptr");
        const src2_ptr = self.builder.buildLoad(ptr_type, src2_ptr_ptr, "zip.src2_ptr");
        const src2_len = self.builder.buildLoad(i32_type, src2_len_ptr, "zip.src2_len");

        // Result length = min(len1, len2)
        const result_len = llvm.c.LLVMBuildSelect(
            self.builder.ref,
            self.builder.buildICmp(llvm.c.LLVMIntSLT, src1_len, src2_len, "zip.len1_lt_len2"),
            src1_len,
            src2_len,
            "zip.result_len",
        );

        // Allocate result list on the stack
        const result_alloca = self.builder.buildAlloca(list_type, "zip.result");
        const zero = llvm.Const.int32(self.ctx, 0);

        // Check if result will be empty
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, result_len, zero, "zip.is_empty");

        // Create basic blocks
        const empty_bb = llvm.appendBasicBlock(self.ctx, func, "zip.empty");
        const alloc_bb = llvm.appendBasicBlock(self.ctx, func, "zip.alloc");
        const loop_cond_bb = llvm.appendBasicBlock(self.ctx, func, "zip.loop_cond");
        const loop_body_bb = llvm.appendBasicBlock(self.ctx, func, "zip.loop_body");
        const loop_end_bb = llvm.appendBasicBlock(self.ctx, func, "zip.loop_end");

        _ = self.builder.buildCondBr(is_empty, empty_bb, alloc_bb);

        // --- Empty block: return empty list ---
        self.builder.positionAtEnd(empty_bb);

        const empty_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "zip.empty_ptr_field");
        _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), empty_ptr_field);
        const empty_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "zip.empty_len_field");
        _ = self.builder.buildStore(zero, empty_len_field);
        const empty_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "zip.empty_cap_field");
        _ = self.builder.buildStore(zero, empty_cap_field);

        _ = self.builder.buildBr(loop_end_bb);

        // --- Allocate block: pre-allocate result array ---
        self.builder.positionAtEnd(alloc_bb);

        // Allocate memory for result: result_len * tuple_size
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, result_len, i64_type, "zip.len_i64");
        const tuple_size_val = llvm.Const.int64(self.ctx, @intCast(tuple_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, len_i64, tuple_size_val, "zip.alloc_size");

        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const dest_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "zip.dest_ptr");

        // Store result list header
        const alloc_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "zip.alloc_ptr_field");
        _ = self.builder.buildStore(dest_ptr, alloc_ptr_field);
        const alloc_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "zip.alloc_len_field");
        _ = self.builder.buildStore(result_len, alloc_len_field);
        const alloc_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "zip.alloc_cap_field");
        _ = self.builder.buildStore(result_len, alloc_cap_field);

        // Create loop counter alloca
        const i_alloca = self.builder.buildAlloca(i32_type, "zip.i");
        _ = self.builder.buildStore(zero, i_alloca);

        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop condition ---
        self.builder.positionAtEnd(loop_cond_bb);
        const i_val = self.builder.buildLoad(i32_type, i_alloca, "zip.i_val");
        const loop_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, i_val, result_len, "zip.loop_cond");
        _ = self.builder.buildCondBr(loop_cond, loop_body_bb, loop_end_bb);

        // --- Loop body: create (elem1, elem2) tuple ---
        self.builder.positionAtEnd(loop_body_bb);
        const i8_type = llvm.Types.int8(self.ctx);

        // Calculate source 1 element address
        const i_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, i_val, i64_type, "zip.i_i64");
        const elem_size1_val = llvm.Const.int64(self.ctx, @intCast(element_size1));
        const src1_offset = llvm.c.LLVMBuildMul(self.builder.ref, i_i64, elem_size1_val, "zip.src1_offset");
        var src1_gep_indices = [_]llvm.ValueRef{src1_offset};
        const src1_elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, src1_ptr, &src1_gep_indices, 1, "zip.src1_elem_ptr");
        const elem1_val = self.builder.buildLoad(element_llvm_type1, src1_elem_ptr, "zip.elem1_val");

        // Calculate source 2 element address
        const elem_size2_val = llvm.Const.int64(self.ctx, @intCast(element_size2));
        const src2_offset = llvm.c.LLVMBuildMul(self.builder.ref, i_i64, elem_size2_val, "zip.src2_offset");
        var src2_gep_indices = [_]llvm.ValueRef{src2_offset};
        const src2_elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, src2_ptr, &src2_gep_indices, 1, "zip.src2_elem_ptr");
        const elem2_val = self.builder.buildLoad(element_llvm_type2, src2_elem_ptr, "zip.elem2_val");

        // Calculate destination tuple address
        const dest_offset = llvm.c.LLVMBuildMul(self.builder.ref, i_i64, tuple_size_val, "zip.dest_offset");
        var dest_gep_indices = [_]llvm.ValueRef{dest_offset};
        const dest_tuple_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, dest_ptr, &dest_gep_indices, 1, "zip.dest_tuple_ptr");

        // Store element 1 (field 0)
        var elem1_field_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const elem1_ptr = self.builder.buildGEP(tuple_type, dest_tuple_ptr, &elem1_field_indices, "zip.elem1_ptr");
        _ = self.builder.buildStore(elem1_val, elem1_ptr);

        // Store element 2 (field 1)
        var elem2_field_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const elem2_ptr = self.builder.buildGEP(tuple_type, dest_tuple_ptr, &elem2_field_indices, "zip.elem2_ptr");
        _ = self.builder.buildStore(elem2_val, elem2_ptr);

        // Increment counter
        const next_i = llvm.c.LLVMBuildAdd(self.builder.ref, i_val, llvm.Const.int32(self.ctx, 1), "zip.next_i");
        _ = self.builder.buildStore(next_i, i_alloca);
        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop end ---
        self.builder.positionAtEnd(loop_end_bb);

        return self.builder.buildLoad(list_type, result_alloca, "zip.result_val");
    }

    /// Emit list.set(index, value) - sets element at index.
    fn emitListSet(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall, index: llvm.ValueRef, value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const list_set_fn = self.getOrDeclareListSet();

        // Get element type
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        // Allocate stack space for the value and get its pointer
        const value_alloca = self.builder.buildAlloca(element_llvm_type, "set.value");
        _ = self.builder.buildStore(value, value_alloca);

        var args = [_]llvm.ValueRef{
            list_ptr,
            llvm.Const.int64(self.ctx, @intCast(element_size)),
            index,
            value_alloca,
        };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(list_set_fn), list_set_fn, &args, "");

        // Return void (represented as i32 0 for now)
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit list.first() - returns first element as Optional.
    fn emitListFirst(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const list_first_fn = self.getOrDeclareListFirst();

        // Get element type
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        // Allocate stack space for the output value
        const value_out = self.builder.buildAlloca(element_llvm_type, "first.value");

        var args = [_]llvm.ValueRef{
            list_ptr,
            llvm.Const.int64(self.ctx, @intCast(element_size)),
            value_out,
        };
        const success = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(list_first_fn), list_first_fn, &args, "first.success");

        // Build optional type: { i1, T }
        const i1_type = llvm.Types.int1(self.ctx);
        var opt_fields = [_]llvm.TypeRef{ i1_type, element_llvm_type };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Allocate the optional result
        const opt_alloca = self.builder.buildAlloca(opt_type, "first.optional");

        // Store the tag (success bool)
        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 0, "first.tag_ptr");
        _ = self.builder.buildStore(success, tag_ptr);

        // Store the value (if success)
        const value_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 1, "first.value_ptr");
        const loaded_value = self.builder.buildLoad(element_llvm_type, value_out, "first.loaded");
        _ = self.builder.buildStore(loaded_value, value_ptr);

        // Load and return the optional
        return self.builder.buildLoad(opt_type, opt_alloca, "first.result");
    }

    /// Emit list.last() - returns last element as Optional.
    fn emitListLast(self: *Emitter, list_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const list_last_fn = self.getOrDeclareListLast();

        // Get element type
        const element_type = self.getListElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type);
        const element_size = self.getLLVMTypeSize(element_llvm_type);

        // Allocate stack space for the output value
        const value_out = self.builder.buildAlloca(element_llvm_type, "last.value");

        var args = [_]llvm.ValueRef{
            list_ptr,
            llvm.Const.int64(self.ctx, @intCast(element_size)),
            value_out,
        };
        const success = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(list_last_fn), list_last_fn, &args, "last.success");

        // Build optional type: { i1, T }
        const i1_type = llvm.Types.int1(self.ctx);
        var opt_fields = [_]llvm.TypeRef{ i1_type, element_llvm_type };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Allocate the optional result
        const opt_alloca = self.builder.buildAlloca(opt_type, "last.optional");

        // Store the tag (success bool)
        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 0, "last.tag_ptr");
        _ = self.builder.buildStore(success, tag_ptr);

        // Store the value (if success)
        const value_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 1, "last.value_ptr");
        const loaded_value = self.builder.buildLoad(element_llvm_type, value_out, "last.loaded");
        _ = self.builder.buildStore(loaded_value, value_ptr);

        // Load and return the optional
        return self.builder.buildLoad(opt_type, opt_alloca, "last.result");
    }

    /// Emit list.clear() - clears the list.
    fn emitListClear(self: *Emitter, list_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const list_clear_fn = self.getOrDeclareListClear();
        var args = [_]llvm.ValueRef{list_ptr};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(list_clear_fn), list_clear_fn, &args, "");
        return llvm.Const.int32(self.ctx, 0);
    }

    // ========================================================================
    // Map Methods
    // ========================================================================
    // Map layout: { entries: *Entry, len: i32, capacity: i32, tombstone_count: i32 }
    // Entry layout: { state: i8, cached_hash: i32, key: K, value: V }
    // State: 0=EMPTY, 1=OCCUPIED, 2=TOMBSTONE

    /// Get the Map struct type: { ptr, i32, i32, i32 }
    fn getMapStructType(self: *Emitter) llvm.TypeRef {
        const i32_type = llvm.Types.int32(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);
        var fields = [_]llvm.TypeRef{ ptr_type, i32_type, i32_type, i32_type };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get the Map entry struct type for given key/value types.
    /// Entry layout: { state: i8, cached_hash: i32, key: K, value: V }
    fn getMapEntryType(self: *Emitter, key_type: llvm.TypeRef, value_type: llvm.TypeRef) llvm.TypeRef {
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var fields = [_]llvm.TypeRef{ i8_type, i32_type, key_type, value_type };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Emit Map.new[K,V]() - creates an empty map.
    /// Returns a Map struct with { null, 0, 0, 0 }.
    fn emitMapNew(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        _ = method; // Type args already validated by checker

        const map_type = self.getMapStructType();

        // Create an empty map struct { null, 0, 0, 0 }
        const null_ptr = llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        const zero_i32 = llvm.Const.int32(self.ctx, 0);

        var values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        return llvm.c.LLVMConstNamedStruct(map_type, &values, 4);
    }

    /// Emit Map.with_capacity[K,V](n) - creates a map with pre-allocated capacity.
    fn emitMapWithCapacity(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        // Get key/value types from type_args
        const type_args = method.type_args orelse return EmitError.InvalidAST;
        if (type_args.len != 2) return EmitError.InvalidAST;

        // Resolve types using type checker
        var key_type_klar: types.Type = undefined;
        var value_type_klar: types.Type = undefined;
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            key_type_klar = tc_mut.resolveTypeExpr(type_args[0]) catch return EmitError.InvalidAST;
            value_type_klar = tc_mut.resolveTypeExpr(type_args[1]) catch return EmitError.InvalidAST;
        } else {
            return EmitError.InvalidAST;
        }

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);
        const entry_size = self.getLLVMTypeSize(entry_type);

        // Emit the capacity argument
        if (method.args.len != 1) return EmitError.InvalidAST;
        const capacity = try self.emitExpr(method.args[0]);

        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const map_type = self.getMapStructType();

        // Convert capacity to i32 if needed
        const cap_type = llvm.typeOf(capacity);
        const cap_i32 = if (llvm.c.LLVMGetIntTypeWidth(cap_type) > 32)
            llvm.c.LLVMBuildTrunc(self.builder.ref, capacity, i32_type, "cap_i32")
        else
            capacity;

        // Calculate allocation size: capacity * entry_size
        const cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, cap_i32, i64_type, "cap_i64");
        const entry_size_val = llvm.Const.int64(self.ctx, @intCast(entry_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, cap_i64, entry_size_val, "alloc_size");

        // Call malloc(size)
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const entries_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "map.entries_ptr");

        // Zero-initialize the entries (all states = EMPTY = 0)
        const memset_fn = self.getOrDeclareMemset();
        var memset_args = [_]llvm.ValueRef{ entries_ptr, llvm.Const.int32(self.ctx, 0), alloc_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memset_fn), memset_fn, &memset_args, "");

        // Build the map struct { entries_ptr, 0, capacity, 0 }
        const map_alloca = self.builder.buildAlloca(map_type, "map.with_cap");

        // Store entries ptr (field 0)
        const ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_alloca, 0, "map.ptr_field");
        _ = self.builder.buildStore(entries_ptr, ptr_field);

        // Store len = 0 (field 1)
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_alloca, 1, "map.len_field");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_field);

        // Store capacity (field 2)
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_alloca, 2, "map.cap_field");
        _ = self.builder.buildStore(cap_i32, cap_field);

        // Store tombstone_count = 0 (field 3)
        const tomb_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_alloca, 3, "map.tomb_field");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), tomb_field);

        // Load and return the struct value
        return self.builder.buildLoad(map_type, map_alloca, "map.with_cap_val");
    }

    /// Emit map.len() - returns length as i32.
    fn emitMapLen(self: *Emitter, map_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const map_type = self.getMapStructType();
        const i32_type = llvm.Types.int32(self.ctx);

        // GEP to the len field (index 1)
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 1, "map.len.ptr");
        return self.builder.buildLoad(i32_type, len_ptr, "map.len");
    }

    /// Emit map.is_empty() - returns true if len == 0.
    fn emitMapIsEmpty(self: *Emitter, map_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const len = try self.emitMapLen(map_ptr);
        const zero = llvm.Const.int32(self.ctx, 0);
        return self.builder.buildICmp(llvm.c.LLVMIntEQ, len, zero, "map.is_empty");
    }

    /// Emit map.capacity() - returns capacity as i32.
    fn emitMapCapacity(self: *Emitter, map_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const map_type = self.getMapStructType();
        const i32_type = llvm.Types.int32(self.ctx);

        // GEP to the capacity field (index 2)
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap.ptr");
        return self.builder.buildLoad(i32_type, cap_ptr, "map.capacity");
    }

    /// Emit map.insert(key, value) - inserts a key-value pair.
    /// If the key exists, updates the value.
    fn emitMapInsert(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall, key: llvm.ValueRef, value: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Get key/value types from stored info or type checker
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);

        const map_type = self.getMapStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));

        // Compute hash of key
        const hash = try self.emitHashValue(key, key_type_klar);

        // Load capacity, len, and tombstone_count
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "map.cap");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 1, "map.len_ptr");
        const len = self.builder.buildLoad(i32_type, len_ptr, "map.len");
        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 3, "map.tomb_ptr");
        const tomb_count = self.builder.buildLoad(i32_type, tomb_ptr, "map.tomb");

        // Check if we need to grow:
        // 1. capacity == 0 (initial allocation)
        // 2. (len + tombstone_count + 1) * 4 > capacity * 3 (load > 75% after this insert)
        const is_zero_cap = self.builder.buildICmp(llvm.c.LLVMIntEQ, capacity, llvm.Const.int32(self.ctx, 0), "is_zero_cap");

        // Compute load check: (len + tomb + 1) * 4 > cap * 3
        const len_plus_tomb = llvm.c.LLVMBuildAdd(self.builder.ref, len, tomb_count, "len_plus_tomb");
        const len_plus_tomb_plus_1 = llvm.c.LLVMBuildAdd(self.builder.ref, len_plus_tomb, llvm.Const.int32(self.ctx, 1), "len_plus_1");
        const lhs = llvm.c.LLVMBuildMul(self.builder.ref, len_plus_tomb_plus_1, llvm.Const.int32(self.ctx, 4), "lhs");
        const rhs = llvm.c.LLVMBuildMul(self.builder.ref, capacity, llvm.Const.int32(self.ctx, 3), "rhs");
        const load_exceeded = self.builder.buildICmp(llvm.c.LLVMIntSGT, lhs, rhs, "load_exceeded");

        const need_grow = llvm.c.LLVMBuildOr(self.builder.ref, is_zero_cap, load_exceeded, "need_grow");

        // Create blocks
        const grow_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.grow");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.insert");
        const merge_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.insert.merge");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, need_grow, grow_block, insert_block);

        // Grow block - allocate new capacity and rehash
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, grow_block);
        const entry_size = self.getLLVMTypeSize(entry_type);

        // New capacity = max(8, capacity * 2)
        const doubled_cap = llvm.c.LLVMBuildMul(self.builder.ref, capacity, llvm.Const.int32(self.ctx, 2), "doubled_cap");
        const cmp_eight = self.builder.buildICmp(llvm.c.LLVMIntSGT, doubled_cap, llvm.Const.int32(self.ctx, 8), "cmp_eight");
        const new_cap = llvm.c.LLVMBuildSelect(self.builder.ref, cmp_eight, doubled_cap, llvm.Const.int32(self.ctx, 8), "new_cap");
        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "new_cap_i64");
        const entry_size_val = llvm.Const.int64(self.ctx, @intCast(entry_size));
        const new_alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, new_cap_i64, entry_size_val, "new_alloc_size");

        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{new_alloc_size};
        const new_entries = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "map.new_entries");

        // Zero-initialize new entries
        const memset_fn = self.getOrDeclareMemset();
        var memset_args = [_]llvm.ValueRef{ new_entries, llvm.Const.int32(self.ctx, 0), new_alloc_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memset_fn), memset_fn, &memset_args, "");

        // If capacity > 0, rehash old entries to new array
        const rehash_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.rehash");
        const rehash_done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.rehash_done");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_zero_cap, rehash_done_block, rehash_block);

        // Rehash block - iterate old entries and reinsert
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_block);
        const old_entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "old_entries_ptr");
        const old_entries = self.builder.buildLoad(ptr_type, old_entries_ptr_field, "old_entries");
        const new_cap_minus_1 = llvm.c.LLVMBuildSub(self.builder.ref, new_cap, llvm.Const.int32(self.ctx, 1), "new_cap_m1");

        // Loop through old entries
        const rehash_loop = llvm.c.LLVMAppendBasicBlock(current_fn, "map.rehash_loop");
        const rehash_check = llvm.c.LLVMAppendBasicBlock(current_fn, "map.rehash_check");
        const rehash_copy = llvm.c.LLVMAppendBasicBlock(current_fn, "map.rehash_copy");
        const rehash_next = llvm.c.LLVMAppendBasicBlock(current_fn, "map.rehash_next");
        const rehash_end = llvm.c.LLVMAppendBasicBlock(current_fn, "map.rehash_end");

        const rehash_idx_alloca = self.builder.buildAlloca(i32_type, "rehash_idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), rehash_idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_loop);

        // Rehash loop header
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_loop);
        const rehash_i = self.builder.buildLoad(i32_type, rehash_idx_alloca, "rehash_i");
        const rehash_done_cmp = self.builder.buildICmp(llvm.c.LLVMIntSGE, rehash_i, capacity, "rehash_done_cmp");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, rehash_done_cmp, rehash_end, rehash_check);

        // Check if old entry is OCCUPIED
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_check);
        const rehash_i_64 = llvm.c.LLVMBuildSExt(self.builder.ref, rehash_i, i64_type, "rehash_i_64");
        var old_entry_idx = [_]llvm.ValueRef{rehash_i_64};
        const old_entry = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, old_entries, &old_entry_idx, 1, "old_entry");
        const old_state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, old_entry, 0, "old_state_ptr");
        const old_state = self.builder.buildLoad(i8_type, old_state_ptr, "old_state");
        const is_occupied = self.builder.buildICmp(llvm.c.LLVMIntEQ, old_state, llvm.Const.int8(self.ctx, 1), "is_occupied");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occupied, rehash_copy, rehash_next);

        // Copy occupied entry to new array
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_copy);
        const old_hash_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, old_entry, 1, "old_hash_ptr");
        const old_hash = self.builder.buildLoad(i32_type, old_hash_ptr, "old_hash");
        const old_key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, old_entry, 2, "old_key_ptr");
        const old_key = self.builder.buildLoad(key_llvm_type, old_key_ptr, "old_key");
        const old_val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, old_entry, 3, "old_val_ptr");
        const old_val = self.builder.buildLoad(value_llvm_type, old_val_ptr, "old_val");

        // Find new slot using probe loop
        const new_idx = llvm.c.LLVMBuildAnd(self.builder.ref, old_hash, new_cap_minus_1, "new_idx");
        const new_idx_alloca = self.builder.buildAlloca(i32_type, "new_idx_alloca");
        _ = self.builder.buildStore(new_idx, new_idx_alloca);

        const rehash_probe = llvm.c.LLVMAppendBasicBlock(current_fn, "rehash_probe");
        const rehash_insert = llvm.c.LLVMAppendBasicBlock(current_fn, "rehash_insert");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_probe);

        // Probe for empty slot in new array
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_probe);
        const new_slot_idx = self.builder.buildLoad(i32_type, new_idx_alloca, "new_slot_idx");
        const new_slot_idx_64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_slot_idx, i64_type, "new_slot_idx_64");
        var new_slot_gep = [_]llvm.ValueRef{new_slot_idx_64};
        const new_slot = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, new_entries, &new_slot_gep, 1, "new_slot");
        const new_slot_state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, new_slot, 0, "new_slot_state");
        const new_slot_state = self.builder.buildLoad(i8_type, new_slot_state_ptr, "new_slot_state_val");
        const slot_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, new_slot_state, llvm.Const.int8(self.ctx, 0), "slot_empty");

        const rehash_probe_next = llvm.c.LLVMAppendBasicBlock(current_fn, "rehash_probe_next");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, slot_empty, rehash_insert, rehash_probe_next);

        // Continue probing
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_probe_next);
        const next_new_idx = llvm.c.LLVMBuildAdd(self.builder.ref, new_slot_idx, llvm.Const.int32(self.ctx, 1), "next_new_idx");
        const wrapped_new_idx = llvm.c.LLVMBuildAnd(self.builder.ref, next_new_idx, new_cap_minus_1, "wrapped_new_idx");
        _ = self.builder.buildStore(wrapped_new_idx, new_idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_probe);

        // Insert into new slot
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_insert);
        _ = self.builder.buildStore(llvm.Const.int8(self.ctx, 1), new_slot_state_ptr);
        const new_slot_hash = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, new_slot, 1, "new_slot_hash");
        _ = self.builder.buildStore(old_hash, new_slot_hash);
        const new_slot_key = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, new_slot, 2, "new_slot_key");
        _ = self.builder.buildStore(old_key, new_slot_key);
        const new_slot_val = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, new_slot, 3, "new_slot_val");
        _ = self.builder.buildStore(old_val, new_slot_val);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_next);

        // Increment rehash index
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_next);
        const next_rehash_i = llvm.c.LLVMBuildAdd(self.builder.ref, rehash_i, llvm.Const.int32(self.ctx, 1), "next_rehash_i");
        _ = self.builder.buildStore(next_rehash_i, rehash_idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_loop);

        // End of rehash - free old entries
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_end);
        const free_fn = self.getOrDeclareFree();
        var free_args = [_]llvm.ValueRef{old_entries};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(free_fn), free_fn, &free_args, "");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_done_block);

        // Rehash done - update map fields
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_done_block);
        const entries_ptr_grow = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_grow");
        _ = self.builder.buildStore(new_entries, entries_ptr_grow);
        _ = self.builder.buildStore(new_cap, cap_ptr);
        // Reset tombstone count after rehash
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), tomb_ptr);

        _ = llvm.c.LLVMBuildBr(self.builder.ref, insert_block);

        // Insert block - do the actual insert
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);

        // Reload entries and capacity after potential grow
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_field");
        const entries_ptr_val = self.builder.buildLoad(ptr_type, entries_ptr_field, "map.entries");
        const cap_val = self.builder.buildLoad(i32_type, cap_ptr, "map.cap_val");

        // Compute initial index: hash & (capacity - 1)
        const cap_minus_one = llvm.c.LLVMBuildSub(self.builder.ref, cap_val, llvm.Const.int32(self.ctx, 1), "cap_m1");
        const init_index = llvm.c.LLVMBuildAnd(self.builder.ref, hash, cap_minus_one, "init_idx");

        // Allocate storage for loop variables
        const index_alloca = self.builder.buildAlloca(i32_type, "idx_alloca");
        _ = self.builder.buildStore(init_index, index_alloca);

        // Probe loop
        const probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.probe");
        const found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.found");
        const empty_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.empty");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.next");

        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_block);

        // Probe loop header
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_block);
        const current_idx = self.builder.buildLoad(i32_type, index_alloca, "cur_idx");
        const current_idx_64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_idx, i64_type, "cur_idx_64");

        // GEP to entry
        var entry_indices = [_]llvm.ValueRef{current_idx_64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr_val, &entry_indices, 1, "entry_ptr");

        // Load state
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");

        // Check if EMPTY (0) or TOMBSTONE (2) - can insert here
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 0), "is_empty");
        const is_tombstone = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 2), "is_tomb");
        const can_insert = llvm.c.LLVMBuildOr(self.builder.ref, is_empty, is_tombstone, "can_insert");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, can_insert, empty_block, next_block);

        // Empty/tombstone slot - insert here
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, empty_block);

        // Store state = OCCUPIED (1)
        _ = self.builder.buildStore(llvm.Const.int8(self.ctx, 1), state_ptr);

        // Store cached hash
        const hash_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 1, "hash_ptr");
        _ = self.builder.buildStore(hash, hash_ptr);

        // Store key
        const key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "key_ptr");
        _ = self.builder.buildStore(key, key_ptr);

        // Store value
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "val_ptr");
        _ = self.builder.buildStore(value, val_ptr);

        // Increment len if this was an empty slot (not tombstone)
        const inc_len_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.inc_len");
        const dec_tomb_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.dec_tomb");
        const after_inc_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.after_inc");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty, inc_len_block, dec_tomb_block);

        // Increment len
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, inc_len_block);
        const len_ptr_insert = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 1, "map.len_ptr");
        const old_len = self.builder.buildLoad(i32_type, len_ptr_insert, "old_len");
        const new_len = llvm.c.LLVMBuildAdd(self.builder.ref, old_len, llvm.Const.int32(self.ctx, 1), "new_len");
        _ = self.builder.buildStore(new_len, len_ptr_insert);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, after_inc_block);

        // Decrement tombstone count and increment len
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, dec_tomb_block);
        const tomb_ptr_dec = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 3, "map.tomb_ptr");
        const old_tomb = self.builder.buildLoad(i32_type, tomb_ptr_dec, "old_tomb");
        const new_tomb = llvm.c.LLVMBuildSub(self.builder.ref, old_tomb, llvm.Const.int32(self.ctx, 1), "new_tomb");
        _ = self.builder.buildStore(new_tomb, tomb_ptr_dec);

        const len_ptr_tomb = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 1, "map.len_ptr_tomb");
        const old_len2 = self.builder.buildLoad(i32_type, len_ptr_tomb, "old_len2");
        const new_len2 = llvm.c.LLVMBuildAdd(self.builder.ref, old_len2, llvm.Const.int32(self.ctx, 1), "new_len2");
        _ = self.builder.buildStore(new_len2, len_ptr_tomb);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, after_inc_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, after_inc_block);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, merge_block);

        // Next block - continue probing
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);

        // Check if this slot has the same key (for update)
        const stored_hash_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 1, "stored_hash_ptr");
        const stored_hash = self.builder.buildLoad(i32_type, stored_hash_ptr, "stored_hash");
        const hash_match = self.builder.buildICmp(llvm.c.LLVMIntEQ, hash, stored_hash, "hash_match");

        // If hash matches, check actual key equality
        const check_key_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.check_key");
        const continue_probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.continue_probe");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, hash_match, check_key_block, continue_probe_block);

        // Check key equality
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_key_block);
        const stored_key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "stored_key_ptr");
        const stored_key = self.builder.buildLoad(key_llvm_type, stored_key_ptr, "stored_key");
        const keys_equal = try self.emitEqComparison(key, stored_key, key_type_klar);

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, keys_equal, found_block, continue_probe_block);

        // Found - update value
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, found_block);
        const update_val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "update_val_ptr");
        _ = self.builder.buildStore(value, update_val_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, merge_block);

        // Continue probing
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, continue_probe_block);
        const next_idx_raw = llvm.c.LLVMBuildAdd(self.builder.ref, current_idx, llvm.Const.int32(self.ctx, 1), "next_idx_raw");
        const next_idx = llvm.c.LLVMBuildAnd(self.builder.ref, next_idx_raw, cap_minus_one, "next_idx");
        _ = self.builder.buildStore(next_idx, index_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_block);

        // Merge block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, merge_block);
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit map.get(key) -> ?V - returns the value for key, or None if not found.
    fn emitMapGet(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall, key: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Get key/value types from stored info or type checker
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);

        const map_type = self.getMapStructType();
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Build optional type: { tag: i1, value: V }
        var opt_fields = [_]llvm.TypeRef{ i1_type, value_llvm_type };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);
        const opt_alloca = self.builder.buildAlloca(opt_type, "map.get.opt");

        // Initialize to None
        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 0, "opt.tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr);

        // Load capacity and check if zero
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "map.cap");
        const is_empty_cap = self.builder.buildICmp(llvm.c.LLVMIntEQ, capacity, llvm.Const.int32(self.ctx, 0), "is_empty_cap");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const search_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.get.search");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.get.done");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty_cap, done_block, search_block);

        // Search block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, search_block);

        // Compute hash
        const hash = try self.emitHashValue(key, key_type_klar);

        // Load entries
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_field");
        const entries_ptr_val = self.builder.buildLoad(ptr_type, entries_ptr_field, "map.entries");

        // Compute initial index
        const cap_minus_one = llvm.c.LLVMBuildSub(self.builder.ref, capacity, llvm.Const.int32(self.ctx, 1), "cap_m1");
        const init_index = llvm.c.LLVMBuildAnd(self.builder.ref, hash, cap_minus_one, "init_idx");

        // Allocate loop variable
        const index_alloca = self.builder.buildAlloca(i32_type, "idx_alloca");
        _ = self.builder.buildStore(init_index, index_alloca);

        // Probe loop
        const probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.get.probe");
        const found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.get.found");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.get.next");
        const not_found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.get.not_found");

        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_block);

        // Probe header
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_block);
        const current_idx = self.builder.buildLoad(i32_type, index_alloca, "cur_idx");
        const current_idx_64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_idx, i64_type, "cur_idx_64");

        // GEP to entry
        var entry_indices = [_]llvm.ValueRef{current_idx_64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr_val, &entry_indices, 1, "entry_ptr");

        // Load state
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");

        // If EMPTY (0), key not found
        const is_empty_state = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 0), "is_empty");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty_state, not_found_block, next_block);

        // Not found
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, not_found_block);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        // Next - check if occupied and hash matches
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const is_occupied = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occupied");

        const check_hash_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.get.check_hash");
        const continue_probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.get.continue");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occupied, check_hash_block, continue_probe_block);

        // Check hash
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_hash_block);
        const stored_hash_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 1, "stored_hash_ptr");
        const stored_hash = self.builder.buildLoad(i32_type, stored_hash_ptr, "stored_hash");
        const hash_match = self.builder.buildICmp(llvm.c.LLVMIntEQ, hash, stored_hash, "hash_match");

        const check_key_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.get.check_key");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, hash_match, check_key_block, continue_probe_block);

        // Check key equality
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_key_block);
        const stored_key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "stored_key_ptr");
        const stored_key = self.builder.buildLoad(key_llvm_type, stored_key_ptr, "stored_key");
        const keys_equal = try self.emitEqComparison(key, stored_key, key_type_klar);

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, keys_equal, found_block, continue_probe_block);

        // Found - set optional to Some(value)
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, found_block);
        const found_val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "found_val_ptr");
        const found_val = self.builder.buildLoad(value_llvm_type, found_val_ptr, "found_val");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        const opt_val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 1, "opt.val_ptr");
        _ = self.builder.buildStore(found_val, opt_val_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        // Continue probing
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, continue_probe_block);
        const next_idx_raw = llvm.c.LLVMBuildAdd(self.builder.ref, current_idx, llvm.Const.int32(self.ctx, 1), "next_idx_raw");
        const next_idx = llvm.c.LLVMBuildAnd(self.builder.ref, next_idx_raw, cap_minus_one, "next_idx");
        _ = self.builder.buildStore(next_idx, index_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_block);

        // Done
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(opt_type, opt_alloca, "map.get.result");
    }

    /// Emit map.remove(key) -> ?V - removes key and returns its value, or None.
    fn emitMapRemove(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall, key: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Similar to get, but marks entry as TOMBSTONE if found
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);

        const map_type = self.getMapStructType();
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Build optional type
        var opt_fields = [_]llvm.TypeRef{ i1_type, value_llvm_type };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);
        const opt_alloca = self.builder.buildAlloca(opt_type, "map.remove.opt");

        // Initialize to None
        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 0, "opt.tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr);

        // Check capacity
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "map.cap");
        const is_empty_cap = self.builder.buildICmp(llvm.c.LLVMIntEQ, capacity, llvm.Const.int32(self.ctx, 0), "is_empty_cap");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const search_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.remove.search");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.remove.done");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty_cap, done_block, search_block);

        // Search block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, search_block);
        const hash = try self.emitHashValue(key, key_type_klar);

        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_field");
        const entries_ptr_val = self.builder.buildLoad(ptr_type, entries_ptr_field, "map.entries");

        const cap_minus_one = llvm.c.LLVMBuildSub(self.builder.ref, capacity, llvm.Const.int32(self.ctx, 1), "cap_m1");
        const init_index = llvm.c.LLVMBuildAnd(self.builder.ref, hash, cap_minus_one, "init_idx");

        const index_alloca = self.builder.buildAlloca(i32_type, "idx_alloca");
        _ = self.builder.buildStore(init_index, index_alloca);

        const probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.remove.probe");
        const found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.remove.found");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.remove.next");
        const not_found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.remove.not_found");

        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_block);

        // Probe header
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_block);
        const current_idx = self.builder.buildLoad(i32_type, index_alloca, "cur_idx");
        const current_idx_64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_idx, i64_type, "cur_idx_64");

        var entry_indices = [_]llvm.ValueRef{current_idx_64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr_val, &entry_indices, 1, "entry_ptr");

        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");

        const is_empty_state = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 0), "is_empty");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty_state, not_found_block, next_block);

        // Not found
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, not_found_block);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        // Next
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const is_occupied = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occupied");

        const check_hash_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.remove.check_hash");
        const continue_probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.remove.continue");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occupied, check_hash_block, continue_probe_block);

        // Check hash
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_hash_block);
        const stored_hash_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 1, "stored_hash_ptr");
        const stored_hash = self.builder.buildLoad(i32_type, stored_hash_ptr, "stored_hash");
        const hash_match = self.builder.buildICmp(llvm.c.LLVMIntEQ, hash, stored_hash, "hash_match");

        const check_key_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.remove.check_key");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, hash_match, check_key_block, continue_probe_block);

        // Check key
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_key_block);
        const stored_key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "stored_key_ptr");
        const stored_key = self.builder.buildLoad(key_llvm_type, stored_key_ptr, "stored_key");
        const keys_equal = try self.emitEqComparison(key, stored_key, key_type_klar);

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, keys_equal, found_block, continue_probe_block);

        // Found - remove entry
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, found_block);
        const found_val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "found_val_ptr");
        const found_val = self.builder.buildLoad(value_llvm_type, found_val_ptr, "found_val");

        // Set optional to Some(value)
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        const opt_val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, opt_alloca, 1, "opt.val_ptr");
        _ = self.builder.buildStore(found_val, opt_val_ptr);

        // Mark as TOMBSTONE
        _ = self.builder.buildStore(llvm.Const.int8(self.ctx, 2), state_ptr);

        // Decrement len, increment tombstone count
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 1, "map.len_ptr");
        const old_len = self.builder.buildLoad(i32_type, len_ptr, "old_len");
        const new_len = llvm.c.LLVMBuildSub(self.builder.ref, old_len, llvm.Const.int32(self.ctx, 1), "new_len");
        _ = self.builder.buildStore(new_len, len_ptr);

        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 3, "map.tomb_ptr");
        const old_tomb = self.builder.buildLoad(i32_type, tomb_ptr, "old_tomb");
        const new_tomb = llvm.c.LLVMBuildAdd(self.builder.ref, old_tomb, llvm.Const.int32(self.ctx, 1), "new_tomb");
        _ = self.builder.buildStore(new_tomb, tomb_ptr);

        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        // Continue probing
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, continue_probe_block);
        const next_idx_raw = llvm.c.LLVMBuildAdd(self.builder.ref, current_idx, llvm.Const.int32(self.ctx, 1), "next_idx_raw");
        const next_idx = llvm.c.LLVMBuildAnd(self.builder.ref, next_idx_raw, cap_minus_one, "next_idx");
        _ = self.builder.buildStore(next_idx, index_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_block);

        // Done
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(opt_type, opt_alloca, "map.remove.result");
    }

    /// Emit map.contains_key(key) -> bool
    fn emitMapContainsKey(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall, key: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Similar to get but returns bool instead of optional
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);

        const map_type = self.getMapStructType();
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        const result_alloca = self.builder.buildAlloca(i1_type, "map.contains.result");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), result_alloca);

        // Check capacity
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "map.cap");
        const is_empty_cap = self.builder.buildICmp(llvm.c.LLVMIntEQ, capacity, llvm.Const.int32(self.ctx, 0), "is_empty_cap");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const search_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.contains.search");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.contains.done");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty_cap, done_block, search_block);

        // Search
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, search_block);
        const hash = try self.emitHashValue(key, key_type_klar);

        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_field");
        const entries_ptr_val = self.builder.buildLoad(ptr_type, entries_ptr_field, "map.entries");

        const cap_minus_one = llvm.c.LLVMBuildSub(self.builder.ref, capacity, llvm.Const.int32(self.ctx, 1), "cap_m1");
        const init_index = llvm.c.LLVMBuildAnd(self.builder.ref, hash, cap_minus_one, "init_idx");

        const index_alloca = self.builder.buildAlloca(i32_type, "idx_alloca");
        _ = self.builder.buildStore(init_index, index_alloca);

        const probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.contains.probe");
        const found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.contains.found");
        const not_found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.contains.not_found");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.contains.next");

        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_block);

        // Probe
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_block);
        const current_idx = self.builder.buildLoad(i32_type, index_alloca, "cur_idx");
        const current_idx_64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_idx, i64_type, "cur_idx_64");

        var entry_indices = [_]llvm.ValueRef{current_idx_64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr_val, &entry_indices, 1, "entry_ptr");

        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");

        const is_empty_state = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 0), "is_empty");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty_state, not_found_block, next_block);

        // Not found
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, not_found_block);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        // Next
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const is_occupied = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occupied");

        const check_hash_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.contains.check_hash");
        const continue_probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.contains.continue");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occupied, check_hash_block, continue_probe_block);

        // Check hash
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_hash_block);
        const stored_hash_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 1, "stored_hash_ptr");
        const stored_hash = self.builder.buildLoad(i32_type, stored_hash_ptr, "stored_hash");
        const hash_match = self.builder.buildICmp(llvm.c.LLVMIntEQ, hash, stored_hash, "hash_match");

        const check_key_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.contains.check_key");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, hash_match, check_key_block, continue_probe_block);

        // Check key
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_key_block);
        const stored_key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "stored_key_ptr");
        const stored_key = self.builder.buildLoad(key_llvm_type, stored_key_ptr, "stored_key");
        const keys_equal = try self.emitEqComparison(key, stored_key, key_type_klar);

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, keys_equal, found_block, continue_probe_block);

        // Found
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, found_block);
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), result_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        // Continue
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, continue_probe_block);
        const next_idx_raw = llvm.c.LLVMBuildAdd(self.builder.ref, current_idx, llvm.Const.int32(self.ctx, 1), "next_idx_raw");
        const next_idx = llvm.c.LLVMBuildAnd(self.builder.ref, next_idx_raw, cap_minus_one, "next_idx");
        _ = self.builder.buildStore(next_idx, index_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_block);

        // Done
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(i1_type, result_alloca, "map.contains.result");
    }

    /// Emit map.keys() -> List[K]
    fn emitMapKeys(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        // Get key/value types from stored info or type checker
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);
        const key_size = self.getLLVMTypeSize(key_llvm_type);

        const map_type = self.getMapStructType();
        const list_type = self.getListStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty list for result
        const list_alloca = self.builder.buildAlloca(list_type, "keys_list");
        _ = self.builder.buildStore(llvm.c.LLVMConstNull(ptr_type), llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 0, ""));
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 1, ""));
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 2, ""));

        // Get map len and capacity
        const len = try self.emitMapLen(map_ptr);
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "map.cap");

        // If len == 0, return empty list
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, len, llvm.Const.int32(self.ctx, 0), "is_empty");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const collect_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.keys.collect");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.keys.done");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty, done_block, collect_block);

        // Collect keys
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, collect_block);

        // Allocate list with capacity = len
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, len, i64_type, "len_i64");
        const key_size_val = llvm.Const.int64(self.ctx, @intCast(key_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, len_i64, key_size_val, "alloc_size");

        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const keys_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "keys_ptr");

        // Store to list
        _ = self.builder.buildStore(keys_ptr, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 0, ""));
        _ = self.builder.buildStore(len, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 2, ""));

        // Loop through entries
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_field");
        const entries_ptr_val = self.builder.buildLoad(ptr_type, entries_ptr_field, "map.entries");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        const list_idx_alloca = self.builder.buildAlloca(i32_type, "list_idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), list_idx_alloca);

        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.keys.loop");
        const body_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.keys.body");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.keys.next");
        const end_loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.keys.end_loop");

        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        // Loop header
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const continue_loop = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_loop, body_block, end_loop_block);

        // Body
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, body_block);
        const idx_64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_64");
        var entry_indices = [_]llvm.ValueRef{idx_64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr_val, &entry_indices, 1, "entry_ptr");

        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occupied = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occupied");

        const copy_key_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.keys.copy");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occupied, copy_key_block, next_block);

        // Copy key
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, copy_key_block);
        const key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "key_ptr");
        const key_val = self.builder.buildLoad(key_llvm_type, key_ptr, "key_val");

        const list_idx = self.builder.buildLoad(i32_type, list_idx_alloca, "list_idx");
        const list_idx_64 = llvm.c.LLVMBuildSExt(self.builder.ref, list_idx, i64_type, "list_idx_64");
        var key_indices = [_]llvm.ValueRef{list_idx_64};
        const dest_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, key_llvm_type, keys_ptr, &key_indices, 1, "dest_ptr");
        _ = self.builder.buildStore(key_val, dest_ptr);

        const new_list_idx = llvm.c.LLVMBuildAdd(self.builder.ref, list_idx, llvm.Const.int32(self.ctx, 1), "new_list_idx");
        _ = self.builder.buildStore(new_list_idx, list_idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        // Next
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const new_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "new_idx");
        _ = self.builder.buildStore(new_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        // End loop
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, end_loop_block);
        const final_list_len = self.builder.buildLoad(i32_type, list_idx_alloca, "final_len");
        _ = self.builder.buildStore(final_list_len, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 1, ""));
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        // Done
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(list_type, list_alloca, "map.keys.result");
    }

    /// Emit map.values() -> List[V]
    fn emitMapValues(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        // Similar to keys() but collects values
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);
        const value_size = self.getLLVMTypeSize(value_llvm_type);

        const map_type = self.getMapStructType();
        const list_type = self.getListStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty list
        const list_alloca = self.builder.buildAlloca(list_type, "values_list");
        _ = self.builder.buildStore(llvm.c.LLVMConstNull(ptr_type), llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 0, ""));
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 1, ""));
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 2, ""));

        const len = try self.emitMapLen(map_ptr);
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "map.cap");

        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, len, llvm.Const.int32(self.ctx, 0), "is_empty");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const collect_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.values.collect");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.values.done");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty, done_block, collect_block);

        // Collect values
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, collect_block);

        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, len, i64_type, "len_i64");
        const value_size_val = llvm.Const.int64(self.ctx, @intCast(value_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, len_i64, value_size_val, "alloc_size");

        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const values_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "values_ptr");

        _ = self.builder.buildStore(values_ptr, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 0, ""));
        _ = self.builder.buildStore(len, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 2, ""));

        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_field");
        const entries_ptr_val = self.builder.buildLoad(ptr_type, entries_ptr_field, "map.entries");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        const list_idx_alloca = self.builder.buildAlloca(i32_type, "list_idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), list_idx_alloca);

        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.values.loop");
        const body_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.values.body");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.values.next");
        const end_loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.values.end_loop");

        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const continue_loop = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_loop, body_block, end_loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, body_block);
        const idx_64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_64");
        var entry_indices = [_]llvm.ValueRef{idx_64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr_val, &entry_indices, 1, "entry_ptr");

        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occupied = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occupied");

        const copy_val_block = llvm.c.LLVMAppendBasicBlock(current_fn, "map.values.copy");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occupied, copy_val_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, copy_val_block);
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "val_ptr");
        const val = self.builder.buildLoad(value_llvm_type, val_ptr, "val");

        const list_idx = self.builder.buildLoad(i32_type, list_idx_alloca, "list_idx");
        const list_idx_64 = llvm.c.LLVMBuildSExt(self.builder.ref, list_idx, i64_type, "list_idx_64");
        var val_indices = [_]llvm.ValueRef{list_idx_64};
        const dest_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, value_llvm_type, values_ptr, &val_indices, 1, "dest_ptr");
        _ = self.builder.buildStore(val, dest_ptr);

        const new_list_idx = llvm.c.LLVMBuildAdd(self.builder.ref, list_idx, llvm.Const.int32(self.ctx, 1), "new_list_idx");
        _ = self.builder.buildStore(new_list_idx, list_idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const new_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "new_idx");
        _ = self.builder.buildStore(new_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, end_loop_block);
        const final_list_len = self.builder.buildLoad(i32_type, list_idx_alloca, "final_len");
        _ = self.builder.buildStore(final_list_len, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 1, ""));
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(list_type, list_alloca, "map.values.result");
    }

    /// Emit map.clear() - resets to empty state.
    fn emitMapClear(self: *Emitter, map_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const map_type = self.getMapStructType();
        const i32_type = llvm.Types.int32(self.ctx);

        // Set len = 0
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 1, "map.len_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_ptr);

        // Set tombstone_count = 0
        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 3, "map.tomb_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), tomb_ptr);

        // Zero out entries (set all states to EMPTY)
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "map.cap");

        // Get entries ptr
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_field");
        const entries_ptr_val = self.builder.buildLoad(llvm.Types.pointer(self.ctx), entries_ptr_field, "map.entries");

        // For simplicity, just set all state bytes to 0
        // This is a simplification - a real impl might iterate
        // We need to know the entry size... for now use 64 bytes as estimate
        const cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, capacity, llvm.Types.int64(self.ctx), "cap_i64");
        const entry_size_estimate = llvm.Const.int64(self.ctx, 64); // Conservative estimate
        const clear_size = llvm.c.LLVMBuildMul(self.builder.ref, cap_i64, entry_size_estimate, "clear_size");

        const memset_fn = self.getOrDeclareMemset();
        var memset_args = [_]llvm.ValueRef{ entries_ptr_val, llvm.Const.int32(self.ctx, 0), clear_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memset_fn), memset_fn, &memset_args, "");

        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit map.clone() -> Map[K,V] - creates a deep copy.
    fn emitMapClone(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);
        const entry_size = self.getLLVMTypeSize(entry_type);

        const map_type = self.getMapStructType();
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load len, capacity, tombstone_count
        const len = try self.emitMapLen(map_ptr);
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "map.cap");
        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 3, "map.tomb_ptr");
        const tomb_count = self.builder.buildLoad(i32_type, tomb_ptr, "map.tomb");

        // Allocate new entries
        const cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, capacity, i64_type, "cap_i64");
        const entry_size_val = llvm.Const.int64(self.ctx, @intCast(entry_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, cap_i64, entry_size_val, "alloc_size");

        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const new_entries = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "new_entries");

        // Copy entries
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_field");
        const old_entries = self.builder.buildLoad(ptr_type, entries_ptr_field, "old_entries");

        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ new_entries, old_entries, alloc_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Build new map struct
        const clone_alloca = self.builder.buildAlloca(map_type, "map.clone");
        const clone_entries_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, clone_alloca, 0, "clone.entries_ptr");
        const clone_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, clone_alloca, 1, "clone.len_ptr");
        const clone_cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, clone_alloca, 2, "clone.cap_ptr");
        const clone_tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, clone_alloca, 3, "clone.tomb_ptr");

        _ = self.builder.buildStore(new_entries, clone_entries_ptr);
        _ = self.builder.buildStore(len, clone_len_ptr);
        _ = self.builder.buildStore(capacity, clone_cap_ptr);
        _ = self.builder.buildStore(tomb_count, clone_tomb_ptr);

        return self.builder.buildLoad(map_type, clone_alloca, "map.clone.result");
    }

    /// Emit map.drop() - frees the map's memory.
    fn emitMapDrop(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        _ = method;

        const map_type = self.getMapStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load entries ptr
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "map.entries_ptr_field");
        const entries_ptr_val = self.builder.buildLoad(ptr_type, entries_ptr_field, "map.entries");

        // Free entries
        const free_fn = self.getOrDeclareFree();
        var free_args = [_]llvm.ValueRef{entries_ptr_val};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(free_fn), free_fn, &free_args, "");

        // Set to null state
        _ = self.builder.buildStore(llvm.c.LLVMConstNull(ptr_type), entries_ptr_field);
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 1, "map.len_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_ptr);
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "map.cap_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), cap_ptr);
        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 3, "map.tomb_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), tomb_ptr);

        return llvm.Const.int32(self.ctx, 0);
    }

    // ========================================================================
    // Map Iterator Adapters
    // ========================================================================

    /// Emit map.take(n) - returns a new map with first n entries.
    fn emitMapTake(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall, count: llvm.ValueRef) EmitError!llvm.ValueRef {
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);

        const map_type = self.getMapStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty result map
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var result_values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        const empty_map = llvm.c.LLVMConstNamedStruct(map_type, &result_values, 4);
        const result_alloca = self.builder.buildAlloca(map_type, "take_result");
        _ = self.builder.buildStore(empty_map, result_alloca);

        // Clamp count to >= 0
        const count_clamped = llvm.c.LLVMBuildSelect(
            self.builder.ref,
            self.builder.buildICmp(llvm.c.LLVMIntSLT, count, zero_i32, "take.count_neg"),
            zero_i32,
            count,
            "take.count_clamped",
        );

        // Load map fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_check");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_insert");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        const taken_alloca = self.builder.buildAlloca(i32_type, "taken");
        _ = self.builder.buildStore(zero_i32, idx_alloca);
        _ = self.builder.buildStore(zero_i32, taken_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const taken = self.builder.buildLoad(i32_type, taken_alloca, "taken");
        const idx_ok = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "idx_ok");
        const taken_ok = self.builder.buildICmp(llvm.c.LLVMIntSLT, taken, count_clamped, "taken_ok");
        const continue_cond = llvm.c.LLVMBuildAnd(self.builder.ref, idx_ok, taken_ok, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, insert_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        const key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "key_ptr");
        const key = self.builder.buildLoad(key_llvm_type, key_ptr, "key");
        const value_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "value_ptr");
        const value = self.builder.buildLoad(value_llvm_type, value_ptr, "value");
        _ = try self.emitMapInsert(result_alloca, method, key, value);
        const new_taken = llvm.c.LLVMBuildAdd(self.builder.ref, taken, llvm.Const.int32(self.ctx, 1), "new_taken");
        _ = self.builder.buildStore(new_taken, taken_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(map_type, result_alloca, "take.result");
    }

    /// Emit map.skip(n) - returns a new map skipping first n entries.
    fn emitMapSkip(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall, count: llvm.ValueRef) EmitError!llvm.ValueRef {
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);

        const map_type = self.getMapStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty result map
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var result_values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        const empty_map = llvm.c.LLVMConstNamedStruct(map_type, &result_values, 4);
        const result_alloca = self.builder.buildAlloca(map_type, "skip_result");
        _ = self.builder.buildStore(empty_map, result_alloca);

        // Clamp count to >= 0
        const count_clamped = llvm.c.LLVMBuildSelect(
            self.builder.ref,
            self.builder.buildICmp(llvm.c.LLVMIntSLT, count, zero_i32, "skip.count_neg"),
            zero_i32,
            count,
            "skip.count_clamped",
        );

        // Load map fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_check");
        const process_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_process");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_insert");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        const skipped_alloca = self.builder.buildAlloca(i32_type, "skipped");
        _ = self.builder.buildStore(zero_i32, idx_alloca);
        _ = self.builder.buildStore(zero_i32, skipped_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const continue_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, process_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, process_block);
        const skipped = self.builder.buildLoad(i32_type, skipped_alloca, "skipped");
        const should_insert = self.builder.buildICmp(llvm.c.LLVMIntSGE, skipped, count_clamped, "should_insert");
        const new_skipped = llvm.c.LLVMBuildAdd(self.builder.ref, skipped, llvm.Const.int32(self.ctx, 1), "new_skipped");
        _ = self.builder.buildStore(new_skipped, skipped_alloca);
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, should_insert, insert_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        const key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "key_ptr");
        const key = self.builder.buildLoad(key_llvm_type, key_ptr, "key");
        const value_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "value_ptr");
        const value = self.builder.buildLoad(value_llvm_type, value_ptr, "value");
        _ = try self.emitMapInsert(result_alloca, method, key, value);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(map_type, result_alloca, "skip.result");
    }

    /// Emit map.filter(predicate) - returns a new map with entries matching predicate.
    fn emitMapFilter(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall, closure_value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);

        const map_type = self.getMapStructType();
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty result map
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var result_values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        const empty_map = llvm.c.LLVMConstNamedStruct(map_type, &result_values, 4);
        const result_alloca = self.builder.buildAlloca(map_type, "filter_result");
        _ = self.builder.buildStore(empty_map, result_alloca);

        // Extract closure
        const closure_struct_type = self.getClosureStructType();
        const closure_alloca = self.builder.buildAlloca(closure_struct_type, "filter.closure_tmp");
        _ = self.builder.buildStore(closure_value, closure_alloca);

        var fn_ptr_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 0) };
        const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "filter.fn_ptr_ptr");
        const fn_ptr = self.builder.buildLoad(ptr_type, fn_ptr_gep, "filter.fn_ptr");

        var env_ptr_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 1) };
        const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "filter.env_ptr_ptr");
        const env_ptr = self.builder.buildLoad(ptr_type, env_ptr_gep, "filter.env_ptr");

        // Build function type: fn(env_ptr, key, value) -> bool
        var param_types = [_]llvm.TypeRef{ ptr_type, key_llvm_type, value_llvm_type };
        const closure_fn_type = llvm.Types.function(i1_type, &param_types, false);

        // Load map fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_check");
        const test_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_test");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_insert");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        _ = self.builder.buildStore(zero_i32, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const continue_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, test_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, test_block);
        const key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "key_ptr");
        const key = self.builder.buildLoad(key_llvm_type, key_ptr, "key");
        const value_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "value_ptr");
        const value = self.builder.buildLoad(value_llvm_type, value_ptr, "value");
        // Call predicate closure with key and value
        var call_args = [_]llvm.ValueRef{ env_ptr, key, value };
        const pred_result = self.builder.buildCall(closure_fn_type, fn_ptr, &call_args, "pred_result");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, pred_result, insert_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        _ = try self.emitMapInsert(result_alloca, method, key, value);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(map_type, result_alloca, "filter.result");
    }

    /// Emit map.map_values(transform) - returns a new map with transformed values.
    fn emitMapMapValues(self: *Emitter, map_ptr: llvm.ValueRef, method: *ast.MethodCall, closure_value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const key_type_klar = self.getMapKeyType(method.object) orelse return EmitError.InvalidAST;
        const value_type_klar = self.getMapValueType(method.object) orelse return EmitError.InvalidAST;

        const key_llvm_type = self.typeToLLVM(key_type_klar);
        const value_llvm_type = self.typeToLLVM(value_type_klar);
        const entry_type = self.getMapEntryType(key_llvm_type, value_llvm_type);

        // Get destination value type from closure's return type
        const dest_value_type = if (self.type_checker) |tc| blk: {
            const tc_mut = @constCast(tc);
            const closure_type = tc_mut.checkExpr(method.args[0]);
            if (closure_type == .function) {
                break :blk closure_type.function.return_type;
            }
            break :blk value_type_klar;
        } else value_type_klar;

        const dest_value_llvm_type = self.typeToLLVM(dest_value_type);

        const map_type = self.getMapStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty result map
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var result_values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        const empty_map = llvm.c.LLVMConstNamedStruct(map_type, &result_values, 4);
        const result_alloca = self.builder.buildAlloca(map_type, "mapval_result");
        _ = self.builder.buildStore(empty_map, result_alloca);

        // Extract closure
        const closure_struct_type = self.getClosureStructType();
        const closure_alloca = self.builder.buildAlloca(closure_struct_type, "mapval.closure_tmp");
        _ = self.builder.buildStore(closure_value, closure_alloca);

        var fn_ptr_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 0) };
        const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "mapval.fn_ptr_ptr");
        const fn_ptr = self.builder.buildLoad(ptr_type, fn_ptr_gep, "mapval.fn_ptr");

        var env_ptr_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 1) };
        const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "mapval.env_ptr_ptr");
        const env_ptr = self.builder.buildLoad(ptr_type, env_ptr_gep, "mapval.env_ptr");

        // Build function type: fn(env_ptr, value) -> new_value
        var param_types = [_]llvm.TypeRef{ ptr_type, value_llvm_type };
        const closure_fn_type = llvm.Types.function(dest_value_llvm_type, &param_types, false);

        // Load map fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, map_type, map_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "mapval_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "mapval_check");
        const transform_block = llvm.c.LLVMAppendBasicBlock(current_fn, "mapval_transform");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "mapval_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "mapval_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        _ = self.builder.buildStore(zero_i32, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const continue_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, transform_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, transform_block);
        const key_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "key_ptr");
        const key = self.builder.buildLoad(key_llvm_type, key_ptr, "key");
        const value_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 3, "value_ptr");
        const value = self.builder.buildLoad(value_llvm_type, value_ptr, "value");
        // Call transform closure with value
        var call_args = [_]llvm.ValueRef{ env_ptr, value };
        const transformed = self.builder.buildCall(closure_fn_type, fn_ptr, &call_args, "transformed");
        // Insert key with new value
        _ = try self.emitMapInsert(result_alloca, method, key, transformed);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(map_type, result_alloca, "mapval.result");
    }

    /// Helper: Emit hash value for a key.
    fn emitHashValue(self: *Emitter, key: llvm.ValueRef, key_type: types.Type) EmitError!llvm.ValueRef {
        const i32_type = llvm.Types.int32(self.ctx);

        // For primitives, use a simple hash function
        switch (key_type) {
            .primitive => |p| {
                switch (p) {
                    .i32_ => {
                        // Hash i32: multiply by a prime and XOR
                        const hash_prime: i32 = @bitCast(@as(u32, 0x9e3779b9));
                        const prime = llvm.Const.int32(self.ctx, hash_prime);
                        const hash = llvm.c.LLVMBuildMul(self.builder.ref, key, prime, "hash_mul");
                        return llvm.c.LLVMBuildXor(self.builder.ref, hash, llvm.c.LLVMBuildLShr(self.builder.ref, hash, llvm.Const.int32(self.ctx, 16), "hash_shift"), "hash");
                    },
                    .i64_, .u64_, .isize_, .usize_ => {
                        // Hash i64: fold to i32
                        const hi = llvm.c.LLVMBuildLShr(self.builder.ref, key, llvm.Const.int64(self.ctx, 32), "hi");
                        const hi_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, hi, i32_type, "hi_i32");
                        const lo_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, key, i32_type, "lo_i32");
                        const xor = llvm.c.LLVMBuildXor(self.builder.ref, hi_i32, lo_i32, "xor");
                        const hash_prime: i32 = @bitCast(@as(u32, 0x9e3779b9));
                        const prime = llvm.Const.int32(self.ctx, hash_prime);
                        return llvm.c.LLVMBuildMul(self.builder.ref, xor, prime, "hash");
                    },
                    .i8_, .u8_, .i16_, .u16_ => {
                        // Extend to i32 and hash
                        const ext = llvm.c.LLVMBuildSExt(self.builder.ref, key, i32_type, "ext");
                        const hash_prime: i32 = @bitCast(@as(u32, 0x9e3779b9));
                        const prime = llvm.Const.int32(self.ctx, hash_prime);
                        return llvm.c.LLVMBuildMul(self.builder.ref, ext, prime, "hash");
                    },
                    .bool_ => {
                        const ext = llvm.c.LLVMBuildZExt(self.builder.ref, key, i32_type, "bool_ext");
                        return ext;
                    },
                    .string_ => {
                        // For string pointers, call djb2 hash function
                        return try self.emitStringHash(key);
                    },
                    else => {
                        // Default: return 0
                        return llvm.Const.int32(self.ctx, 0);
                    },
                }
            },
            else => {
                // For other types, return 0 (not ideal but works for testing)
                return llvm.Const.int32(self.ctx, 0);
            },
        }
    }

    /// Helper: Emit string hash using djb2 algorithm.
    fn emitStringHash(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Simple djb2 hash inline
        const hash_alloca = self.builder.buildAlloca(i32_type, "hash");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 5381), hash_alloca);

        const ptr_alloca = self.builder.buildAlloca(ptr_type, "str_ptr");
        _ = self.builder.buildStore(str_ptr, ptr_alloca);

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "hash.loop");
        const body_block = llvm.c.LLVMAppendBasicBlock(current_fn, "hash.body");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "hash.done");

        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        // Loop
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const cur_ptr = self.builder.buildLoad(ptr_type, ptr_alloca, "cur_ptr");
        const c = self.builder.buildLoad(i8_type, cur_ptr, "c");
        const is_zero = self.builder.buildICmp(llvm.c.LLVMIntEQ, c, llvm.Const.int8(self.ctx, 0), "is_zero");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_zero, done_block, body_block);

        // Body: hash = hash * 33 + c
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, body_block);
        const hash_val = self.builder.buildLoad(i32_type, hash_alloca, "hash_val");
        const hash_mul = llvm.c.LLVMBuildMul(self.builder.ref, hash_val, llvm.Const.int32(self.ctx, 33), "hash_mul");
        const c_ext = llvm.c.LLVMBuildZExt(self.builder.ref, c, i32_type, "c_ext");
        const new_hash = llvm.c.LLVMBuildAdd(self.builder.ref, hash_mul, c_ext, "new_hash");
        _ = self.builder.buildStore(new_hash, hash_alloca);

        // Advance pointer
        var indices = [_]llvm.ValueRef{llvm.Const.int32(self.ctx, 1)};
        const next_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, cur_ptr, &indices, 1, "next_ptr");
        _ = self.builder.buildStore(next_ptr, ptr_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        // Done
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(i32_type, hash_alloca, "str_hash");
    }

    /// Helper: Emit equality comparison for two values of the same type.
    fn emitEqComparison(self: *Emitter, a: llvm.ValueRef, b: llvm.ValueRef, ty: types.Type) EmitError!llvm.ValueRef {
        switch (ty) {
            .primitive => |p| {
                switch (p) {
                    .i8_, .u8_, .i16_, .u16_, .i32_, .u32_, .i64_, .u64_, .isize_, .usize_, .i128_, .u128_, .bool_, .char_ => {
                        return self.builder.buildICmp(llvm.c.LLVMIntEQ, a, b, "eq");
                    },
                    .f32_, .f64_ => {
                        return self.builder.buildFCmp(llvm.c.LLVMRealOEQ, a, b, "eq");
                    },
                    .string_ => {
                        // String comparison: call strcmp
                        const strcmp_fn = self.getOrDeclareStrcmp();
                        var args = [_]llvm.ValueRef{ a, b };
                        const result = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strcmp_fn), strcmp_fn, &args, "strcmp_result");
                        return self.builder.buildICmp(llvm.c.LLVMIntEQ, result, llvm.Const.int32(self.ctx, 0), "eq");
                    },
                }
            },
            else => {
                // Default: pointer equality
                return self.builder.buildICmp(llvm.c.LLVMIntEQ, a, b, "eq");
            },
        }
    }

    // ========================================================================
    // Set Methods
    // ========================================================================
    // Set layout: { entries: *Entry, len: i32, capacity: i32, tombstone_count: i32 }
    // Entry layout: { state: i8, cached_hash: i32, element: T }
    // State: 0=EMPTY, 1=OCCUPIED, 2=TOMBSTONE

    /// Get the Set struct type: { ptr, i32, i32, i32 }
    fn getSetStructType(self: *Emitter) llvm.TypeRef {
        const i32_type = llvm.Types.int32(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);
        var fields = [_]llvm.TypeRef{ ptr_type, i32_type, i32_type, i32_type };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get the Set entry struct type for given element type.
    /// Entry layout: { state: i8, cached_hash: i32, element: T }
    fn getSetEntryType(self: *Emitter, element_type: llvm.TypeRef) llvm.TypeRef {
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var fields = [_]llvm.TypeRef{ i8_type, i32_type, element_type };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Emit Set.new[T]() - creates an empty set.
    /// Returns a Set struct with { null, 0, 0, 0 }.
    fn emitSetNew(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        _ = method; // Type args already validated by checker

        const set_type = self.getSetStructType();

        // Create an empty set struct { null, 0, 0, 0 }
        const null_ptr = llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        const zero_i32 = llvm.Const.int32(self.ctx, 0);

        var values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        return llvm.c.LLVMConstNamedStruct(set_type, &values, 4);
    }

    /// Emit Set.with_capacity[T](n) - creates a set with pre-allocated capacity.
    fn emitSetWithCapacity(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        // Get element type from type_args
        const type_args = method.type_args orelse return EmitError.InvalidAST;
        if (type_args.len != 1) return EmitError.InvalidAST;

        // Resolve element type using type checker
        var element_type_klar: types.Type = undefined;
        if (self.type_checker) |tc| {
            const tc_mut = @constCast(tc);
            element_type_klar = tc_mut.resolveTypeExpr(type_args[0]) catch return EmitError.InvalidAST;
        } else {
            return EmitError.InvalidAST;
        }

        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);
        const entry_size = self.getLLVMTypeSize(entry_type);

        // Emit the capacity argument
        if (method.args.len != 1) return EmitError.InvalidAST;
        const capacity = try self.emitExpr(method.args[0]);

        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const set_type = self.getSetStructType();

        // Convert capacity to i32 if needed
        const cap_type = llvm.typeOf(capacity);
        const cap_i32 = if (cap_type == i64_type)
            llvm.c.LLVMBuildTrunc(self.builder.ref, capacity, i32_type, "cap_i32")
        else
            capacity;

        // Calculate allocation size: capacity * entry_size
        const cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, cap_i32, i64_type, "cap_i64");
        const entry_size_val = llvm.Const.int64(self.ctx, @intCast(entry_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, cap_i64, entry_size_val, "alloc_size");

        // Call malloc(size)
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const entries_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "set.entries");

        // Zero-initialize the entries (all states = EMPTY = 0)
        const memset_fn = self.getOrDeclareMemset();
        var memset_args = [_]llvm.ValueRef{ entries_ptr, llvm.Const.int32(self.ctx, 0), alloc_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memset_fn), memset_fn, &memset_args, "");

        // Build the set struct
        const set_alloca = self.builder.buildAlloca(set_type, "set");
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_alloca, 0, "set.entries_ptr");
        _ = self.builder.buildStore(entries_ptr, entries_field);
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_alloca, 1, "set.len_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_field);
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_alloca, 2, "set.cap_ptr");
        _ = self.builder.buildStore(cap_i32, cap_field);
        const tomb_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_alloca, 3, "set.tomb_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), tomb_field);

        return self.builder.buildLoad(set_type, set_alloca, "set.result");
    }

    /// Emit set.len() - returns length as i32.
    fn emitSetLen(self: *Emitter, set_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const set_type = self.getSetStructType();
        const i32_type = llvm.Types.int32(self.ctx);

        // GEP to the len field (index 1)
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 1, "set.len_ptr");
        return self.builder.buildLoad(i32_type, len_ptr, "set.len");
    }

    /// Emit set.is_empty() - returns true if len == 0.
    fn emitSetIsEmpty(self: *Emitter, set_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const len = try self.emitSetLen(set_ptr);
        return self.builder.buildICmp(llvm.c.LLVMIntEQ, len, llvm.Const.int32(self.ctx, 0), "set.is_empty");
    }

    /// Emit set.capacity() - returns capacity as i32.
    fn emitSetCapacity(self: *Emitter, set_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const set_type = self.getSetStructType();
        const i32_type = llvm.Types.int32(self.ctx);

        // GEP to the capacity field (index 2)
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "set.cap_ptr");
        return self.builder.buildLoad(i32_type, cap_ptr, "set.capacity");
    }

    /// Emit set.insert(element) - inserts an element, returns true if newly inserted.
    fn emitSetInsert(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, element: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Get element type from stored info or type checker
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;

        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        const set_type = self.getSetStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load current capacity and length
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "set.cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "set.capacity");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 1, "set.len_ptr");
        const len = self.builder.buildLoad(i32_type, len_ptr, "set.len");
        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 3, "set.tomb_ptr");
        const tombstones = self.builder.buildLoad(i32_type, tomb_ptr, "set.tombstones");
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "set.entries_ptr_field");
        const entries_ptr = self.builder.buildLoad(ptr_type, entries_ptr_field, "set.entries");

        // Compute hash of element
        const hash = try self.emitHashValue(element, element_type_klar);

        // Setup basic blocks for resize check, probe loop, and done
        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const check_resize_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.check_resize");
        const do_resize_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.do_resize");
        const probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.probe");
        const found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.found");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.insert");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.done");

        // Result alloca for return value
        const result_alloca = self.builder.buildAlloca(i1_type, "set.result");
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i1_type, 0, 0), result_alloca);

        _ = llvm.c.LLVMBuildBr(self.builder.ref, check_resize_block);

        // Check if we need to resize (load factor > 75%)
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_resize_block);
        // Check if capacity is 0 (need initial allocation)
        const need_init = self.builder.buildICmp(llvm.c.LLVMIntEQ, capacity, llvm.Const.int32(self.ctx, 0), "need_init");
        // occupied = len + tombstones
        const occupied = llvm.c.LLVMBuildAdd(self.builder.ref, len, tombstones, "occupied");
        // threshold = capacity * 3 / 4 (75% load factor)
        const cap_3 = llvm.c.LLVMBuildMul(self.builder.ref, capacity, llvm.Const.int32(self.ctx, 3), "cap_3");
        const threshold = llvm.c.LLVMBuildSDiv(self.builder.ref, cap_3, llvm.Const.int32(self.ctx, 4), "threshold");
        const need_grow = self.builder.buildICmp(llvm.c.LLVMIntSGE, occupied, threshold, "need_grow");
        const need_resize = llvm.c.LLVMBuildOr(self.builder.ref, need_init, need_grow, "need_resize");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, need_resize, do_resize_block, probe_block);

        // Do resize: double capacity (or init to 8)
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, do_resize_block);
        const new_cap = llvm.c.LLVMBuildSelect(self.builder.ref, need_init, llvm.Const.int32(self.ctx, 8), llvm.c.LLVMBuildMul(self.builder.ref, capacity, llvm.Const.int32(self.ctx, 2), "cap_2"), "new_cap");
        // Allocate new entries
        const entry_size = self.getLLVMTypeSize(entry_type);
        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "new_cap_i64");
        const entry_size_val = llvm.Const.int64(self.ctx, @intCast(entry_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, new_cap_i64, entry_size_val, "alloc_size");
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const new_entries = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "new_entries");
        // Zero-initialize the new entries
        const memset_fn = self.getOrDeclareMemset();
        var memset_args = [_]llvm.ValueRef{ new_entries, llvm.Const.int32(self.ctx, 0), alloc_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memset_fn), memset_fn, &memset_args, "");

        // Rehash existing entries into new array
        // For simplicity, we'll use a loop to copy non-empty, non-tombstone entries
        const rehash_start_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.rehash_start");
        const rehash_loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.rehash_loop");
        const rehash_check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.rehash_check");
        const rehash_copy_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.rehash_copy");
        const rehash_next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.rehash_next");
        const rehash_done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "set.rehash_done");

        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_start_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_start_block);
        const old_cap_phi = capacity;
        const old_entries_phi = entries_ptr;
        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, old_cap_phi, "cond");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, cond, rehash_check_block, rehash_done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const old_entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, old_entries_phi, &indices, 1, "old_entry");
        const old_state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, old_entry_ptr, 0, "old_state_ptr");
        const old_state = self.builder.buildLoad(i8_type, old_state_ptr, "old_state");
        const is_occupied = self.builder.buildICmp(llvm.c.LLVMIntEQ, old_state, llvm.c.LLVMConstInt(i8_type, 1, 0), "is_occupied");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occupied, rehash_copy_block, rehash_next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_copy_block);
        // Load element and hash from old entry
        const old_hash_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, old_entry_ptr, 1, "old_hash_ptr");
        const old_hash = self.builder.buildLoad(i32_type, old_hash_ptr, "old_hash");
        const old_elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, old_entry_ptr, 2, "old_elem_ptr");
        const old_elem = self.builder.buildLoad(element_llvm_type, old_elem_ptr, "old_elem");

        // Find position in new array using linear probing
        // new_idx = hash & (new_cap - 1)
        const new_cap_minus_1 = llvm.c.LLVMBuildSub(self.builder.ref, new_cap, llvm.Const.int32(self.ctx, 1), "new_cap_m1");
        const new_start_idx = llvm.c.LLVMBuildAnd(self.builder.ref, old_hash, new_cap_minus_1, "new_start_idx");

        // Simple linear probe to find empty slot (new array has no collisions initially since it's larger)
        const probe_idx_alloca = self.builder.buildAlloca(i32_type, "probe_idx");
        _ = self.builder.buildStore(new_start_idx, probe_idx_alloca);
        const find_slot_block = llvm.c.LLVMAppendBasicBlock(current_fn, "find_slot");
        const slot_found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "slot_found");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, find_slot_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, find_slot_block);
        const probe_idx = self.builder.buildLoad(i32_type, probe_idx_alloca, "probe_idx");
        const probe_idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, probe_idx, i64_type, "probe_idx_i64");
        var new_indices = [_]llvm.ValueRef{probe_idx_i64};
        const new_entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, new_entries, &new_indices, 1, "new_entry");
        const new_state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, new_entry_ptr, 0, "new_state_ptr");
        const new_state = self.builder.buildLoad(i8_type, new_state_ptr, "new_state");
        const slot_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, new_state, llvm.c.LLVMConstInt(i8_type, 0, 0), "slot_empty");
        const probe_next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "probe_next");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, slot_empty, slot_found_block, probe_next_block);

        // Increment probe index and continue searching
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_next_block);
        const next_probe = llvm.c.LLVMBuildAdd(self.builder.ref, probe_idx, llvm.Const.int32(self.ctx, 1), "next_probe");
        const wrapped_probe = llvm.c.LLVMBuildAnd(self.builder.ref, next_probe, new_cap_minus_1, "wrapped_probe");
        _ = self.builder.buildStore(wrapped_probe, probe_idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, find_slot_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, slot_found_block);
        // Store element in new slot
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i8_type, 1, 0), new_state_ptr);
        const new_hash_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, new_entry_ptr, 1, "new_hash_ptr");
        _ = self.builder.buildStore(old_hash, new_hash_ptr);
        const new_elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, new_entry_ptr, 2, "new_elem_ptr");
        _ = self.builder.buildStore(old_elem, new_elem_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, rehash_loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, rehash_done_block);
        // Free old entries if not null
        const old_is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, old_entries_phi, llvm.c.LLVMConstNull(ptr_type), "old_is_null");
        const free_old_block = llvm.c.LLVMAppendBasicBlock(current_fn, "free_old");
        const after_free_block = llvm.c.LLVMAppendBasicBlock(current_fn, "after_free");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, old_is_null, after_free_block, free_old_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, free_old_block);
        const free_fn = self.getOrDeclareFree();
        var free_args = [_]llvm.ValueRef{old_entries_phi};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(free_fn), free_fn, &free_args, "");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, after_free_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, after_free_block);
        // Update set struct with new entries and capacity
        _ = self.builder.buildStore(new_entries, entries_ptr_field);
        _ = self.builder.buildStore(new_cap, cap_ptr);
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), tomb_ptr); // Reset tombstones after rehash
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_block);

        // Probe loop for insertion
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_block);
        // Reload entries and capacity (may have changed after resize)
        const entries_after = self.builder.buildLoad(ptr_type, entries_ptr_field, "entries_after");
        const cap_after = self.builder.buildLoad(i32_type, cap_ptr, "cap_after");
        const cap_mask = llvm.c.LLVMBuildSub(self.builder.ref, cap_after, llvm.Const.int32(self.ctx, 1), "cap_mask");
        const start_slot = llvm.c.LLVMBuildAnd(self.builder.ref, hash, cap_mask, "start_slot");

        // Probe loop variables
        const probe_slot_alloca = self.builder.buildAlloca(i32_type, "probe_slot");
        _ = self.builder.buildStore(start_slot, probe_slot_alloca);
        const first_tombstone_alloca = self.builder.buildAlloca(i32_type, "first_tombstone");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, -1), first_tombstone_alloca); // -1 means no tombstone found

        const probe_loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "probe_loop");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_loop_block);
        const cur_slot = self.builder.buildLoad(i32_type, probe_slot_alloca, "cur_slot");
        const cur_slot_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, cur_slot, i64_type, "cur_slot_i64");
        var cur_indices = [_]llvm.ValueRef{cur_slot_i64};
        const cur_entry = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_after, &cur_indices, 1, "cur_entry");
        const cur_state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, cur_entry, 0, "cur_state_ptr");
        const cur_state = self.builder.buildLoad(i8_type, cur_state_ptr, "cur_state");

        // Check if empty slot - insert here
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, cur_state, llvm.c.LLVMConstInt(i8_type, 0, 0), "is_empty");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty, insert_block, found_block);

        // Found block - check if occupied and element matches
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, found_block);
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, cur_state, llvm.c.LLVMConstInt(i8_type, 1, 0), "is_occ");

        const check_match_block = llvm.c.LLVMAppendBasicBlock(current_fn, "check_match");
        const is_tombstone_block = llvm.c.LLVMAppendBasicBlock(current_fn, "is_tombstone");
        const next_probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "next_probe");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, check_match_block, is_tombstone_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_match_block);
        const cur_elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, cur_entry, 2, "cur_elem_ptr");
        const cur_elem = self.builder.buildLoad(element_llvm_type, cur_elem_ptr, "cur_elem");
        const elems_equal = try self.emitEqComparison(element, cur_elem, element_type_klar);
        // If equal, element already exists - return false
        const already_exists_block = llvm.c.LLVMAppendBasicBlock(current_fn, "already_exists");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, elems_equal, already_exists_block, next_probe_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, already_exists_block);
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i1_type, 0, 0), result_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, is_tombstone_block);
        // Record first tombstone position for potential reuse
        const first_tomb = self.builder.buildLoad(i32_type, first_tombstone_alloca, "first_tomb");
        const no_tomb_yet = self.builder.buildICmp(llvm.c.LLVMIntEQ, first_tomb, llvm.Const.int32(self.ctx, -1), "no_tomb_yet");
        const new_first_tomb = llvm.c.LLVMBuildSelect(self.builder.ref, no_tomb_yet, cur_slot, first_tomb, "new_first_tomb");
        _ = self.builder.buildStore(new_first_tomb, first_tombstone_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_probe_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_probe_block);
        // Linear probe: next_slot = (cur_slot + 1) & cap_mask
        const next_slot = llvm.c.LLVMBuildAnd(self.builder.ref, llvm.c.LLVMBuildAdd(self.builder.ref, cur_slot, llvm.Const.int32(self.ctx, 1), "next"), cap_mask, "next_slot");
        _ = self.builder.buildStore(next_slot, probe_slot_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_loop_block);

        // Insert block - insert at first tombstone or current empty slot
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        const first_tomb_final = self.builder.buildLoad(i32_type, first_tombstone_alloca, "first_tomb_final");
        const use_tombstone = self.builder.buildICmp(llvm.c.LLVMIntNE, first_tomb_final, llvm.Const.int32(self.ctx, -1), "use_tombstone");
        const insert_slot = llvm.c.LLVMBuildSelect(self.builder.ref, use_tombstone, first_tomb_final, cur_slot, "insert_slot");
        const insert_slot_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, insert_slot, i64_type, "insert_slot_i64");
        var insert_indices = [_]llvm.ValueRef{insert_slot_i64};
        const insert_entry = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_after, &insert_indices, 1, "insert_entry");

        // Store element
        const ins_state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, insert_entry, 0, "ins_state_ptr");
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i8_type, 1, 0), ins_state_ptr); // OCCUPIED
        const ins_hash_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, insert_entry, 1, "ins_hash_ptr");
        _ = self.builder.buildStore(hash, ins_hash_ptr);
        const ins_elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, insert_entry, 2, "ins_elem_ptr");
        _ = self.builder.buildStore(element, ins_elem_ptr);

        // Increment len
        const new_len = llvm.c.LLVMBuildAdd(self.builder.ref, len, llvm.Const.int32(self.ctx, 1), "new_len");
        _ = self.builder.buildStore(new_len, len_ptr);

        // If we used a tombstone slot, decrement tombstone count
        const dec_tomb_block = llvm.c.LLVMAppendBasicBlock(current_fn, "dec_tomb");
        const after_tomb_block = llvm.c.LLVMAppendBasicBlock(current_fn, "after_tomb");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, use_tombstone, dec_tomb_block, after_tomb_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, dec_tomb_block);
        const cur_tombs = self.builder.buildLoad(i32_type, tomb_ptr, "cur_tombs");
        const new_tombs = llvm.c.LLVMBuildSub(self.builder.ref, cur_tombs, llvm.Const.int32(self.ctx, 1), "new_tombs");
        _ = self.builder.buildStore(new_tombs, tomb_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, after_tomb_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, after_tomb_block);
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i1_type, 1, 0), result_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(i1_type, result_alloca, "set.insert.result");
    }

    /// Emit set.contains(element) - returns true if element exists.
    fn emitSetContains(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, element: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;

        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        const set_type = self.getSetStructType();
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load capacity and entries
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "capacity");
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "entries_ptr_field");
        const entries_ptr = self.builder.buildLoad(ptr_type, entries_ptr_field, "entries");

        // Hash the element
        const hash = try self.emitHashValue(element, element_type_klar);

        // Result alloca
        const result_alloca = self.builder.buildAlloca(i1_type, "result");
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i1_type, 0, 0), result_alloca);

        // Check if capacity is 0 (empty set)
        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "probe");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "done");
        const empty_check = self.builder.buildICmp(llvm.c.LLVMIntEQ, capacity, llvm.Const.int32(self.ctx, 0), "empty_check");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, empty_check, done_block, probe_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_block);
        const cap_mask = llvm.c.LLVMBuildSub(self.builder.ref, capacity, llvm.Const.int32(self.ctx, 1), "cap_mask");
        const start_slot = llvm.c.LLVMBuildAnd(self.builder.ref, hash, cap_mask, "start_slot");

        const probe_slot_alloca = self.builder.buildAlloca(i32_type, "probe_slot");
        _ = self.builder.buildStore(start_slot, probe_slot_alloca);

        const probe_loop = llvm.c.LLVMAppendBasicBlock(current_fn, "probe_loop");
        const found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "found");
        const not_found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "not_found");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_loop);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_loop);
        const cur_slot = self.builder.buildLoad(i32_type, probe_slot_alloca, "cur_slot");
        const cur_slot_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, cur_slot, i64_type, "cur_slot_i64");
        var indices = [_]llvm.ValueRef{cur_slot_i64};
        const cur_entry = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr, &indices, 1, "cur_entry");
        const cur_state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, cur_entry, 0, "cur_state_ptr");
        const cur_state = self.builder.buildLoad(i8_type, cur_state_ptr, "cur_state");

        // If empty, element not found
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, cur_state, llvm.c.LLVMConstInt(i8_type, 0, 0), "is_empty");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty, not_found_block, found_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, found_block);
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, cur_state, llvm.c.LLVMConstInt(i8_type, 1, 0), "is_occ");
        const check_elem_block = llvm.c.LLVMAppendBasicBlock(current_fn, "check_elem");
        const next_probe = llvm.c.LLVMAppendBasicBlock(current_fn, "next_probe");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, check_elem_block, next_probe);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_elem_block);
        const cur_elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, cur_entry, 2, "cur_elem_ptr");
        const cur_elem = self.builder.buildLoad(element_llvm_type, cur_elem_ptr, "cur_elem");
        const elems_equal = try self.emitEqComparison(element, cur_elem, element_type_klar);
        const elem_found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "elem_found");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, elems_equal, elem_found_block, next_probe);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, elem_found_block);
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i1_type, 1, 0), result_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_probe);
        const next_slot = llvm.c.LLVMBuildAnd(self.builder.ref, llvm.c.LLVMBuildAdd(self.builder.ref, cur_slot, llvm.Const.int32(self.ctx, 1), "next"), cap_mask, "next_slot");
        _ = self.builder.buildStore(next_slot, probe_slot_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_loop);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, not_found_block);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(i1_type, result_alloca, "contains.result");
    }

    /// Emit set.remove(element) - removes an element, returns true if removed.
    fn emitSetRemove(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, element: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;

        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        const set_type = self.getSetStructType();
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load fields
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "capacity");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 1, "len_ptr");
        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 3, "tomb_ptr");
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "entries_ptr_field");
        const entries_ptr = self.builder.buildLoad(ptr_type, entries_ptr_field, "entries");

        const hash = try self.emitHashValue(element, element_type_klar);

        const result_alloca = self.builder.buildAlloca(i1_type, "result");
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i1_type, 0, 0), result_alloca);

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const probe_block = llvm.c.LLVMAppendBasicBlock(current_fn, "probe");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "done");
        const empty_check = self.builder.buildICmp(llvm.c.LLVMIntEQ, capacity, llvm.Const.int32(self.ctx, 0), "empty_check");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, empty_check, done_block, probe_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_block);
        const cap_mask = llvm.c.LLVMBuildSub(self.builder.ref, capacity, llvm.Const.int32(self.ctx, 1), "cap_mask");
        const start_slot = llvm.c.LLVMBuildAnd(self.builder.ref, hash, cap_mask, "start_slot");

        const probe_slot_alloca = self.builder.buildAlloca(i32_type, "probe_slot");
        _ = self.builder.buildStore(start_slot, probe_slot_alloca);

        const probe_loop = llvm.c.LLVMAppendBasicBlock(current_fn, "probe_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "check");
        const not_found_block = llvm.c.LLVMAppendBasicBlock(current_fn, "not_found");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_loop);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, probe_loop);
        const cur_slot = self.builder.buildLoad(i32_type, probe_slot_alloca, "cur_slot");
        const cur_slot_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, cur_slot, i64_type, "cur_slot_i64");
        var indices = [_]llvm.ValueRef{cur_slot_i64};
        const cur_entry = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries_ptr, &indices, 1, "cur_entry");
        const cur_state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, cur_entry, 0, "cur_state_ptr");
        const cur_state = self.builder.buildLoad(i8_type, cur_state_ptr, "cur_state");

        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, cur_state, llvm.c.LLVMConstInt(i8_type, 0, 0), "is_empty");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_empty, not_found_block, check_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, cur_state, llvm.c.LLVMConstInt(i8_type, 1, 0), "is_occ");
        const check_elem_block = llvm.c.LLVMAppendBasicBlock(current_fn, "check_elem");
        const next_probe = llvm.c.LLVMAppendBasicBlock(current_fn, "next_probe");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, check_elem_block, next_probe);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_elem_block);
        const cur_elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, cur_entry, 2, "cur_elem_ptr");
        const cur_elem = self.builder.buildLoad(element_llvm_type, cur_elem_ptr, "cur_elem");
        const elems_equal = try self.emitEqComparison(element, cur_elem, element_type_klar);
        const remove_block = llvm.c.LLVMAppendBasicBlock(current_fn, "remove");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, elems_equal, remove_block, next_probe);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, remove_block);
        // Mark as tombstone
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i8_type, 2, 0), cur_state_ptr); // TOMBSTONE
        // Decrement len
        const len = self.builder.buildLoad(i32_type, len_ptr, "len");
        const new_len = llvm.c.LLVMBuildSub(self.builder.ref, len, llvm.Const.int32(self.ctx, 1), "new_len");
        _ = self.builder.buildStore(new_len, len_ptr);
        // Increment tombstones
        const tombs = self.builder.buildLoad(i32_type, tomb_ptr, "tombs");
        const new_tombs = llvm.c.LLVMBuildAdd(self.builder.ref, tombs, llvm.Const.int32(self.ctx, 1), "new_tombs");
        _ = self.builder.buildStore(new_tombs, tomb_ptr);
        _ = self.builder.buildStore(llvm.c.LLVMConstInt(i1_type, 1, 0), result_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_probe);
        const next_slot = llvm.c.LLVMBuildAnd(self.builder.ref, llvm.c.LLVMBuildAdd(self.builder.ref, cur_slot, llvm.Const.int32(self.ctx, 1), "next"), cap_mask, "next_slot");
        _ = self.builder.buildStore(next_slot, probe_slot_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, probe_loop);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, not_found_block);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(i1_type, result_alloca, "remove.result");
    }

    /// Emit set.clear() - resets to empty state.
    fn emitSetClear(self: *Emitter, set_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const set_type = self.getSetStructType();

        // Set len = 0
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 1, "set.len_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_ptr);

        // Set tombstones = 0
        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 3, "set.tomb_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), tomb_ptr);

        // Note: We don't free/clear entries here, just reset counters
        // A full clear would need to zero the entries array

        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit set.clone() - creates a deep copy of the set.
    fn emitSetClone(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;

        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);
        const entry_size = self.getLLVMTypeSize(entry_type);

        const set_type = self.getSetStructType();
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load original set fields
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "entries_ptr_field");
        const entries_ptr = self.builder.buildLoad(ptr_type, entries_ptr_field, "entries");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 1, "len_ptr");
        const len = self.builder.buildLoad(i32_type, len_ptr, "len");
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "cap_ptr");
        const capacity = self.builder.buildLoad(i32_type, cap_ptr, "capacity");
        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 3, "tomb_ptr");
        const tombstones = self.builder.buildLoad(i32_type, tomb_ptr, "tombstones");

        // Allocate new entries array
        const cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, capacity, i64_type, "cap_i64");
        const entry_size_val = llvm.Const.int64(self.ctx, @intCast(entry_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, cap_i64, entry_size_val, "alloc_size");

        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const new_entries = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "new_entries");

        // Copy entries using memcpy
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ new_entries, entries_ptr, alloc_size };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Build new set struct
        const clone_alloca = self.builder.buildAlloca(set_type, "clone");
        const clone_entries_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, clone_alloca, 0, "clone_entries_ptr");
        _ = self.builder.buildStore(new_entries, clone_entries_ptr);
        const clone_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, clone_alloca, 1, "clone_len_ptr");
        _ = self.builder.buildStore(len, clone_len_ptr);
        const clone_cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, clone_alloca, 2, "clone_cap_ptr");
        _ = self.builder.buildStore(capacity, clone_cap_ptr);
        const clone_tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, clone_alloca, 3, "clone_tomb_ptr");
        _ = self.builder.buildStore(tombstones, clone_tomb_ptr);

        return self.builder.buildLoad(set_type, clone_alloca, "set.clone.result");
    }

    /// Emit set.drop() - frees the set's memory.
    fn emitSetDrop(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        _ = method;

        const set_type = self.getSetStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load entries ptr
        const entries_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "set.entries_ptr_field");
        const entries_ptr_val = self.builder.buildLoad(ptr_type, entries_ptr_field, "set.entries");

        // Free entries
        const free_fn = self.getOrDeclareFree();
        var free_args = [_]llvm.ValueRef{entries_ptr_val};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(free_fn), free_fn, &free_args, "");

        // Set to null state
        _ = self.builder.buildStore(llvm.c.LLVMConstNull(ptr_type), entries_ptr_field);
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 1, "set.len_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_ptr);
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "set.cap_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), cap_ptr);
        const tomb_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 3, "set.tomb_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), tomb_ptr);

        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit set.union(other) - returns a new set with elements from both sets.
    fn emitSetUnion(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, other_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;

        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        const set_type = self.getSetStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Clone self first
        const result = try self.emitSetClone(set_ptr, method);

        // Store result in temp alloca to insert elements from other
        const result_alloca = self.builder.buildAlloca(set_type, "union_result");
        _ = self.builder.buildStore(result, result_alloca);

        // Load other set fields
        const other_entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, other_ptr, 0, "other_entries_field");
        const other_entries = self.builder.buildLoad(ptr_type, other_entries_field, "other_entries");
        const other_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, other_ptr, 2, "other_cap_field");
        const other_cap = self.builder.buildLoad(i32_type, other_cap_field, "other_cap");

        // Iterate through other's entries and insert each occupied element
        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "union_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "union_check");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "union_insert");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "union_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "union_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, other_cap, "cond");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, other_entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.c.LLVMConstInt(i8_type, 1, 0), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, insert_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        const elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "elem_ptr");
        const elem = self.builder.buildLoad(element_llvm_type, elem_ptr, "elem");
        // Insert into result set (we call emitSetInsert with the result_alloca)
        _ = try self.emitSetInsert(result_alloca, method, elem);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(set_type, result_alloca, "union.result");
    }

    /// Emit set.intersection(other) - returns a new set with elements in both sets.
    fn emitSetIntersection(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, other_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;

        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        const set_type = self.getSetStructType();
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty result set
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var result_values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        const empty_set = llvm.c.LLVMConstNamedStruct(set_type, &result_values, 4);
        const result_alloca = self.builder.buildAlloca(set_type, "intersect_result");
        _ = self.builder.buildStore(empty_set, result_alloca);

        // Load self set fields
        const self_entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "self_entries_field");
        const self_entries = self.builder.buildLoad(ptr_type, self_entries_field, "self_entries");
        const self_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "self_cap_field");
        const self_cap = self.builder.buildLoad(i32_type, self_cap_field, "self_cap");

        // Iterate through self's entries
        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "intersect_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "intersect_check");
        const test_block = llvm.c.LLVMAppendBasicBlock(current_fn, "intersect_test");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "intersect_insert");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "intersect_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "intersect_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, self_cap, "cond");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, self_entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.c.LLVMConstInt(i8_type, 1, 0), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, test_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, test_block);
        const elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "elem_ptr");
        const elem = self.builder.buildLoad(element_llvm_type, elem_ptr, "elem");
        // Check if element is in other set
        const in_other = try self.emitSetContains(other_ptr, method, elem);
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, in_other, insert_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        _ = try self.emitSetInsert(result_alloca, method, elem);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        _ = i1_type;
        return self.builder.buildLoad(set_type, result_alloca, "intersect.result");
    }

    /// Emit set.difference(other) - returns a new set with elements in self but not in other.
    fn emitSetDifference(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, other_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;

        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        const set_type = self.getSetStructType();
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty result set
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var result_values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        const empty_set = llvm.c.LLVMConstNamedStruct(set_type, &result_values, 4);
        const result_alloca = self.builder.buildAlloca(set_type, "diff_result");
        _ = self.builder.buildStore(empty_set, result_alloca);

        // Load self set fields
        const self_entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "self_entries_field");
        const self_entries = self.builder.buildLoad(ptr_type, self_entries_field, "self_entries");
        const self_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "self_cap_field");
        const self_cap = self.builder.buildLoad(i32_type, self_cap_field, "self_cap");

        // Iterate through self's entries
        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "diff_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "diff_check");
        const test_block = llvm.c.LLVMAppendBasicBlock(current_fn, "diff_test");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "diff_insert");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "diff_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "diff_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, self_cap, "cond");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, self_entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.c.LLVMConstInt(i8_type, 1, 0), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, test_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, test_block);
        const elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "elem_ptr");
        const elem = self.builder.buildLoad(element_llvm_type, elem_ptr, "elem");
        // Check if element is NOT in other set
        const in_other = try self.emitSetContains(other_ptr, method, elem);
        const not_in_other = llvm.c.LLVMBuildNot(self.builder.ref, in_other, "not_in_other");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, not_in_other, insert_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        _ = try self.emitSetInsert(result_alloca, method, elem);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        _ = i1_type;
        return self.builder.buildLoad(set_type, result_alloca, "diff.result");
    }

    // ========================================================================
    // Set Iterator Adapters
    // ========================================================================

    /// Emit set.take(n) - returns a new set with first n elements.
    fn emitSetTake(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, count: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        const set_type = self.getSetStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty result set
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var result_values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        const empty_set = llvm.c.LLVMConstNamedStruct(set_type, &result_values, 4);
        const result_alloca = self.builder.buildAlloca(set_type, "take_result");
        _ = self.builder.buildStore(empty_set, result_alloca);

        // Clamp count to >= 0
        const count_clamped = llvm.c.LLVMBuildSelect(
            self.builder.ref,
            self.builder.buildICmp(llvm.c.LLVMIntSLT, count, zero_i32, "take.count_neg"),
            zero_i32,
            count,
            "take.count_clamped",
        );

        // Load set fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        // Iterate through entries, insert first n occupied elements
        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_check");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_insert");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "take_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        const taken_alloca = self.builder.buildAlloca(i32_type, "taken");
        _ = self.builder.buildStore(zero_i32, idx_alloca);
        _ = self.builder.buildStore(zero_i32, taken_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const taken = self.builder.buildLoad(i32_type, taken_alloca, "taken");
        // Continue if idx < capacity AND taken < count
        const idx_ok = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "idx_ok");
        const taken_ok = self.builder.buildICmp(llvm.c.LLVMIntSLT, taken, count_clamped, "taken_ok");
        const continue_cond = llvm.c.LLVMBuildAnd(self.builder.ref, idx_ok, taken_ok, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, insert_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        const elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "elem_ptr");
        const elem = self.builder.buildLoad(element_llvm_type, elem_ptr, "elem");
        _ = try self.emitSetInsert(result_alloca, method, elem);
        const new_taken = llvm.c.LLVMBuildAdd(self.builder.ref, taken, llvm.Const.int32(self.ctx, 1), "new_taken");
        _ = self.builder.buildStore(new_taken, taken_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(set_type, result_alloca, "take.result");
    }

    /// Emit set.skip(n) - returns a new set skipping first n elements.
    fn emitSetSkip(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, count: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        const set_type = self.getSetStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty result set
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var result_values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        const empty_set = llvm.c.LLVMConstNamedStruct(set_type, &result_values, 4);
        const result_alloca = self.builder.buildAlloca(set_type, "skip_result");
        _ = self.builder.buildStore(empty_set, result_alloca);

        // Clamp count to >= 0
        const count_clamped = llvm.c.LLVMBuildSelect(
            self.builder.ref,
            self.builder.buildICmp(llvm.c.LLVMIntSLT, count, zero_i32, "skip.count_neg"),
            zero_i32,
            count,
            "skip.count_clamped",
        );

        // Load set fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        // Iterate through entries, skip first n occupied, insert the rest
        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_check");
        const process_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_process");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_insert");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "skip_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        const skipped_alloca = self.builder.buildAlloca(i32_type, "skipped");
        _ = self.builder.buildStore(zero_i32, idx_alloca);
        _ = self.builder.buildStore(zero_i32, skipped_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const continue_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, process_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, process_block);
        const skipped = self.builder.buildLoad(i32_type, skipped_alloca, "skipped");
        const should_insert = self.builder.buildICmp(llvm.c.LLVMIntSGE, skipped, count_clamped, "should_insert");
        // Always increment skipped count
        const new_skipped = llvm.c.LLVMBuildAdd(self.builder.ref, skipped, llvm.Const.int32(self.ctx, 1), "new_skipped");
        _ = self.builder.buildStore(new_skipped, skipped_alloca);
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, should_insert, insert_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        const elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "elem_ptr");
        const elem = self.builder.buildLoad(element_llvm_type, elem_ptr, "elem");
        _ = try self.emitSetInsert(result_alloca, method, elem);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(set_type, result_alloca, "skip.result");
    }

    /// Emit set.filter(predicate) - returns a new set with elements matching predicate.
    fn emitSetFilter(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, closure_value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        const set_type = self.getSetStructType();
        const i1_type = llvm.Types.int1(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Create empty result set
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var result_values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32, zero_i32 };
        const empty_set = llvm.c.LLVMConstNamedStruct(set_type, &result_values, 4);
        const result_alloca = self.builder.buildAlloca(set_type, "filter_result");
        _ = self.builder.buildStore(empty_set, result_alloca);

        // Extract closure function pointer and environment pointer
        const closure_struct_type = self.getClosureStructType();
        const closure_alloca = self.builder.buildAlloca(closure_struct_type, "filter.closure_tmp");
        _ = self.builder.buildStore(closure_value, closure_alloca);

        var fn_ptr_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 0) };
        const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "filter.fn_ptr_ptr");
        const fn_ptr = self.builder.buildLoad(ptr_type, fn_ptr_gep, "filter.fn_ptr");

        var env_ptr_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 1) };
        const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "filter.env_ptr_ptr");
        const env_ptr = self.builder.buildLoad(ptr_type, env_ptr_gep, "filter.env_ptr");

        // Build function type for closure: fn(env_ptr, element) -> bool
        var param_types = [_]llvm.TypeRef{ ptr_type, element_llvm_type };
        const closure_fn_type = llvm.Types.function(i1_type, &param_types, false);

        // Load set fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        // Iterate through entries, apply predicate, insert matching elements
        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_check");
        const test_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_test");
        const insert_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_insert");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "filter_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        _ = self.builder.buildStore(zero_i32, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const continue_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, test_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, test_block);
        const elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "elem_ptr");
        const elem = self.builder.buildLoad(element_llvm_type, elem_ptr, "elem");
        // Call predicate closure
        var call_args = [_]llvm.ValueRef{ env_ptr, elem };
        const pred_result = self.builder.buildCall(closure_fn_type, fn_ptr, &call_args, "pred_result");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, pred_result, insert_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, insert_block);
        _ = try self.emitSetInsert(result_alloca, method, elem);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(set_type, result_alloca, "filter.result");
    }

    /// Emit set.map(transform) - returns a new list with transformed elements.
    /// Pre-allocates result list based on set's len field for efficiency.
    fn emitSetMap(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, closure_value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        const src_element_type = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;
        const src_element_llvm_type = self.typeToLLVM(src_element_type);
        const entry_type = self.getSetEntryType(src_element_llvm_type);

        // Get destination element type from closure's return type
        const dest_element_type = if (self.type_checker) |tc| blk: {
            const tc_mut = @constCast(tc);
            const closure_type = tc_mut.checkExpr(method.args[0]);
            if (closure_type == .function) {
                break :blk closure_type.function.return_type;
            }
            break :blk src_element_type;
        } else src_element_type;

        const dest_element_llvm_type = self.typeToLLVM(dest_element_type);
        const dest_element_size = self.getLLVMTypeSize(dest_element_llvm_type);

        const set_type = self.getSetStructType();
        const list_type = self.getListStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load set fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 1, "len_field");
        const set_len = self.builder.buildLoad(i32_type, len_field, "set_len");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        // Allocate result list on the stack
        const result_alloca = self.builder.buildAlloca(list_type, "map.result");
        const zero = llvm.Const.int32(self.ctx, 0);

        // Check if set is empty
        const is_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, set_len, zero, "map.is_empty");

        // Create basic blocks
        const empty_bb = llvm.appendBasicBlock(self.ctx, func, "map.empty");
        const alloc_bb = llvm.appendBasicBlock(self.ctx, func, "map.alloc");
        const loop_bb = llvm.appendBasicBlock(self.ctx, func, "map.loop");
        const check_bb = llvm.appendBasicBlock(self.ctx, func, "map.check");
        const transform_bb = llvm.appendBasicBlock(self.ctx, func, "map.transform");
        const next_bb = llvm.appendBasicBlock(self.ctx, func, "map.next");
        const done_bb = llvm.appendBasicBlock(self.ctx, func, "map.done");

        _ = self.builder.buildCondBr(is_empty, empty_bb, alloc_bb);

        // --- Empty block: return empty list ---
        self.builder.positionAtEnd(empty_bb);
        const empty_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "map.empty_ptr_field");
        _ = self.builder.buildStore(llvm.c.LLVMConstPointerNull(ptr_type), empty_ptr_field);
        const empty_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "map.empty_len_field");
        _ = self.builder.buildStore(zero, empty_len_field);
        const empty_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "map.empty_cap_field");
        _ = self.builder.buildStore(zero, empty_cap_field);
        _ = self.builder.buildBr(done_bb);

        // --- Allocate block: pre-allocate result array based on set len ---
        self.builder.positionAtEnd(alloc_bb);

        // Extract closure function pointer and environment pointer
        const closure_struct_type = self.getClosureStructType();
        const closure_alloca = self.builder.buildAlloca(closure_struct_type, "map.closure_tmp");
        _ = self.builder.buildStore(closure_value, closure_alloca);

        var fn_ptr_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 0) };
        const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "map.fn_ptr_ptr");
        const fn_ptr = self.builder.buildLoad(ptr_type, fn_ptr_gep, "map.fn_ptr");

        var env_ptr_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 1) };
        const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "map.env_ptr_ptr");
        const env_ptr = self.builder.buildLoad(ptr_type, env_ptr_gep, "map.env_ptr");

        // Build function type for closure: fn(env_ptr, src_element) -> dest_element
        var param_types = [_]llvm.TypeRef{ ptr_type, src_element_llvm_type };
        const closure_fn_type = llvm.Types.function(dest_element_llvm_type, &param_types, false);

        // Allocate memory for result: set_len * dest_element_size
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, set_len, i64_type, "map.len_i64");
        const dest_elem_size_val = llvm.Const.int64(self.ctx, @intCast(dest_element_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, len_i64, dest_elem_size_val, "map.alloc_size");

        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const dest_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "map.dest_ptr");

        // Store result list header (ptr, len=set_len, cap=set_len)
        const alloc_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "map.alloc_ptr_field");
        _ = self.builder.buildStore(dest_ptr, alloc_ptr_field);
        const alloc_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "map.alloc_len_field");
        _ = self.builder.buildStore(set_len, alloc_len_field);
        const alloc_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "map.alloc_cap_field");
        _ = self.builder.buildStore(set_len, alloc_cap_field);

        // Loop counters: source index (over capacity) and result index (over elements found)
        const src_idx_alloca = self.builder.buildAlloca(i32_type, "map.src_idx");
        const res_idx_alloca = self.builder.buildAlloca(i32_type, "map.res_idx");
        _ = self.builder.buildStore(zero, src_idx_alloca);
        _ = self.builder.buildStore(zero, res_idx_alloca);

        _ = self.builder.buildBr(loop_bb);

        // --- Loop: iterate over source set's capacity ---
        self.builder.positionAtEnd(loop_bb);
        const src_idx = self.builder.buildLoad(i32_type, src_idx_alloca, "map.src_idx_val");
        const res_idx = self.builder.buildLoad(i32_type, res_idx_alloca, "map.res_idx_val");
        // Continue while src_idx < capacity AND res_idx < set_len
        const src_ok = self.builder.buildICmp(llvm.c.LLVMIntSLT, src_idx, capacity, "map.src_ok");
        const res_ok = self.builder.buildICmp(llvm.c.LLVMIntSLT, res_idx, set_len, "map.res_ok");
        const loop_cond = llvm.c.LLVMBuildAnd(self.builder.ref, src_ok, res_ok, "map.loop_cond");
        _ = self.builder.buildCondBr(loop_cond, check_bb, done_bb);

        // --- Check: is this entry occupied? ---
        self.builder.positionAtEnd(check_bb);
        const src_idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, src_idx, i64_type, "map.src_idx_i64");
        var entry_indices = [_]llvm.ValueRef{src_idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &entry_indices, 1, "map.entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "map.state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "map.state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "map.is_occ");
        _ = self.builder.buildCondBr(is_occ, transform_bb, next_bb);

        // --- Transform: load element, call closure, store result ---
        self.builder.positionAtEnd(transform_bb);
        const elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "map.elem_ptr");
        const elem = self.builder.buildLoad(src_element_llvm_type, elem_ptr, "map.elem");

        // Call closure
        var call_args = [_]llvm.ValueRef{ env_ptr, elem };
        const transformed = self.builder.buildCall(closure_fn_type, fn_ptr, &call_args, "map.transformed");

        // Store to result at res_idx
        const res_idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, res_idx, i64_type, "map.res_idx_i64");
        var store_indices = [_]llvm.ValueRef{res_idx_i64};
        const store_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, dest_element_llvm_type, dest_ptr, &store_indices, 1, "map.store_ptr");
        _ = self.builder.buildStore(transformed, store_ptr);

        // Increment res_idx
        const new_res_idx = llvm.c.LLVMBuildAdd(self.builder.ref, res_idx, llvm.Const.int32(self.ctx, 1), "map.new_res_idx");
        _ = self.builder.buildStore(new_res_idx, res_idx_alloca);

        _ = self.builder.buildBr(next_bb);

        // --- Next: increment src_idx, loop ---
        self.builder.positionAtEnd(next_bb);
        const next_src_idx = llvm.c.LLVMBuildAdd(self.builder.ref, src_idx, llvm.Const.int32(self.ctx, 1), "map.next_src_idx");
        _ = self.builder.buildStore(next_src_idx, src_idx_alloca);
        _ = self.builder.buildBr(loop_bb);

        // --- Done: return result ---
        self.builder.positionAtEnd(done_bb);
        return self.builder.buildLoad(list_type, result_alloca, "map.result");
    }

    /// Emit set.enumerate() - returns List[(i32, T)] pairing each element with its index.
    fn emitSetEnumerate(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        // Build tuple type (i32, T)
        const set_type = self.getSetStructType();
        const list_type = self.getListStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        var tuple_fields = [_]llvm.TypeRef{ i32_type, element_llvm_type };
        const tuple_type = llvm.Types.struct_(self.ctx, &tuple_fields, false);
        const tuple_size = self.getLLVMTypeSize(tuple_type);

        // Create empty result list
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        const result_alloca = self.builder.buildAlloca(list_type, "enum_result");
        _ = self.builder.buildStore(null_ptr, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, ""));
        _ = self.builder.buildStore(zero_i32, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, ""));
        _ = self.builder.buildStore(zero_i32, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, ""));

        // Load set fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop_block = llvm.c.LLVMAppendBasicBlock(current_fn, "enum_loop");
        const check_block = llvm.c.LLVMAppendBasicBlock(current_fn, "enum_check");
        const process_block = llvm.c.LLVMAppendBasicBlock(current_fn, "enum_process");
        const next_block = llvm.c.LLVMAppendBasicBlock(current_fn, "enum_next");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "enum_done");

        const idx_alloca = self.builder.buildAlloca(i32_type, "idx");
        const enum_idx_alloca = self.builder.buildAlloca(i32_type, "enum_idx");
        _ = self.builder.buildStore(zero_i32, idx_alloca);
        _ = self.builder.buildStore(zero_i32, enum_idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "idx");
        const continue_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, capacity, "continue");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_cond, check_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check_block);
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "idx_i64");
        var indices = [_]llvm.ValueRef{idx_i64};
        const entry_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &indices, 1, "entry_ptr");
        const state_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 0, "state_ptr");
        const state = self.builder.buildLoad(i8_type, state_ptr, "state");
        const is_occ = self.builder.buildICmp(llvm.c.LLVMIntEQ, state, llvm.Const.int8(self.ctx, 1), "is_occ");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ, process_block, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, process_block);
        const elem_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry_ptr, 2, "elem_ptr");
        const elem = self.builder.buildLoad(element_llvm_type, elem_ptr, "elem");
        const enum_idx = self.builder.buildLoad(i32_type, enum_idx_alloca, "enum_idx");

        // Build tuple value
        var tuple_val = llvm.c.LLVMGetUndef(tuple_type);
        tuple_val = llvm.c.LLVMBuildInsertValue(self.builder.ref, tuple_val, enum_idx, 0, "tuple.0");
        tuple_val = llvm.c.LLVMBuildInsertValue(self.builder.ref, tuple_val, elem, 1, "tuple.1");

        // Push to result list (inline push logic)
        const res_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, "res_ptr_ptr");
        const res_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, "res_len_ptr");
        const res_cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, "res_cap_ptr");

        const res_ptr = self.builder.buildLoad(ptr_type, res_ptr_ptr, "res_ptr");
        const res_len = self.builder.buildLoad(i32_type, res_len_ptr, "res_len");
        const res_cap = self.builder.buildLoad(i32_type, res_cap_ptr, "res_cap");

        const need_grow = self.builder.buildICmp(llvm.c.LLVMIntSGE, res_len, res_cap, "need_grow");

        const grow_bb = llvm.c.LLVMAppendBasicBlock(current_fn, "enum.grow");
        const store_bb = llvm.c.LLVMAppendBasicBlock(current_fn, "enum.store");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, need_grow, grow_bb, store_bb);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, grow_bb);
        const doubled_cap = llvm.c.LLVMBuildMul(self.builder.ref, res_cap, llvm.Const.int32(self.ctx, 2), "doubled");
        const eight = llvm.Const.int32(self.ctx, 8);
        const cmp_eight = self.builder.buildICmp(llvm.c.LLVMIntSGT, doubled_cap, eight, "cmp_eight");
        const new_cap = llvm.c.LLVMBuildSelect(self.builder.ref, cmp_eight, doubled_cap, eight, "new_cap");

        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "new_cap_i64");
        const tuple_size_val = llvm.Const.int64(self.ctx, @intCast(tuple_size));
        const new_size = llvm.c.LLVMBuildMul(self.builder.ref, new_cap_i64, tuple_size_val, "new_size");

        const realloc_fn = self.getOrDeclareRealloc();
        var realloc_args = [_]llvm.ValueRef{ res_ptr, new_size };
        const grown_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(realloc_fn), realloc_fn, &realloc_args, "grown_ptr");

        _ = self.builder.buildStore(grown_ptr, res_ptr_ptr);
        _ = self.builder.buildStore(new_cap, res_cap_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, store_bb);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, store_bb);
        const phi = llvm.c.LLVMBuildPhi(self.builder.ref, ptr_type, "data_ptr");
        var incoming_values = [_]llvm.ValueRef{ res_ptr, grown_ptr };
        var incoming_blocks = [_]llvm.BasicBlockRef{ process_block, grow_bb };
        llvm.c.LLVMAddIncoming(phi, &incoming_values, &incoming_blocks, 2);

        const res_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, res_len, i64_type, "res_len_i64");
        var store_indices = [_]llvm.ValueRef{res_len_i64};
        const store_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, tuple_type, phi, &store_indices, 1, "store_ptr");
        _ = self.builder.buildStore(tuple_val, store_ptr);

        const new_res_len = llvm.c.LLVMBuildAdd(self.builder.ref, res_len, llvm.Const.int32(self.ctx, 1), "new_res_len");
        _ = self.builder.buildStore(new_res_len, res_len_ptr);

        // Increment enum index
        const new_enum_idx = llvm.c.LLVMBuildAdd(self.builder.ref, enum_idx, llvm.Const.int32(self.ctx, 1), "new_enum_idx");
        _ = self.builder.buildStore(new_enum_idx, enum_idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next_block);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        return self.builder.buildLoad(list_type, result_alloca, "enum.result");
    }

    /// Emit set.zip(other) - returns List[(T, U)] combining two sets element-wise.
    fn emitSetZip(self: *Emitter, set_ptr: llvm.ValueRef, method: *ast.MethodCall, other_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type_klar = self.getSetElementType(method.object) orelse return EmitError.InvalidAST;
        const element_llvm_type = self.typeToLLVM(element_type_klar);
        const entry_type = self.getSetEntryType(element_llvm_type);

        // Get other set's element type
        const other_element_type_klar = if (self.type_checker) |tc| blk: {
            const tc_mut = @constCast(tc);
            const arg_type = tc_mut.checkExpr(method.args[0]);
            if (arg_type == .set) {
                break :blk arg_type.set.element;
            }
            break :blk element_type_klar;
        } else element_type_klar;

        const other_element_llvm_type = self.typeToLLVM(other_element_type_klar);
        const other_entry_type = self.getSetEntryType(other_element_llvm_type);

        // Build tuple type (T, U)
        const set_type = self.getSetStructType();
        const list_type = self.getListStructType();
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        var tuple_fields = [_]llvm.TypeRef{ element_llvm_type, other_element_llvm_type };
        const tuple_type = llvm.Types.struct_(self.ctx, &tuple_fields, false);
        const tuple_size = self.getLLVMTypeSize(tuple_type);

        // Create empty result list
        const null_ptr = llvm.c.LLVMConstNull(ptr_type);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        const result_alloca = self.builder.buildAlloca(list_type, "zip_result");
        _ = self.builder.buildStore(null_ptr, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, ""));
        _ = self.builder.buildStore(zero_i32, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, ""));
        _ = self.builder.buildStore(zero_i32, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, ""));

        // Load set fields
        const entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 0, "entries_field");
        const entries = self.builder.buildLoad(ptr_type, entries_field, "entries");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, set_ptr, 2, "cap_field");
        const capacity = self.builder.buildLoad(i32_type, cap_field, "capacity");

        // Load other set fields
        const other_entries_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, other_ptr, 0, "other_entries_field");
        const other_entries = self.builder.buildLoad(ptr_type, other_entries_field, "other_entries");
        const other_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, set_type, other_ptr, 2, "other_cap_field");
        const other_capacity = self.builder.buildLoad(i32_type, other_cap_field, "other_capacity");

        const current_fn = llvm.c.LLVMGetBasicBlockParent(llvm.c.LLVMGetInsertBlock(self.builder.ref));
        const loop1_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_loop1");
        const check1_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_check1");
        const store1_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_store1");
        const next1_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_next1");
        const loop2_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_loop2");
        const check2_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_check2");
        const store2_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_store2");
        const next2_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_next2");
        const done_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_done");

        // Collect elements from first set into a temp buffer
        const list1_alloca = self.builder.buildAlloca(list_type, "list1");
        _ = self.builder.buildStore(null_ptr, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list1_alloca, 0, ""));
        _ = self.builder.buildStore(zero_i32, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list1_alloca, 1, ""));
        _ = self.builder.buildStore(zero_i32, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list1_alloca, 2, ""));

        const list2_alloca = self.builder.buildAlloca(list_type, "list2");
        _ = self.builder.buildStore(null_ptr, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list2_alloca, 0, ""));
        _ = self.builder.buildStore(zero_i32, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list2_alloca, 1, ""));
        _ = self.builder.buildStore(zero_i32, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list2_alloca, 2, ""));

        const idx1_alloca = self.builder.buildAlloca(i32_type, "idx1");
        _ = self.builder.buildStore(zero_i32, idx1_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop1_block);

        // Loop 1: Collect from first set
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop1_block);
        const idx1 = self.builder.buildLoad(i32_type, idx1_alloca, "idx1");
        const cond1 = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx1, capacity, "cond1");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, cond1, check1_block, loop2_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check1_block);
        const idx1_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx1, i64_type, "idx1_i64");
        var indices1 = [_]llvm.ValueRef{idx1_i64};
        const entry1_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, entry_type, entries, &indices1, 1, "entry1_ptr");
        const state1_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry1_ptr, 0, "state1_ptr");
        const state1 = self.builder.buildLoad(i8_type, state1_ptr, "state1");
        const is_occ1 = self.builder.buildICmp(llvm.c.LLVMIntEQ, state1, llvm.Const.int8(self.ctx, 1), "is_occ1");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ1, store1_block, next1_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, store1_block);
        const elem1_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, entry_type, entry1_ptr, 2, "elem1_ptr");
        const elem1 = self.builder.buildLoad(element_llvm_type, elem1_ptr, "elem1");
        // Push to list1 (simplified - just use emitListPushInline pattern)
        try self.emitListPushInline(list1_alloca, elem1, element_llvm_type);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next1_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next1_block);
        const next_idx1 = llvm.c.LLVMBuildAdd(self.builder.ref, idx1, llvm.Const.int32(self.ctx, 1), "next_idx1");
        _ = self.builder.buildStore(next_idx1, idx1_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop1_block);

        // Loop 2: Collect from second set
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop2_block);
        const idx2_alloca = self.builder.buildAlloca(i32_type, "idx2");
        _ = self.builder.buildStore(zero_i32, idx2_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, check2_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, check2_block);
        const idx2 = self.builder.buildLoad(i32_type, idx2_alloca, "idx2");
        const cond2 = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx2, other_capacity, "cond2");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, cond2, store2_block, done_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, store2_block);
        const idx2_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx2, i64_type, "idx2_i64");
        var indices2 = [_]llvm.ValueRef{idx2_i64};
        const entry2_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, other_entry_type, other_entries, &indices2, 1, "entry2_ptr");
        const state2_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, other_entry_type, entry2_ptr, 0, "state2_ptr");
        const state2 = self.builder.buildLoad(i8_type, state2_ptr, "state2");
        const is_occ2 = self.builder.buildICmp(llvm.c.LLVMIntEQ, state2, llvm.Const.int8(self.ctx, 1), "is_occ2");

        const add_tuple_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_add_tuple");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_occ2, add_tuple_block, next2_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, add_tuple_block);
        const elem2_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, other_entry_type, entry2_ptr, 2, "elem2_ptr");
        const elem2 = self.builder.buildLoad(other_element_llvm_type, elem2_ptr, "elem2");
        try self.emitListPushInline(list2_alloca, elem2, other_element_llvm_type);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, next2_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, next2_block);
        const next_idx2 = llvm.c.LLVMBuildAdd(self.builder.ref, idx2, llvm.Const.int32(self.ctx, 1), "next_idx2");
        _ = self.builder.buildStore(next_idx2, idx2_alloca);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, check2_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, done_block);
        // Now pair elements from list1 and list2
        const list1_ptr = self.builder.buildLoad(ptr_type, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list1_alloca, 0, ""), "list1_ptr");
        const list1_len = self.builder.buildLoad(i32_type, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list1_alloca, 1, ""), "list1_len");
        const list2_ptr = self.builder.buildLoad(ptr_type, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list2_alloca, 0, ""), "list2_ptr");
        const list2_len = self.builder.buildLoad(i32_type, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list2_alloca, 1, ""), "list2_len");

        // min_len = min(list1_len, list2_len)
        const len_cmp = self.builder.buildICmp(llvm.c.LLVMIntSLT, list1_len, list2_len, "len_cmp");
        const min_len = llvm.c.LLVMBuildSelect(self.builder.ref, len_cmp, list1_len, list2_len, "min_len");

        // Allocate result buffer
        const min_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, min_len, i64_type, "min_len_i64");
        const tuple_size_val = llvm.Const.int64(self.ctx, @intCast(tuple_size));
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, min_len_i64, tuple_size_val, "alloc_size");

        const is_zero = self.builder.buildICmp(llvm.c.LLVMIntEQ, min_len, zero_i32, "is_zero");

        const alloc_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_alloc");
        const build_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_build");
        const final_block = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_final");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_zero, final_block, alloc_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, alloc_block);
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const result_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "result_ptr");
        _ = self.builder.buildStore(result_ptr, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 0, ""));
        _ = self.builder.buildStore(min_len, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 1, ""));
        _ = self.builder.buildStore(min_len, llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, result_alloca, 2, ""));

        // Build tuples
        const build_idx = self.builder.buildAlloca(i32_type, "build_idx");
        _ = self.builder.buildStore(zero_i32, build_idx);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, build_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, build_block);
        const bi = self.builder.buildLoad(i32_type, build_idx, "bi");
        const build_cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, bi, min_len, "build_cond");

        const build_body = llvm.c.LLVMAppendBasicBlock(current_fn, "zip_build_body");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, build_cond, build_body, final_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, build_body);
        const bi_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, bi, i64_type, "bi_i64");

        var idx_arr1 = [_]llvm.ValueRef{bi_i64};
        const e1_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, element_llvm_type, list1_ptr, &idx_arr1, 1, "e1_ptr");
        const e1 = self.builder.buildLoad(element_llvm_type, e1_ptr, "e1");

        var idx_arr2 = [_]llvm.ValueRef{bi_i64};
        const e2_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, other_element_llvm_type, list2_ptr, &idx_arr2, 1, "e2_ptr");
        const e2 = self.builder.buildLoad(other_element_llvm_type, e2_ptr, "e2");

        var tup = llvm.c.LLVMGetUndef(tuple_type);
        tup = llvm.c.LLVMBuildInsertValue(self.builder.ref, tup, e1, 0, "tup.0");
        tup = llvm.c.LLVMBuildInsertValue(self.builder.ref, tup, e2, 1, "tup.1");

        var res_idx_arr = [_]llvm.ValueRef{bi_i64};
        const res_elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, tuple_type, result_ptr, &res_idx_arr, 1, "res_elem_ptr");
        _ = self.builder.buildStore(tup, res_elem_ptr);

        const next_bi = llvm.c.LLVMBuildAdd(self.builder.ref, bi, llvm.Const.int32(self.ctx, 1), "next_bi");
        _ = self.builder.buildStore(next_bi, build_idx);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, build_block);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, final_block);
        return self.builder.buildLoad(list_type, result_alloca, "zip.result");
    }

    /// Helper to push an element to a list inline
    fn emitListPushInline(self: *Emitter, list_alloca: llvm.ValueRef, elem: llvm.ValueRef, elem_type: llvm.TypeRef) EmitError!void {
        const list_type = self.getListStructType();
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        const elem_size = self.getLLVMTypeSize(elem_type);

        const res_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 0, "res_ptr_ptr");
        const res_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 1, "res_len_ptr");
        const res_cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_alloca, 2, "res_cap_ptr");

        const res_ptr = self.builder.buildLoad(ptr_type, res_ptr_ptr, "res_ptr");
        const res_len = self.builder.buildLoad(i32_type, res_len_ptr, "res_len");
        const res_cap = self.builder.buildLoad(i32_type, res_cap_ptr, "res_cap");

        const need_grow = self.builder.buildICmp(llvm.c.LLVMIntSGE, res_len, res_cap, "need_grow");

        // Capture the entry block BEFORE creating the conditional branch
        const entry_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const current_fn = llvm.c.LLVMGetBasicBlockParent(entry_bb);
        const grow_bb = llvm.c.LLVMAppendBasicBlock(current_fn, "push.grow");
        const store_bb = llvm.c.LLVMAppendBasicBlock(current_fn, "push.store");
        const cont_bb = llvm.c.LLVMAppendBasicBlock(current_fn, "push.cont");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, need_grow, grow_bb, store_bb);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, grow_bb);
        const doubled_cap = llvm.c.LLVMBuildMul(self.builder.ref, res_cap, llvm.Const.int32(self.ctx, 2), "doubled");
        const eight = llvm.Const.int32(self.ctx, 8);
        const cmp_eight = self.builder.buildICmp(llvm.c.LLVMIntSGT, doubled_cap, eight, "cmp_eight");
        const new_cap = llvm.c.LLVMBuildSelect(self.builder.ref, cmp_eight, doubled_cap, eight, "new_cap");

        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "new_cap_i64");
        const elem_size_val = llvm.Const.int64(self.ctx, @intCast(elem_size));
        const new_size = llvm.c.LLVMBuildMul(self.builder.ref, new_cap_i64, elem_size_val, "new_size");

        const realloc_fn = self.getOrDeclareRealloc();
        var realloc_args = [_]llvm.ValueRef{ res_ptr, new_size };
        const grown_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(realloc_fn), realloc_fn, &realloc_args, "grown_ptr");

        _ = self.builder.buildStore(grown_ptr, res_ptr_ptr);
        _ = self.builder.buildStore(new_cap, res_cap_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, store_bb);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, store_bb);
        const phi = llvm.c.LLVMBuildPhi(self.builder.ref, ptr_type, "data_ptr");
        var incoming_values = [_]llvm.ValueRef{ res_ptr, grown_ptr };
        var incoming_blocks = [_]llvm.BasicBlockRef{ entry_bb, grow_bb };
        llvm.c.LLVMAddIncoming(phi, &incoming_values, &incoming_blocks, 2);

        const res_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, res_len, i64_type, "res_len_i64");
        var store_indices = [_]llvm.ValueRef{res_len_i64};
        const store_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, elem_type, phi, &store_indices, 1, "store_ptr");
        _ = self.builder.buildStore(elem, store_ptr);

        const new_res_len = llvm.c.LLVMBuildAdd(self.builder.ref, res_len, llvm.Const.int32(self.ctx, 1), "new_res_len");
        _ = self.builder.buildStore(new_res_len, res_len_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, cont_bb);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, cont_bb);
    }

    // ========================================================================
    // String Methods (heap-allocated string)
    // ========================================================================

    /// Emit String.new() - creates an empty string.
    fn emitStringNew(self: *Emitter) EmitError!llvm.ValueRef {
        // Build String struct type (same as List)
        const string_type = self.getStringStructType();

        // Create an empty string struct { null, 0, 0 } directly
        const null_ptr = llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        const zero_i32 = llvm.Const.int32(self.ctx, 0);

        var values = [_]llvm.ValueRef{ null_ptr, zero_i32, zero_i32 };
        return llvm.c.LLVMConstNamedStruct(string_type, &values, 3);
    }

    /// Emit String.from(s) - creates a string from a string literal.
    /// Implemented inline: calculates length, allocates memory, copies content.
    fn emitStringFrom(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) return EmitError.InvalidAST;

        // Emit the string literal argument (pointer to null-terminated string)
        const str_literal = try self.emitExpr(method.args[0]);

        const string_type = self.getStringStructType();
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Call strlen to get the length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{str_literal};
        const len_i64 = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &strlen_args, "str.len");

        // Convert to i32 (String uses i32 for len)
        const len_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, len_i64, i32_type, "str.len_i32");

        // Allocate memory: len + 1 for null terminator
        const one_i32 = llvm.Const.int32(self.ctx, 1);
        const alloc_len = llvm.c.LLVMBuildAdd(self.builder.ref, len_i32, one_i32, "str.alloc_len");
        const alloc_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, alloc_len, i64_type, "str.alloc_len_i64");

        // Call malloc
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_len_i64};
        const new_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "str.ptr");

        // Call memcpy to copy content (including null terminator)
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ new_ptr, str_literal, alloc_len_i64 };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Build the String struct: { ptr, len, len } (capacity = len for from())
        const string_alloca = self.builder.buildAlloca(string_type, "str.result");
        const ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_alloca, 0, "str.ptr_field");
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_alloca, 1, "str.len_field");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_alloca, 2, "str.cap_field");

        _ = self.builder.buildStore(new_ptr, ptr_field);
        _ = self.builder.buildStore(len_i32, len_field);
        _ = self.builder.buildStore(len_i32, cap_field); // capacity = len for from()

        // Load and return the struct value
        return self.builder.buildLoad(string_type, string_alloca, "str.from.result");
    }

    /// Emit String.with_capacity(n) - creates a string with pre-allocated capacity.
    /// Implemented inline: allocates memory using malloc, returns { ptr, 0, capacity }.
    fn emitStringWithCapacity(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) return EmitError.InvalidAST;

        // Emit the capacity argument (i32)
        const capacity = try self.emitExpr(method.args[0]);

        const string_type = self.getStringStructType();
        const i64_type = llvm.Types.int64(self.ctx);

        // Allocate memory: capacity + 1 for null terminator
        const one_i32 = llvm.Const.int32(self.ctx, 1);
        const alloc_size_i32 = llvm.c.LLVMBuildAdd(self.builder.ref, capacity, one_i32, "str.alloc_size");
        const alloc_size = llvm.c.LLVMBuildSExt(self.builder.ref, alloc_size_i32, i64_type, "str.alloc_size_i64");

        // Call malloc
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const new_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "str.ptr");

        // Build the String struct: { ptr, 0, capacity }
        const string_alloca = self.builder.buildAlloca(string_type, "str.result");
        const ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_alloca, 0, "str.ptr_field");
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_alloca, 1, "str.len_field");
        const cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, string_alloca, 2, "str.cap_field");

        _ = self.builder.buildStore(new_ptr, ptr_field);
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_field); // len = 0
        _ = self.builder.buildStore(capacity, cap_field); // capacity from argument

        // Load and return the struct value
        return self.builder.buildLoad(string_type, string_alloca, "str.with_cap.result");
    }

    /// Emit string.len() for heap-allocated String type - returns the byte length.
    fn emitStringDataLen(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const string_type = self.getStringStructType();
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "str.len_ptr");
        return self.builder.buildLoad(llvm.Types.int32(self.ctx), len_ptr, "str.len");
    }

    /// Emit string.is_empty() for heap-allocated String type - checks if the string is empty.
    fn emitStringDataIsEmpty(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const len = try self.emitStringDataLen(str_ptr);
        const zero = llvm.Const.int32(self.ctx, 0);
        return self.builder.buildICmp(llvm.c.LLVMIntEQ, len, zero, "str.is_empty");
    }

    /// Emit string.capacity() - returns the allocated capacity.
    fn emitStringCapacity(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const string_type = self.getStringStructType();
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 2, "str.cap_ptr");
        return self.builder.buildLoad(llvm.Types.int32(self.ctx), cap_ptr, "str.cap");
    }

    /// Emit string.push(char) - appends a character (UTF-8 encoded).
    /// Implemented inline with growth logic similar to List.push.
    fn emitStringPush(self: *Emitter, str_ptr: llvm.ValueRef, char_val: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);

        // Load current ptr, len, capacity
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "push.ptr_ptr");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "push.len_ptr");
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 2, "push.cap_ptr");

        const current_ptr = self.builder.buildLoad(ptr_type, ptr_ptr, "push.current_ptr");
        const current_len = self.builder.buildLoad(i32_type, len_ptr, "push.current_len");
        const current_cap = self.builder.buildLoad(i32_type, cap_ptr, "push.current_cap");

        // For now, assume single-byte character (ASCII). UTF-8 multi-byte would need more logic.
        // Need 1 extra byte for the character
        const one = llvm.Const.int32(self.ctx, 1);
        const new_len = llvm.c.LLVMBuildAdd(self.builder.ref, current_len, one, "push.new_len");

        // Check if we need to grow: new_len >= capacity (need space for null terminator)
        const need_grow = self.builder.buildICmp(llvm.c.LLVMIntSGE, new_len, current_cap, "push.need_grow");

        // Save the current block BEFORE creating new blocks (for PHI node incoming edge)
        const entry_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Create basic blocks for growth path
        const grow_bb = llvm.appendBasicBlock(self.ctx, func, "push.grow");
        const store_bb = llvm.appendBasicBlock(self.ctx, func, "push.store");

        _ = self.builder.buildCondBr(need_grow, grow_bb, store_bb);

        // --- Grow block ---
        self.builder.positionAtEnd(grow_bb);

        // New capacity = max(16, capacity * 2)
        const doubled_cap = llvm.c.LLVMBuildMul(self.builder.ref, current_cap, llvm.Const.int32(self.ctx, 2), "push.doubled");
        const sixteen = llvm.Const.int32(self.ctx, 16);
        const cmp_sixteen = self.builder.buildICmp(llvm.c.LLVMIntSGT, doubled_cap, sixteen, "push.cmp_sixteen");
        const new_cap = llvm.c.LLVMBuildSelect(self.builder.ref, cmp_sixteen, doubled_cap, sixteen, "push.new_cap");

        // Calculate new size in bytes: new_cap (includes space for null terminator)
        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "push.new_cap_i64");

        // Call realloc(ptr, new_size)
        const realloc_fn = self.getOrDeclareRealloc();
        var realloc_args = [_]llvm.ValueRef{ current_ptr, new_cap_i64 };
        const new_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(realloc_fn), realloc_fn, &realloc_args, "push.new_ptr");

        // Store new ptr and capacity
        _ = self.builder.buildStore(new_ptr, ptr_ptr);
        _ = self.builder.buildStore(new_cap, cap_ptr);

        _ = self.builder.buildBr(store_bb);

        // --- Store block ---
        self.builder.positionAtEnd(store_bb);

        // PHI for the data pointer (either current_ptr or new_ptr from grow)
        // Use saved entry_bb (not LLVMGetPreviousBasicBlock) to correctly handle
        // cases where emitting the char value created intermediate basic blocks
        const phi = llvm.c.LLVMBuildPhi(self.builder.ref, ptr_type, "push.data_ptr");
        var incoming_values = [_]llvm.ValueRef{ current_ptr, new_ptr };
        var incoming_blocks = [_]llvm.BasicBlockRef{ entry_bb, grow_bb };
        llvm.c.LLVMAddIncoming(phi, &incoming_values, &incoming_blocks, 2);

        // Calculate address: ptr + len
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_len, i64_type, "push.len_i64");
        var gep_indices = [_]llvm.ValueRef{len_i64};
        const char_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, phi, &gep_indices, 1, "push.char_ptr");

        // Truncate char (i32) to i8 and store
        const char_i8 = llvm.c.LLVMBuildTrunc(self.builder.ref, char_val, i8_type, "push.char_i8");
        _ = self.builder.buildStore(char_i8, char_ptr);

        // Store null terminator at len + 1
        const null_offset = llvm.c.LLVMBuildAdd(self.builder.ref, len_i64, llvm.Const.int64(self.ctx, 1), "push.null_offset");
        var null_indices = [_]llvm.ValueRef{null_offset};
        const null_ptr_addr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, phi, &null_indices, 1, "push.null_ptr");
        _ = self.builder.buildStore(llvm.Const.int(i8_type, 0, false), null_ptr_addr);

        // Store new length
        _ = self.builder.buildStore(new_len, len_ptr);

        // Return void (represented as i32 0 for now)
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit string.concat(other) - concatenates two strings, returns new string.
    /// Implemented inline: allocates new buffer, copies both strings, returns new String struct.
    fn emitStringConcat(self: *Emitter, str_ptr: llvm.ValueRef, other_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);

        // Load ptr1, len1 from first string
        const ptr1_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "concat.ptr1_ptr");
        const len1_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "concat.len1_ptr");
        const ptr1 = self.builder.buildLoad(ptr_type, ptr1_ptr, "concat.ptr1");
        const len1 = self.builder.buildLoad(i32_type, len1_ptr, "concat.len1");

        // Load ptr2, len2 from second string
        const ptr2_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, other_ptr, 0, "concat.ptr2_ptr");
        const len2_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, other_ptr, 1, "concat.len2_ptr");
        const ptr2 = self.builder.buildLoad(ptr_type, ptr2_ptr, "concat.ptr2");
        const len2 = self.builder.buildLoad(i32_type, len2_ptr, "concat.len2");

        // total_len = len1 + len2
        const total_len = llvm.c.LLVMBuildAdd(self.builder.ref, len1, len2, "concat.total_len");

        // new_cap = total_len + 1 (for null terminator)
        const one = llvm.Const.int32(self.ctx, 1);
        const new_cap = llvm.c.LLVMBuildAdd(self.builder.ref, total_len, one, "concat.new_cap");

        // Allocate: malloc(new_cap)
        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "concat.new_cap_i64");
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{new_cap_i64};
        const new_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "concat.new_ptr");

        // memcpy(new_ptr, ptr1, len1)
        const len1_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, len1, i64_type, "concat.len1_i64");
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args1 = [_]llvm.ValueRef{ new_ptr, ptr1, len1_i64 };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args1, "");

        // memcpy(new_ptr + len1, ptr2, len2)
        var gep_indices = [_]llvm.ValueRef{len1_i64};
        const dest2 = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, new_ptr, &gep_indices, 1, "concat.dest2");
        const len2_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, len2, i64_type, "concat.len2_i64");
        var memcpy_args2 = [_]llvm.ValueRef{ dest2, ptr2, len2_i64 };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args2, "");

        // Store null terminator at new_ptr + total_len
        const total_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, total_len, i64_type, "concat.total_len_i64");
        var null_indices = [_]llvm.ValueRef{total_len_i64};
        const null_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, new_ptr, &null_indices, 1, "concat.null_ptr");
        _ = self.builder.buildStore(llvm.Const.int(i8_type, 0, false), null_ptr);

        // Build result String struct: { new_ptr, total_len, new_cap }
        const result_alloca = self.builder.buildAlloca(string_type, "concat.result");
        const result_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result_alloca, 0, "concat.result_ptr");
        const result_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result_alloca, 1, "concat.result_len");
        const result_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result_alloca, 2, "concat.result_cap");

        _ = self.builder.buildStore(new_ptr, result_ptr_field);
        _ = self.builder.buildStore(total_len, result_len_field);
        _ = self.builder.buildStore(new_cap, result_cap_field);

        // Return loaded struct value
        return self.builder.buildLoad(string_type, result_alloca, "concat.result_val");
    }

    /// Emit string.append(other) - appends other string to this one (mutates).
    /// Implemented inline with growth logic similar to push but for multiple bytes.
    fn emitStringAppend(self: *Emitter, str_ptr: llvm.ValueRef, other_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);

        // Load other's len first to check if empty
        const other_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, other_ptr, 1, "append.other_len_ptr");
        const other_len = self.builder.buildLoad(i32_type, other_len_ptr, "append.other_len");

        // Early return if other is empty: if (other.len == 0) return
        const zero = llvm.Const.int32(self.ctx, 0);
        const other_empty = self.builder.buildICmp(llvm.c.LLVMIntEQ, other_len, zero, "append.other_empty");

        const do_append_bb = llvm.appendBasicBlock(self.ctx, func, "append.do");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "append.end");

        _ = self.builder.buildCondBr(other_empty, end_bb, do_append_bb);

        // --- Do append block ---
        self.builder.positionAtEnd(do_append_bb);

        // Load self's ptr, len, capacity
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "append.ptr_ptr");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "append.len_ptr");
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 2, "append.cap_ptr");

        const current_ptr = self.builder.buildLoad(ptr_type, ptr_ptr, "append.current_ptr");
        const current_len = self.builder.buildLoad(i32_type, len_ptr, "append.current_len");
        const current_cap = self.builder.buildLoad(i32_type, cap_ptr, "append.current_cap");

        // Load other's ptr
        const other_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, other_ptr, 0, "append.other_ptr_ptr");
        const other_data_ptr = self.builder.buildLoad(ptr_type, other_ptr_ptr, "append.other_data");

        // new_len = self.len + other.len
        const new_len = llvm.c.LLVMBuildAdd(self.builder.ref, current_len, other_len, "append.new_len");

        // need_space = new_len + 1 (for null terminator)
        const one = llvm.Const.int32(self.ctx, 1);
        const need_space = llvm.c.LLVMBuildAdd(self.builder.ref, new_len, one, "append.need_space");

        // Check if we need to grow: need_space > capacity
        const need_grow = self.builder.buildICmp(llvm.c.LLVMIntSGT, need_space, current_cap, "append.need_grow");

        const grow_bb = llvm.appendBasicBlock(self.ctx, func, "append.grow");
        const copy_bb = llvm.appendBasicBlock(self.ctx, func, "append.copy");

        _ = self.builder.buildCondBr(need_grow, grow_bb, copy_bb);

        // --- Grow block ---
        self.builder.positionAtEnd(grow_bb);

        // Calculate new capacity: start with current cap (or 16 if 0), double until >= need_space
        // For simplicity, use: new_cap = max(16, need_space * 2)
        const sixteen = llvm.Const.int32(self.ctx, 16);
        const need_space_doubled = llvm.c.LLVMBuildMul(self.builder.ref, need_space, llvm.Const.int32(self.ctx, 2), "append.need_doubled");
        const cmp = self.builder.buildICmp(llvm.c.LLVMIntSGT, need_space_doubled, sixteen, "append.cmp");
        const new_cap = llvm.c.LLVMBuildSelect(self.builder.ref, cmp, need_space_doubled, sixteen, "append.new_cap");

        // realloc(ptr, new_cap)
        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "append.new_cap_i64");
        const realloc_fn = self.getOrDeclareRealloc();
        var realloc_args = [_]llvm.ValueRef{ current_ptr, new_cap_i64 };
        const grown_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(realloc_fn), realloc_fn, &realloc_args, "append.grown_ptr");

        // Store new ptr and capacity
        _ = self.builder.buildStore(grown_ptr, ptr_ptr);
        _ = self.builder.buildStore(new_cap, cap_ptr);

        _ = self.builder.buildBr(copy_bb);

        // --- Copy block ---
        self.builder.positionAtEnd(copy_bb);

        // PHI for data pointer
        const data_phi = llvm.c.LLVMBuildPhi(self.builder.ref, ptr_type, "append.data_ptr");
        var incoming_values = [_]llvm.ValueRef{ current_ptr, grown_ptr };
        var incoming_blocks = [_]llvm.BasicBlockRef{ do_append_bb, grow_bb };
        llvm.c.LLVMAddIncoming(data_phi, &incoming_values, &incoming_blocks, 2);

        // memcpy(data_ptr + current_len, other_data, other_len)
        const current_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_len, i64_type, "append.cur_len_i64");
        var dest_indices = [_]llvm.ValueRef{current_len_i64};
        const dest_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, data_phi, &dest_indices, 1, "append.dest");

        const other_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, other_len, i64_type, "append.other_len_i64");
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ dest_ptr, other_data_ptr, other_len_i64 };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Store null terminator at data_ptr + new_len
        const new_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_len, i64_type, "append.new_len_i64");
        var null_indices = [_]llvm.ValueRef{new_len_i64};
        const null_ptr_addr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, data_phi, &null_indices, 1, "append.null_ptr");
        _ = self.builder.buildStore(llvm.Const.int(i8_type, 0, false), null_ptr_addr);

        // Update len
        _ = self.builder.buildStore(new_len, len_ptr);

        _ = self.builder.buildBr(end_bb);

        // --- End block ---
        self.builder.positionAtEnd(end_bb);

        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit string.as_str() - returns pointer to null-terminated C string.
    /// Simply returns the ptr field (which is already null-terminated).
    fn emitStringAsStr(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);

        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "asstr.ptr_ptr");
        return self.builder.buildLoad(ptr_type, ptr_ptr, "asstr.ptr");
    }

    /// Emit string.clear() - clears the string (keeps capacity).
    /// Sets len to 0 and writes null terminator at start (if ptr is not null).
    fn emitStringClear(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);

        // Set len = 0
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "clear.len_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_ptr);

        // Load data pointer
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "clear.ptr_ptr");
        const data_ptr = self.builder.buildLoad(ptr_type, ptr_ptr, "clear.data_ptr");

        // Check if ptr is not null before writing null terminator
        const null_ptr = llvm.Const.null_(ptr_type);
        const is_not_null = self.builder.buildICmp(llvm.c.LLVMIntNE, data_ptr, null_ptr, "clear.is_not_null");

        const write_bb = llvm.appendBasicBlock(self.ctx, func, "clear.write");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "clear.end");

        _ = self.builder.buildCondBr(is_not_null, write_bb, end_bb);

        // --- Write block ---
        self.builder.positionAtEnd(write_bb);
        _ = self.builder.buildStore(llvm.Const.int(i8_type, 0, false), data_ptr);
        _ = self.builder.buildBr(end_bb);

        // --- End block ---
        self.builder.positionAtEnd(end_bb);

        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit string.clone() - creates a deep copy.
    /// Allocates new buffer, copies data, returns new String struct.
    fn emitStringClone(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);

        // Load source ptr, len
        const src_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "clone.src_ptr_ptr");
        const src_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "clone.src_len_ptr");
        const src_ptr = self.builder.buildLoad(ptr_type, src_ptr_ptr, "clone.src_ptr");
        const src_len = self.builder.buildLoad(i32_type, src_len_ptr, "clone.src_len");

        // new_cap = len + 1
        const one = llvm.Const.int32(self.ctx, 1);
        const new_cap = llvm.c.LLVMBuildAdd(self.builder.ref, src_len, one, "clone.new_cap");

        // malloc(new_cap)
        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "clone.new_cap_i64");
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{new_cap_i64};
        const new_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "clone.new_ptr");

        // memcpy(new_ptr, src_ptr, len)
        const src_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, src_len, i64_type, "clone.src_len_i64");
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ new_ptr, src_ptr, src_len_i64 };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Write null terminator
        var null_indices = [_]llvm.ValueRef{src_len_i64};
        const null_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, new_ptr, &null_indices, 1, "clone.null_ptr");
        _ = self.builder.buildStore(llvm.Const.int(i8_type, 0, false), null_ptr);

        // Build result String struct: { new_ptr, len, new_cap }
        const result_alloca = self.builder.buildAlloca(string_type, "clone.result");
        const result_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result_alloca, 0, "clone.result_ptr");
        const result_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result_alloca, 1, "clone.result_len");
        const result_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result_alloca, 2, "clone.result_cap");

        _ = self.builder.buildStore(new_ptr, result_ptr_field);
        _ = self.builder.buildStore(src_len, result_len_field);
        _ = self.builder.buildStore(new_cap, result_cap_field);

        return self.builder.buildLoad(string_type, result_alloca, "clone.result_val");
    }

    /// Emit string.drop() - frees the string's memory.
    /// Calls free(ptr) and zeroes the struct.
    fn emitStringDrop(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load ptr
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "drop.ptr_ptr");
        const data_ptr = self.builder.buildLoad(ptr_type, ptr_ptr, "drop.data_ptr");

        // free(ptr)
        const free_fn = self.getOrDeclareFree();
        var free_args = [_]llvm.ValueRef{data_ptr};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(free_fn), free_fn, &free_args, "");

        // Zero the struct: ptr=null, len=0, cap=0
        const null_ptr = llvm.Const.null_(ptr_type);
        const zero = llvm.Const.int32(self.ctx, 0);

        _ = self.builder.buildStore(null_ptr, ptr_ptr);
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "drop.len_ptr");
        _ = self.builder.buildStore(zero, len_ptr);
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 2, "drop.cap_ptr");
        _ = self.builder.buildStore(zero, cap_ptr);

        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit string.eq(other) - compares two strings for equality.
    /// Returns true if lengths match and all bytes match.
    fn emitStringEq(self: *Emitter, str_ptr: llvm.ValueRef, other_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);

        // Load len1, len2
        const len1_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "eq.len1_ptr");
        const len2_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, other_ptr, 1, "eq.len2_ptr");
        const len1 = self.builder.buildLoad(i32_type, len1_ptr, "eq.len1");
        const len2 = self.builder.buildLoad(i32_type, len2_ptr, "eq.len2");

        // First check: lengths must be equal
        const lens_equal = self.builder.buildICmp(llvm.c.LLVMIntEQ, len1, len2, "eq.lens_equal");

        const check_bytes_bb = llvm.appendBasicBlock(self.ctx, func, "eq.check_bytes");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "eq.end");

        _ = self.builder.buildCondBr(lens_equal, check_bytes_bb, end_bb);

        // --- Check bytes block ---
        self.builder.positionAtEnd(check_bytes_bb);

        // Use memcmp for byte comparison
        const ptr1_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "eq.ptr1_ptr");
        const ptr2_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, other_ptr, 0, "eq.ptr2_ptr");
        const ptr1 = self.builder.buildLoad(ptr_type, ptr1_ptr, "eq.ptr1");
        const ptr2 = self.builder.buildLoad(ptr_type, ptr2_ptr, "eq.ptr2");

        const i64_type = llvm.Types.int64(self.ctx);
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, len1, i64_type, "eq.len_i64");
        const memcmp_fn = self.getOrDeclareMemcmp();
        var memcmp_args = [_]llvm.ValueRef{ ptr1, ptr2, len_i64 };
        const cmp_result = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcmp_fn), memcmp_fn, &memcmp_args, "eq.cmp_result");

        // memcmp returns 0 if equal
        const bytes_equal = self.builder.buildICmp(llvm.c.LLVMIntEQ, cmp_result, llvm.Const.int32(self.ctx, 0), "eq.bytes_equal");

        _ = self.builder.buildBr(end_bb);

        // --- End block ---
        self.builder.positionAtEnd(end_bb);

        // PHI: true from check_bytes if bytes_equal, false from entry if lens differ
        const result_phi = llvm.c.LLVMBuildPhi(self.builder.ref, i1_type, "eq.result");
        const false_val = llvm.Const.int(i1_type, 0, false);
        var incoming_values = [_]llvm.ValueRef{ false_val, bytes_equal };
        const entry_bb = llvm.c.LLVMGetPreviousBasicBlock(check_bytes_bb);
        var incoming_blocks = [_]llvm.BasicBlockRef{ entry_bb, check_bytes_bb };
        llvm.c.LLVMAddIncoming(result_phi, &incoming_values, &incoming_blocks, 2);

        return result_phi;
    }

    /// Emit string.hash() for heap-allocated String type - computes FNV-1a hash.
    fn emitStringDataHash(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);

        // FNV-1a constants
        const FNV_OFFSET: u64 = 14695981039346656037;
        const FNV_PRIME: u64 = 1099511628211;

        // Load ptr, len
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "hash.ptr_ptr");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "hash.len_ptr");
        const data_ptr = self.builder.buildLoad(ptr_type, ptr_ptr, "hash.data_ptr");
        const len = self.builder.buildLoad(i32_type, len_ptr, "hash.len");

        // Initialize hash = FNV_OFFSET
        const hash_alloca = self.builder.buildAlloca(i64_type, "hash.val");
        _ = self.builder.buildStore(llvm.Const.int(i64_type, @bitCast(FNV_OFFSET), false), hash_alloca);

        // Loop index
        const idx_alloca = self.builder.buildAlloca(i32_type, "hash.idx");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), idx_alloca);

        // Loop blocks
        const loop_cond_bb = llvm.appendBasicBlock(self.ctx, func, "hash.loop_cond");
        const loop_body_bb = llvm.appendBasicBlock(self.ctx, func, "hash.loop_body");
        const loop_end_bb = llvm.appendBasicBlock(self.ctx, func, "hash.loop_end");

        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop condition ---
        self.builder.positionAtEnd(loop_cond_bb);
        const idx = self.builder.buildLoad(i32_type, idx_alloca, "hash.idx_val");
        const cond = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx, len, "hash.cond");
        _ = self.builder.buildCondBr(cond, loop_body_bb, loop_end_bb);

        // --- Loop body ---
        self.builder.positionAtEnd(loop_body_bb);

        // Load byte at data_ptr[idx]
        const idx_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, idx, i64_type, "hash.idx_i64");
        var gep_indices = [_]llvm.ValueRef{idx_i64};
        const byte_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, data_ptr, &gep_indices, 1, "hash.byte_ptr");
        const byte = self.builder.buildLoad(i8_type, byte_ptr, "hash.byte");
        const byte_i64 = llvm.c.LLVMBuildZExt(self.builder.ref, byte, i64_type, "hash.byte_i64");

        // hash ^= byte
        const current_hash = self.builder.buildLoad(i64_type, hash_alloca, "hash.current");
        const xored = llvm.c.LLVMBuildXor(self.builder.ref, current_hash, byte_i64, "hash.xored");

        // hash *= FNV_PRIME (wrapping)
        const multiplied = llvm.c.LLVMBuildMul(self.builder.ref, xored, llvm.Const.int(i64_type, @bitCast(FNV_PRIME), false), "hash.multiplied");
        _ = self.builder.buildStore(multiplied, hash_alloca);

        // idx++
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int32(self.ctx, 1), "hash.next_idx");
        _ = self.builder.buildStore(next_idx, idx_alloca);

        _ = self.builder.buildBr(loop_cond_bb);

        // --- Loop end ---
        self.builder.positionAtEnd(loop_end_bb);

        // Return hash as i64
        return self.builder.buildLoad(i64_type, hash_alloca, "hash.result");
    }

    /// Emit String.as_cstr() -> CStr
    /// Returns a pointer to the null-terminated string data.
    fn emitStringDataAsCstr(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const string_type = self.getStringStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Get pointer to the ptr field of the String struct
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "as_cstr.ptr_ptr");

        // Load the data pointer - this is already null-terminated
        return self.builder.buildLoad(ptr_type, ptr_ptr, "as_cstr.ptr");
    }

    /// Emit CStr.to_string() -> String
    /// Copies the C string to a new Klar String.
    /// Implements inline: strlen, malloc, memcpy (like emitStringFrom).
    fn emitCstrToString(self: *Emitter, cstr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const string_type = self.getStringStructType();
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Call strlen to get the length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{cstr};
        const len_i64 = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &strlen_args, "cstr.len");

        // Convert to i32 (String uses i32 for len)
        const len_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, len_i64, i32_type, "cstr.len_i32");

        // Allocate memory: len + 1 for null terminator
        const one_i32 = llvm.Const.int32(self.ctx, 1);
        const alloc_len = llvm.c.LLVMBuildAdd(self.builder.ref, len_i32, one_i32, "cstr.alloc_len");
        const alloc_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, alloc_len, i64_type, "cstr.alloc_len_i64");

        // Call malloc
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_len_i64};
        const str_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "cstr.ptr");

        // Call memcpy to copy the string (including null terminator)
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ str_ptr, cstr, alloc_len_i64 };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "cstr.memcpy");

        // Build the String result struct
        const result = self.builder.buildAlloca(string_type, "cstr.result");

        // Set ptr field
        const ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result, 0, "cstr.ptr_ptr");
        _ = self.builder.buildStore(str_ptr, ptr_ptr);

        // Set len field
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result, 1, "cstr.len_ptr");
        _ = self.builder.buildStore(len_i32, len_ptr);

        // Set capacity field (capacity = len + 1)
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, result, 2, "cstr.cap_ptr");
        _ = self.builder.buildStore(alloc_len, cap_ptr);

        // Load and return the struct
        return self.builder.buildLoad(string_type, result, "cstr.to_string");
    }

    /// Emit CStr.len() -> usize
    /// Returns the length of the C string by calling strlen.
    fn emitCstrLen(self: *Emitter, cstr: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Declare or get strlen
        const strlen_fn = self.getOrDeclareStrlen();
        const strlen_fn_type = llvm.c.LLVMGlobalGetValueType(strlen_fn);

        // Call strlen(cstr)
        var args = [_]llvm.ValueRef{cstr};
        return self.builder.buildCall(strlen_fn_type, strlen_fn, &args, "cstr.len");
    }

    /// Emit String.to_cstr() -> CStrOwned
    /// Allocates a new null-terminated copy of the String data.
    fn emitStringDataToCstrOwned(self: *Emitter, str_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const string_type = self.getStringStructType();
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Get the ptr field (source data)
        const src_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 0, "to_cstr.src_ptr_ptr");
        const src_ptr = self.builder.buildLoad(ptr_type, src_ptr_ptr, "to_cstr.src_ptr");

        // Get the len field
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_ptr, 1, "to_cstr.len_ptr");
        const len_i32 = self.builder.buildLoad(i32_type, len_ptr, "to_cstr.len");

        // Allocate memory: len + 1 for null terminator
        const one_i32 = llvm.Const.int32(self.ctx, 1);
        const alloc_len = llvm.c.LLVMBuildAdd(self.builder.ref, len_i32, one_i32, "to_cstr.alloc_len");
        const alloc_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, alloc_len, i64_type, "to_cstr.alloc_len_i64");

        // Call malloc
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_len_i64};
        const dest_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "to_cstr.ptr");

        // Call memcpy to copy the string data (without null terminator from String)
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, len_i32, i64_type, "to_cstr.len_i64");
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ dest_ptr, src_ptr, len_i64 };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "to_cstr.memcpy");

        // Add null terminator at the end
        const i8_type = llvm.Types.int8(self.ctx);
        var gep_indices = [_]llvm.ValueRef{len_i32};
        const null_offset = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, dest_ptr, &gep_indices, 1, "to_cstr.null_pos");
        _ = self.builder.buildStore(llvm.Const.int8(self.ctx, 0), null_offset);

        return dest_ptr;
    }

    /// Emit primitive string.to_cstr() -> CStrOwned
    /// Allocates a new null-terminated copy of the primitive string data.
    fn emitPrimitiveStringToCstrOwned(self: *Emitter, str_ptr: llvm.ValueRef, literal: ?ast.Literal) EmitError!llvm.ValueRef {
        // Get the string length
        const len: llvm.ValueRef = if (literal) |lit| blk: {
            // For string literals, we know the length at compile time
            const str_val = switch (lit.kind) {
                .string => |s| s,
                else => return EmitError.InvalidAST,
            };
            break :blk llvm.Const.int64(self.ctx, @intCast(str_val.len));
        } else blk: {
            // For string variables, call strlen
            const strlen_fn = self.getOrDeclareStrlen();
            var strlen_args = [_]llvm.ValueRef{str_ptr};
            break :blk self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &strlen_args, "to_cstr.strlen");
        };

        // Allocate memory: len + 1 for null terminator
        const one_i64 = llvm.Const.int64(self.ctx, 1);
        const alloc_len = llvm.c.LLVMBuildAdd(self.builder.ref, len, one_i64, "to_cstr.alloc_len");

        // Call malloc
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_len};
        const dest_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "to_cstr.ptr");

        // Call memcpy to copy the string data (including null terminator)
        // Note: We copy len+1 bytes which includes the null terminator from the source
        // (primitive strings are already null-terminated)
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ dest_ptr, str_ptr, alloc_len };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "to_cstr.memcpy");

        return dest_ptr;
    }

    /// Get the LLVM struct type for String: { ptr, i32, i32 }
    fn getStringStructType(self: *Emitter) llvm.TypeRef {
        var fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx), // ptr
            llvm.Types.int32(self.ctx), // len
            llvm.Types.int32(self.ctx), // capacity
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    // ==================== File I/O Emit Functions ====================

    /// Get the LLVM struct type for IoError: { tag: i32, payload: ptr }
    fn getIoErrorStructType(self: *Emitter) llvm.TypeRef {
        var fields = [_]llvm.TypeRef{
            llvm.Types.int32(self.ctx), // tag: 0=NotFound, 1=PermissionDenied, 2=AlreadyExists, 3=InvalidInput, 4=UnexpectedEof, 5=Other
            llvm.Types.pointer(self.ctx), // payload: string for Other variant
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get the LLVM struct type for Result[File, IoError]: { tag: i1, file: ptr, error: IoError }
    fn getFileResultType(self: *Emitter) llvm.TypeRef {
        const io_error_type = self.getIoErrorStructType();
        var fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag: 1=Ok, 0=Err
            llvm.Types.pointer(self.ctx), // File (FILE*)
            io_error_type, // IoError
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get the LLVM struct type for Result[i32, IoError]: { tag: i1, value: i32, error: IoError }
    fn getI32ResultType(self: *Emitter) llvm.TypeRef {
        const io_error_type = self.getIoErrorStructType();
        var fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag: 1=Ok, 0=Err
            llvm.Types.int32(self.ctx), // i32 value
            io_error_type, // IoError
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get the LLVM struct type for Result[void, IoError]: { tag: i1, placeholder: i8, error: IoError }
    /// Uses 3-field layout for consistency with other Result types (ok_value at index 1, err_value at index 2).
    fn getVoidResultType(self: *Emitter) llvm.TypeRef {
        const io_error_type = self.getIoErrorStructType();
        var fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag: 1=Ok, 0=Err
            llvm.Types.int8(self.ctx), // placeholder for void ok_value (maintains consistent field indices)
            io_error_type, // IoError at index 2, same as other Result types
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get the LLVM struct type for Result[String, IoError]: { tag: i1, string: { ptr, len, cap }, error: IoError }
    fn getStringResultType(self: *Emitter) llvm.TypeRef {
        const io_error_type = self.getIoErrorStructType();
        const string_type = self.getStringStructType();
        var fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag: 1=Ok, 0=Err
            string_type, // String { ptr, len, capacity }
            io_error_type, // IoError
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get the LLVM struct type for Result[List[u8], IoError]: { tag: i1, list: List, error: IoError }
    fn getListResultType(self: *Emitter) llvm.TypeRef {
        const io_error_type = self.getIoErrorStructType();
        const list_type = self.getListStructType();
        var fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag: 1=Ok, 0=Err
            list_type, // List { ptr, len, capacity }
            io_error_type, // IoError
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Emit File.open(path, mode) -> Result[File, IoError]
    fn emitFileOpen(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 2) return EmitError.InvalidAST;

        // Emit path and mode string arguments
        const path_val = try self.emitExpr(method.args[0]);
        const mode_val = try self.emitExpr(method.args[1]);

        // Call fopen
        const fopen_fn = self.getOrDeclareFopen();
        var fopen_args = [_]llvm.ValueRef{ path_val, mode_val };
        const file_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fopen_fn), fopen_fn, &fopen_args, "file.ptr");

        // Check if fopen returned null (error)
        const null_ptr = llvm.c.LLVMConstPointerNull(llvm.Types.pointer(self.ctx));
        const is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, file_ptr, null_ptr, "file.is_null");

        // Build the Result struct
        const result_type = self.getFileResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "file.result");

        // Get struct field pointers
        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "file.tag_ptr");
        const file_field_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "file.file_ptr");
        const err_field_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 2, "file.err_ptr");

        // Create Ok/Err paths
        const func = self.current_function orelse return EmitError.InvalidAST;
        const ok_bb = llvm.appendBasicBlock(self.ctx, func, "file.ok");
        const err_bb = llvm.appendBasicBlock(self.ctx, func, "file.err");
        const cont_bb = llvm.appendBasicBlock(self.ctx, func, "file.cont");

        _ = self.builder.buildCondBr(is_null, err_bb, ok_bb);

        // --- Ok path ---
        self.builder.positionAtEnd(ok_bb);
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr); // tag = 1 (Ok)
        _ = self.builder.buildStore(file_ptr, file_field_ptr);
        _ = self.builder.buildBr(cont_bb);

        // --- Err path ---
        self.builder.positionAtEnd(err_bb);
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr); // tag = 0 (Err)
        // Set IoError to NotFound (tag=0)
        const io_error_type = self.getIoErrorStructType();
        const err_tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, io_error_type, err_field_ptr, 0, "file.err_tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), err_tag_ptr); // NotFound
        _ = self.builder.buildBr(cont_bb);

        // --- Continue ---
        self.builder.positionAtEnd(cont_bb);
        return self.builder.buildLoad(result_type, result_alloca, "file.result_val");
    }

    /// Emit File.read_to_string(path) -> Result[String, IoError]
    /// Opens the file, reads entire content as a null-terminated string, closes file.
    fn emitFileReadToString(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) return EmitError.InvalidAST;

        const ptr_type = llvm.Types.pointer(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);

        // Emit path argument
        const path_val = try self.emitExpr(method.args[0]);

        // Get C runtime functions
        const fopen_fn = self.getOrDeclareFopen();
        const fseek_fn = self.getOrDeclareFseek();
        const ftell_fn = self.getOrDeclareFtell();
        const fread_fn = self.getOrDeclareFread();
        const fclose_fn = self.getOrDeclareFclose();
        const malloc_fn = self.getOrDeclareMalloc();

        // Open file for reading: fopen(path, "r")
        const mode_str = self.builder.buildGlobalStringPtr("r", "mode.r");
        var fopen_args = [_]llvm.ValueRef{ path_val, mode_str };
        const file_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fopen_fn), fopen_fn, &fopen_args, "readstr.file");

        // Build Result[String, IoError] struct
        const result_type = self.getStringResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "readstr.result");

        // Get struct field pointers
        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "readstr.tag_ptr");
        const str_field_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "readstr.str_ptr");
        const err_field_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 2, "readstr.err_ptr");

        // Check if fopen returned null
        const null_ptr = llvm.c.LLVMConstPointerNull(ptr_type);
        const is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, file_ptr, null_ptr, "readstr.is_null");

        // Create basic blocks
        const func = self.current_function orelse return EmitError.InvalidAST;
        const open_ok_bb = llvm.appendBasicBlock(self.ctx, func, "readstr.open_ok");
        const open_err_bb = llvm.appendBasicBlock(self.ctx, func, "readstr.open_err");
        const cont_bb = llvm.appendBasicBlock(self.ctx, func, "readstr.cont");

        _ = self.builder.buildCondBr(is_null, open_err_bb, open_ok_bb);

        // --- Open error path ---
        self.builder.positionAtEnd(open_err_bb);
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr); // tag = 0 (Err)
        const io_error_type = self.getIoErrorStructType();
        const err_tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, io_error_type, err_field_ptr, 0, "readstr.err_tag");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), err_tag_ptr); // NotFound
        _ = self.builder.buildBr(cont_bb);

        // --- Open OK path ---
        self.builder.positionAtEnd(open_ok_bb);

        // Seek to end: fseek(file, 0, SEEK_END=2)
        var fseek_args = [_]llvm.ValueRef{ file_ptr, llvm.Const.int64(self.ctx, 0), llvm.Const.int32(self.ctx, 2) };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fseek_fn), fseek_fn, &fseek_args, "readstr.seek_end");

        // Get file size: ftell(file)
        var ftell_args = [_]llvm.ValueRef{file_ptr};
        const file_size = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(ftell_fn), ftell_fn, &ftell_args, "readstr.size");

        // Seek back to start: fseek(file, 0, SEEK_SET=0)
        var fseek_args2 = [_]llvm.ValueRef{ file_ptr, llvm.Const.int64(self.ctx, 0), llvm.Const.int32(self.ctx, 0) };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fseek_fn), fseek_fn, &fseek_args2, "readstr.seek_start");

        // Allocate buffer: malloc(size + 1) for null terminator
        const size_plus_one = llvm.c.LLVMBuildAdd(self.builder.ref, file_size, llvm.Const.int64(self.ctx, 1), "readstr.size_plus_one");
        var malloc_args = [_]llvm.ValueRef{size_plus_one};
        const buffer = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "readstr.buffer");

        // Read file: fread(buffer, 1, size, file)
        var fread_args = [_]llvm.ValueRef{ buffer, llvm.Const.int64(self.ctx, 1), file_size, file_ptr };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fread_fn), fread_fn, &fread_args, "readstr.read");

        // Null-terminate the buffer
        var null_idx = [_]llvm.ValueRef{file_size};
        const null_pos = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, buffer, &null_idx, 1, "readstr.null_pos");
        _ = self.builder.buildStore(llvm.Const.int(i8_type, 0, false), null_pos);

        // Close file: fclose(file)
        var fclose_args = [_]llvm.ValueRef{file_ptr};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fclose_fn), fclose_fn, &fclose_args, "readstr.close");

        // Build String struct { ptr, len, capacity }
        const string_type = self.getStringStructType();
        const i32_type = llvm.Types.int32(self.ctx);

        // Store ptr (field 0)
        const str_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_field_ptr, 0, "readstr.str_ptr_field");
        _ = self.builder.buildStore(buffer, str_ptr_field);

        // Store len (field 1) - truncate i64 to i32
        const len_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, file_size, i32_type, "readstr.len_i32");
        const str_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_field_ptr, 1, "readstr.str_len_field");
        _ = self.builder.buildStore(len_i32, str_len_field);

        // Store capacity (field 2) - same as len
        const str_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_field_ptr, 2, "readstr.str_cap_field");
        _ = self.builder.buildStore(len_i32, str_cap_field);

        // Store Ok result
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr); // tag = 1 (Ok)

        _ = self.builder.buildBr(cont_bb);

        // --- Continue ---
        self.builder.positionAtEnd(cont_bb);
        return self.builder.buildLoad(result_type, result_alloca, "readstr.result_val");
    }

    /// Emit File.read_all(path) -> Result[List[u8], IoError]
    /// Opens the file, reads entire content as bytes, closes file.
    fn emitFileReadAll(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) return EmitError.InvalidAST;

        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Emit path argument
        const path_val = try self.emitExpr(method.args[0]);

        // Get C runtime functions
        const fopen_fn = self.getOrDeclareFopen();
        const fseek_fn = self.getOrDeclareFseek();
        const ftell_fn = self.getOrDeclareFtell();
        const fread_fn = self.getOrDeclareFread();
        const fclose_fn = self.getOrDeclareFclose();
        const malloc_fn = self.getOrDeclareMalloc();

        // Open file for reading: fopen(path, "rb") - binary mode for raw bytes
        const mode_str = self.builder.buildGlobalStringPtr("rb", "mode.rb");
        var fopen_args = [_]llvm.ValueRef{ path_val, mode_str };
        const file_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fopen_fn), fopen_fn, &fopen_args, "readall.file");

        // Build Result[List[u8], IoError] struct
        const list_type = self.getListStructType();
        const result_type = self.getListResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "readall.result");

        // Get struct field pointers
        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "readall.tag_ptr");
        const list_field_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "readall.list_ptr");
        const err_field_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 2, "readall.err_ptr");

        // Check if fopen returned null
        const null_ptr = llvm.c.LLVMConstPointerNull(ptr_type);
        const is_null = self.builder.buildICmp(llvm.c.LLVMIntEQ, file_ptr, null_ptr, "readall.is_null");

        // Create basic blocks
        const func = self.current_function orelse return EmitError.InvalidAST;
        const open_ok_bb = llvm.appendBasicBlock(self.ctx, func, "readall.open_ok");
        const open_err_bb = llvm.appendBasicBlock(self.ctx, func, "readall.open_err");
        const cont_bb = llvm.appendBasicBlock(self.ctx, func, "readall.cont");

        _ = self.builder.buildCondBr(is_null, open_err_bb, open_ok_bb);

        // --- Open error path ---
        self.builder.positionAtEnd(open_err_bb);
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr); // tag = 0 (Err)
        const io_error_type = self.getIoErrorStructType();
        const err_tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, io_error_type, err_field_ptr, 0, "readall.err_tag");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), err_tag_ptr); // NotFound
        _ = self.builder.buildBr(cont_bb);

        // --- Open OK path ---
        self.builder.positionAtEnd(open_ok_bb);

        // Seek to end: fseek(file, 0, SEEK_END=2)
        var fseek_args = [_]llvm.ValueRef{ file_ptr, llvm.Const.int64(self.ctx, 0), llvm.Const.int32(self.ctx, 2) };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fseek_fn), fseek_fn, &fseek_args, "readall.seek_end");

        // Get file size: ftell(file)
        var ftell_args = [_]llvm.ValueRef{file_ptr};
        const file_size = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(ftell_fn), ftell_fn, &ftell_args, "readall.size");

        // Seek back to start: fseek(file, 0, SEEK_SET=0)
        var fseek_args2 = [_]llvm.ValueRef{ file_ptr, llvm.Const.int64(self.ctx, 0), llvm.Const.int32(self.ctx, 0) };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fseek_fn), fseek_fn, &fseek_args2, "readall.seek_start");

        // Allocate buffer: malloc(size)
        var malloc_args = [_]llvm.ValueRef{file_size};
        const buffer = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "readall.buffer");

        // Read file: fread(buffer, 1, size, file)
        var fread_args = [_]llvm.ValueRef{ buffer, llvm.Const.int64(self.ctx, 1), file_size, file_ptr };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fread_fn), fread_fn, &fread_args, "readall.read");

        // Close file: fclose(file)
        var fclose_args = [_]llvm.ValueRef{file_ptr};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fclose_fn), fclose_fn, &fclose_args, "readall.close");

        // Build List[u8] struct { ptr, len, capacity }
        // Store ptr (field 0)
        const list_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_field_ptr, 0, "readall.list_ptr_field");
        _ = self.builder.buildStore(buffer, list_ptr_field);

        // Store len (field 1) - truncate i64 to i32
        const len_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, file_size, i32_type, "readall.len_i32");
        const list_len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_field_ptr, 1, "readall.list_len_field");
        _ = self.builder.buildStore(len_i32, list_len_field);

        // Store capacity (field 2) - same as len
        const list_cap_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, list_type, list_field_ptr, 2, "readall.list_cap_field");
        _ = self.builder.buildStore(len_i32, list_cap_field);

        // Store Ok result
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr); // tag = 1 (Ok)

        _ = self.builder.buildBr(cont_bb);

        // --- Continue ---
        self.builder.positionAtEnd(cont_bb);
        return self.builder.buildLoad(result_type, result_alloca, "readall.result_val");
    }

    /// Emit file.write_string(s) -> Result[i32, IoError]
    fn emitFileWriteString(self: *Emitter, file_ptr: llvm.ValueRef, str_val: llvm.ValueRef) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Load the FILE* from the File alloca
        const file_handle = self.builder.buildLoad(ptr_type, file_ptr, "file.handle");

        // Get string length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{str_val};
        const len = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &strlen_args, "str.len");

        // Call fwrite(str, 1, len, file)
        const fwrite_fn = self.getOrDeclareFwrite();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        var fwrite_args = [_]llvm.ValueRef{ str_val, one_i64, len, file_handle };
        const written = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &fwrite_args, "file.written");

        // Build Result[i32, IoError]
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "write.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "write.tag_ptr");
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "write.val_ptr");

        // Always return Ok for now (simplified - could check ferror)
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr); // tag = 1 (Ok)
        const written_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, written, i32_type, "write.written_i32");
        _ = self.builder.buildStore(written_i32, val_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "write.result_val");
    }

    /// Buffer info struct for extracting pointer and length from different buffer types
    const BufferInfo = struct {
        ptr: llvm.ValueRef,
        len: llvm.ValueRef,
    };

    /// Extract buffer pointer and length from either a slice reference or an array reference.
    /// - For slice references: load the slice struct and extract ptr/len fields
    /// - For array references: use the array pointer directly and compute length from type
    fn extractBufferPtrAndLen(self: *Emitter, buf_ref: llvm.ValueRef, buf_expr: ast.Expr) EmitError!BufferInfo {
        const i64_type = llvm.Types.int64(self.ctx);

        // Check if this is an array reference by looking at the operand of the ref expression
        // The expression should be `ref <identifier>` where identifier is a variable
        const maybe_array_size: ?usize = blk: {
            // buf_expr should be a unary ref expression
            if (buf_expr == .unary) {
                const un = buf_expr.unary;
                if (un.op == .ref or un.op == .ref_mut) {
                    // The operand should be an identifier
                    if (un.operand == .identifier) {
                        const id = un.operand.identifier;
                        // Look up the variable in our named_values to get its type info
                        if (self.named_values.get(id.name)) |local| {
                            // Check if this variable has array type stored
                            if (local.array_size) |size| {
                                break :blk size;
                            }
                        }
                    }
                }
            }
            break :blk null;
        };

        if (maybe_array_size) |array_size| {
            // Array reference: buf_ref is a pointer to [u8; N]

            // Get pointer to first element of the array using GEP
            const u8_type = llvm.Types.int8(self.ctx);
            const array_type = llvm.Types.array(u8_type, @intCast(array_size));
            const zero = llvm.Const.int32(self.ctx, 0);
            var indices = [_]llvm.ValueRef{ zero, zero };
            const buf_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, array_type, buf_ref, &indices, 2, "buf.ptr");
            const buf_len = llvm.Const.int(i64_type, array_size, false);

            return BufferInfo{ .ptr = buf_ptr, .len = buf_len };
        } else {
            // Slice reference: buf_ref is a pointer to {ptr: *u8, len: i64}
            var slice_fields = [_]llvm.TypeRef{
                llvm.Types.pointer(self.ctx), // data pointer
                i64_type, // length
            };
            const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);
            const buf_val = self.builder.buildLoad(slice_type, buf_ref, "buf.slice");
            const buf_ptr = llvm.c.LLVMBuildExtractValue(self.builder.ref, buf_val, 0, "buf.ptr");
            const buf_len = llvm.c.LLVMBuildExtractValue(self.builder.ref, buf_val, 1, "buf.len");

            return BufferInfo{ .ptr = buf_ptr, .len = buf_len };
        }
    }

    /// Emit file.write(buf) -> Result[i32, IoError]
    /// buf_expr is needed to determine if we have a slice or array reference
    fn emitFileWrite(self: *Emitter, file_ptr: llvm.ValueRef, buf_ref: llvm.ValueRef, buf_expr: ast.Expr) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Load the FILE* from the File alloca
        const file_handle = self.builder.buildLoad(ptr_type, file_ptr, "file.handle");

        // Extract buffer pointer and length based on type
        const buf_info = try self.extractBufferPtrAndLen(buf_ref, buf_expr);
        const buf_ptr = buf_info.ptr;
        const buf_len = buf_info.len;

        // Call fwrite(ptr, 1, len, file)
        const fwrite_fn = self.getOrDeclareFwrite();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        var fwrite_args = [_]llvm.ValueRef{ buf_ptr, one_i64, buf_len, file_handle };
        const written = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &fwrite_args, "file.written");

        // Build Result[i32, IoError]
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "write.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "write.tag_ptr");
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "write.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        const written_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, written, i32_type, "write.written_i32");
        _ = self.builder.buildStore(written_i32, val_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "write.result_val");
    }

    /// Emit file.read(buf) -> Result[i32, IoError]
    /// buf_expr is needed to determine if we have a slice or array reference
    fn emitFileRead(self: *Emitter, file_ptr: llvm.ValueRef, buf_ref: llvm.ValueRef, buf_expr: ast.Expr) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Load the FILE* from the File alloca
        const file_handle = self.builder.buildLoad(ptr_type, file_ptr, "file.handle");

        // Extract buffer pointer and length based on type
        const buf_info = try self.extractBufferPtrAndLen(buf_ref, buf_expr);
        const buf_ptr = buf_info.ptr;
        const buf_len = buf_info.len;

        // Call fread(ptr, 1, len, file)
        const fread_fn = self.getOrDeclareFread();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        var fread_args = [_]llvm.ValueRef{ buf_ptr, one_i64, buf_len, file_handle };
        const bytes_read = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fread_fn), fread_fn, &fread_args, "file.read");

        // Build Result[i32, IoError]
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "read.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "read.tag_ptr");
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "read.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        const read_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, bytes_read, i32_type, "read.bytes_i32");
        _ = self.builder.buildStore(read_i32, val_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "read.result_val");
    }

    /// Emit file.close() -> Result[void, IoError]
    fn emitFileClose(self: *Emitter, file_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load the FILE* from the File alloca
        const file_handle = self.builder.buildLoad(ptr_type, file_ptr, "file.handle");

        // Call fclose
        const fclose_fn = self.getOrDeclareFclose();
        var fclose_args = [_]llvm.ValueRef{file_handle};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fclose_fn), fclose_fn, &fclose_args, "");

        // Build Result[void, IoError] - always Ok
        const result_type = self.getVoidResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "close.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "close.tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "close.result_val");
    }

    /// Emit file.flush() -> Result[void, IoError]
    fn emitFileFlush(self: *Emitter, file_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);

        // Load the FILE* from the File alloca
        const file_handle = self.builder.buildLoad(ptr_type, file_ptr, "file.handle");

        // Call fflush
        const fflush_fn = self.getOrDeclareFflush();
        var fflush_args = [_]llvm.ValueRef{file_handle};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fflush_fn), fflush_fn, &fflush_args, "");

        // Build Result[void, IoError] - always Ok
        const result_type = self.getVoidResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "flush.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "flush.tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "flush.result_val");
    }

    /// Emit stdout().write_string(s) -> Result[i32, IoError]
    fn emitStdoutWriteString(self: *Emitter, str_val: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Get stdout handle
        const stdout_fn = self.getOrDeclareStdout();
        const stdout_handle = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stdout_fn), stdout_fn, &[_]llvm.ValueRef{}, "stdout.handle");

        // Get string length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{str_val};
        const len = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &strlen_args, "str.len");

        // Call fwrite(str, 1, len, stdout)
        const fwrite_fn = self.getOrDeclareFwrite();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        var fwrite_args = [_]llvm.ValueRef{ str_val, one_i64, len, stdout_handle };
        const written = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &fwrite_args, "stdout.written");

        // Build Result[i32, IoError]
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "stdout.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "stdout.tag_ptr");
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "stdout.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        const written_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, written, i32_type, "stdout.written_i32");
        _ = self.builder.buildStore(written_i32, val_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "stdout.result_val");
    }

    /// Emit stdout().flush() -> Result[void, IoError]
    fn emitStdoutFlush(self: *Emitter) EmitError!llvm.ValueRef {
        // Get stdout handle
        const stdout_fn = self.getOrDeclareStdout();
        const stdout_handle = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stdout_fn), stdout_fn, &[_]llvm.ValueRef{}, "stdout.handle");

        // Call fflush
        const fflush_fn = self.getOrDeclareFflush();
        var fflush_args = [_]llvm.ValueRef{stdout_handle};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fflush_fn), fflush_fn, &fflush_args, "");

        // Build Result[void, IoError]
        const result_type = self.getVoidResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "stdout.flush.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "stdout.flush.tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "stdout.flush.result_val");
    }

    /// Emit stdout().write(buf) -> Result[i32, IoError]
    fn emitStdoutWrite(self: *Emitter, buf_ref: llvm.ValueRef, buf_expr: ast.Expr) EmitError!llvm.ValueRef {
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Get stdout handle
        const stdout_fn = self.getOrDeclareStdout();
        const stdout_handle = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stdout_fn), stdout_fn, &[_]llvm.ValueRef{}, "stdout.handle");

        // Extract buffer pointer and length based on type
        const buf_info = try self.extractBufferPtrAndLen(buf_ref, buf_expr);
        const buf_ptr = buf_info.ptr;
        const buf_len = buf_info.len;

        // Call fwrite(ptr, 1, len, stdout)
        const fwrite_fn = self.getOrDeclareFwrite();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        var fwrite_args = [_]llvm.ValueRef{ buf_ptr, one_i64, buf_len, stdout_handle };
        const written = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &fwrite_args, "stdout.written");

        // Build Result[i32, IoError]
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "stdout.write.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "stdout.write.tag_ptr");
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "stdout.write.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        const written_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, written, i32_type, "stdout.written_i32");
        _ = self.builder.buildStore(written_i32, val_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "stdout.write.result_val");
    }

    /// Emit stderr().write_string(s) -> Result[i32, IoError]
    fn emitStderrWriteString(self: *Emitter, str_val: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Get stderr handle
        const stderr_fn = self.getOrDeclareStderr();
        const stderr_handle = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stderr_fn), stderr_fn, &[_]llvm.ValueRef{}, "stderr.handle");

        // Get string length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{str_val};
        const len = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &strlen_args, "str.len");

        // Call fwrite(str, 1, len, stderr)
        const fwrite_fn = self.getOrDeclareFwrite();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        var fwrite_args = [_]llvm.ValueRef{ str_val, one_i64, len, stderr_handle };
        const written = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &fwrite_args, "stderr.written");

        // Build Result[i32, IoError]
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "stderr.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "stderr.tag_ptr");
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "stderr.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        const written_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, written, i32_type, "stderr.written_i32");
        _ = self.builder.buildStore(written_i32, val_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "stderr.result_val");
    }

    /// Emit stderr().flush() -> Result[void, IoError]
    fn emitStderrFlush(self: *Emitter) EmitError!llvm.ValueRef {
        // Get stderr handle
        const stderr_fn = self.getOrDeclareStderr();
        const stderr_handle = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stderr_fn), stderr_fn, &[_]llvm.ValueRef{}, "stderr.handle");

        // Call fflush
        const fflush_fn = self.getOrDeclareFflush();
        var fflush_args = [_]llvm.ValueRef{stderr_handle};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fflush_fn), fflush_fn, &fflush_args, "");

        // Build Result[void, IoError]
        const result_type = self.getVoidResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "stderr.flush.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "stderr.flush.tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "stderr.flush.result_val");
    }

    /// Emit stderr().write(buf) -> Result[i32, IoError]
    fn emitStderrWrite(self: *Emitter, buf_ref: llvm.ValueRef, buf_expr: ast.Expr) EmitError!llvm.ValueRef {
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Get stderr handle
        const stderr_fn = self.getOrDeclareStderr();
        const stderr_handle = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stderr_fn), stderr_fn, &[_]llvm.ValueRef{}, "stderr.handle");

        // Extract buffer pointer and length based on type
        const buf_info = try self.extractBufferPtrAndLen(buf_ref, buf_expr);
        const buf_ptr = buf_info.ptr;
        const buf_len = buf_info.len;

        // Call fwrite(ptr, 1, len, stderr)
        const fwrite_fn = self.getOrDeclareFwrite();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        var fwrite_args = [_]llvm.ValueRef{ buf_ptr, one_i64, buf_len, stderr_handle };
        const written = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &fwrite_args, "stderr.written");

        // Build Result[i32, IoError]
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "stderr.write.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "stderr.write.tag_ptr");
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "stderr.write.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        const written_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, written, i32_type, "stderr.written_i32");
        _ = self.builder.buildStore(written_i32, val_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "stderr.write.result_val");
    }

    /// Emit stdin().read(buf) -> Result[i32, IoError]
    fn emitStdinRead(self: *Emitter, buf_ref: llvm.ValueRef, buf_expr: ast.Expr) EmitError!llvm.ValueRef {
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Get stdin handle
        const stdin_fn = self.getOrDeclareStdin();
        const stdin_handle = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(stdin_fn), stdin_fn, &[_]llvm.ValueRef{}, "stdin.handle");

        // Extract buffer pointer and length based on type
        const buf_info = try self.extractBufferPtrAndLen(buf_ref, buf_expr);
        const buf_ptr = buf_info.ptr;
        const buf_len = buf_info.len;

        // Call fread(ptr, 1, len, stdin)
        const fread_fn = self.getOrDeclareFread();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        var fread_args = [_]llvm.ValueRef{ buf_ptr, one_i64, buf_len, stdin_handle };
        const bytes_read = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fread_fn), fread_fn, &fread_args, "stdin.read");

        // Build Result[i32, IoError]
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "stdin.read.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "stdin.read.tag_ptr");
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "stdin.read.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        const read_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, bytes_read, i32_type, "stdin.read_i32");
        _ = self.builder.buildStore(read_i32, val_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "stdin.read.result_val");
    }

    // ========================================================================
    // BufReader Methods
    // ========================================================================

    /// Buffer size for buffered I/O (8KB)
    const BUF_SIZE: u32 = 8192;

    /// Get the LLVM struct type for BufReader: { inner: FILE*, buffer: [8192]u8, pos: i32, cap: i32 }
    fn getBufReaderStructType(self: *Emitter) llvm.TypeRef {
        var fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx), // inner (FILE*)
            llvm.Types.array(llvm.Types.int8(self.ctx), BUF_SIZE), // buffer
            llvm.Types.int32(self.ctx), // pos
            llvm.Types.int32(self.ctx), // cap
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get the LLVM struct type for BufWriter: { inner: FILE*, buffer: [8192]u8, len: i32 }
    fn getBufWriterStructType(self: *Emitter) llvm.TypeRef {
        var fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx), // inner (FILE*)
            llvm.Types.array(llvm.Types.int8(self.ctx), BUF_SIZE), // buffer
            llvm.Types.int32(self.ctx), // len
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Emit BufReader.new[R](reader) -> BufReader[R]
    fn emitBufReaderNew(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) return EmitError.InvalidAST;

        const br_type = self.getBufReaderStructType();

        // Emit the inner reader (e.g., a File)
        // emitExpr returns the FILE* value (already loaded from alloca)
        const file_handle = try self.emitExpr(method.args[0]);

        // Allocate BufReader struct
        const br_alloca = self.builder.buildAlloca(br_type, "bufreader");

        // Initialize fields: inner = file_handle, pos = 0, cap = 0
        const inner_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_alloca, 0, "br.inner_ptr");
        _ = self.builder.buildStore(file_handle, inner_ptr);

        const pos_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_alloca, 2, "br.pos_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), pos_ptr);

        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_alloca, 3, "br.cap_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), cap_ptr);

        // Return the struct value
        return self.builder.buildLoad(br_type, br_alloca, "bufreader.val");
    }

    /// Emit bufreader.read(buf) -> Result[i32, IoError]
    /// Reads from buffer first, then refills from underlying reader if needed.
    fn emitBufReaderRead(self: *Emitter, br_ptr: llvm.ValueRef, buf_ref: llvm.ValueRef, buf_expr: ast.Expr) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const br_type = self.getBufReaderStructType();

        // Get pointers to BufReader fields
        const inner_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 0, "br.inner_ptr");
        const buf_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 1, "br.buf_ptr");
        const pos_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 2, "br.pos_ptr");
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 3, "br.cap_ptr");

        // Load current values
        const file_handle = self.builder.buildLoad(ptr_type, inner_ptr, "br.file");
        const pos = self.builder.buildLoad(i32_type, pos_ptr, "br.pos");
        const cap = self.builder.buildLoad(i32_type, cap_ptr, "br.cap");

        // Extract destination buffer pointer and length
        const dest_info = try self.extractBufferPtrAndLen(buf_ref, buf_expr);
        const dest_ptr = dest_info.ptr;
        const dest_len = dest_info.len;
        const dest_len_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, dest_len, i32_type, "dest_len_i32");

        // Calculate available bytes in buffer: available = cap - pos
        const available = llvm.c.LLVMBuildSub(self.builder.ref, cap, pos, "br.available");

        // Create basic blocks for control flow
        const func = self.current_function orelse return EmitError.InvalidAST;
        const have_data_bb = llvm.appendBasicBlock(self.ctx, func, "br.have_data");
        const need_refill_bb = llvm.appendBasicBlock(self.ctx, func, "br.need_refill");
        const copy_bb = llvm.appendBasicBlock(self.ctx, func, "br.copy");
        const done_bb = llvm.appendBasicBlock(self.ctx, func, "br.done");

        // Check if we have data in buffer
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        const has_data = self.builder.buildICmp(llvm.c.LLVMIntSGT, available, zero_i32, "br.has_data");
        _ = self.builder.buildCondBr(has_data, have_data_bb, need_refill_bb);

        // --- Have data: calculate how much to copy ---
        self.builder.positionAtEnd(have_data_bb);
        // to_copy = min(available, dest_len)
        const cmp_avail = self.builder.buildICmp(llvm.c.LLVMIntSLT, available, dest_len_i32, "br.cmp_avail");
        const to_copy_have = llvm.c.LLVMBuildSelect(self.builder.ref, cmp_avail, available, dest_len_i32, "br.to_copy_have");
        _ = self.builder.buildBr(copy_bb);

        // --- Need refill: read from underlying file ---
        self.builder.positionAtEnd(need_refill_bb);
        // Reset pos = 0
        _ = self.builder.buildStore(zero_i32, pos_ptr);

        // Read into buffer: fread(buffer, 1, BUF_SIZE, file)
        const fread_fn = self.getOrDeclareFread();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        const buf_size_i64 = llvm.Const.int(i64_type, BUF_SIZE, false);
        var fread_args = [_]llvm.ValueRef{ buf_ptr_field, one_i64, buf_size_i64, file_handle };
        const bytes_read = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fread_fn), fread_fn, &fread_args, "br.bytes_read");
        const new_cap = llvm.c.LLVMBuildTrunc(self.builder.ref, bytes_read, i32_type, "br.new_cap");
        _ = self.builder.buildStore(new_cap, cap_ptr);

        // to_copy = min(new_cap, dest_len)
        const cmp_new = self.builder.buildICmp(llvm.c.LLVMIntSLT, new_cap, dest_len_i32, "br.cmp_new");
        const to_copy_refill = llvm.c.LLVMBuildSelect(self.builder.ref, cmp_new, new_cap, dest_len_i32, "br.to_copy_refill");
        _ = self.builder.buildBr(copy_bb);

        // --- Copy data to destination ---
        self.builder.positionAtEnd(copy_bb);
        // PHI for to_copy
        const to_copy_phi = llvm.c.LLVMBuildPhi(self.builder.ref, i32_type, "br.to_copy");
        var phi_vals = [_]llvm.ValueRef{ to_copy_have, to_copy_refill };
        var phi_bbs = [_]llvm.BasicBlockRef{ have_data_bb, need_refill_bb };
        llvm.c.LLVMAddIncoming(to_copy_phi, &phi_vals, &phi_bbs, 2);

        // Get current pos (might be 0 after refill or original pos)
        const cur_pos = self.builder.buildLoad(i32_type, pos_ptr, "br.cur_pos");
        const cur_pos_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, cur_pos, i64_type, "br.cur_pos_i64");

        // src_ptr = buffer + pos
        const buf_base = buf_ptr_field;
        var indices = [_]llvm.ValueRef{ zero_i32, llvm.c.LLVMBuildTrunc(self.builder.ref, cur_pos_i64, i32_type, "pos_idx") };
        const src_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, llvm.Types.array(llvm.Types.int8(self.ctx), BUF_SIZE), buf_base, &indices, 2, "br.src_ptr");

        // Call memcpy(dest, src, to_copy)
        const memcpy_fn = self.getOrDeclareMemcpy();
        const to_copy_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, to_copy_phi, i64_type, "br.to_copy_i64");
        var memcpy_args = [_]llvm.ValueRef{ dest_ptr, src_ptr, to_copy_i64 };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Update pos = pos + to_copy
        const new_pos = llvm.c.LLVMBuildAdd(self.builder.ref, cur_pos, to_copy_phi, "br.new_pos");
        _ = self.builder.buildStore(new_pos, pos_ptr);
        _ = self.builder.buildBr(done_bb);

        // --- Done: return Result[i32, IoError] ---
        self.builder.positionAtEnd(done_bb);
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "br.read.result");

        const tag_ptr_res = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "br.read.tag_ptr");
        const val_ptr_res = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "br.read.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr_res);
        _ = self.builder.buildStore(to_copy_phi, val_ptr_res);

        return self.builder.buildLoad(result_type, result_alloca, "br.read.result_val");
    }

    /// Emit bufreader.read_line() -> Result[String, IoError]
    /// Reads until newline or EOF, returning the line including the newline character.
    fn emitBufReaderReadLine(self: *Emitter, br_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        const ptr_type = llvm.Types.pointer(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const br_type = self.getBufReaderStructType();
        const string_type = self.getStringStructType();
        const result_type = self.getStringResultType();

        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        const newline_char = llvm.Const.int32(self.ctx, 10); // '\n'
        const initial_cap: i32 = 128;

        // Get BufReader field pointers
        const inner_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 0, "rl.inner_ptr");
        const buf_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 1, "rl.buf_ptr");
        const pos_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 2, "rl.pos_ptr");
        const cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 3, "rl.cap_ptr");

        // Allocate result String on stack: { ptr, len, cap }
        const str_alloca = self.builder.buildAlloca(string_type, "rl.str");

        // Initialize String with initial capacity
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{llvm.Const.int64(self.ctx, initial_cap)};
        const str_data = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(malloc_fn), malloc_fn, &malloc_args, "rl.str_data");

        const str_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_alloca, 0, "rl.str_ptr_ptr");
        const str_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_alloca, 1, "rl.str_len_ptr");
        const str_cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_alloca, 2, "rl.str_cap_ptr");

        _ = self.builder.buildStore(str_data, str_ptr_ptr);
        _ = self.builder.buildStore(zero_i32, str_len_ptr);
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, initial_cap), str_cap_ptr);

        // Store null terminator at start
        _ = self.builder.buildStore(llvm.Const.int(i8_type, 0, false), str_data);

        // Create basic blocks
        const loop_bb = llvm.appendBasicBlock(self.ctx, func, "rl.loop");
        const refill_bb = llvm.appendBasicBlock(self.ctx, func, "rl.refill");
        const scan_bb = llvm.appendBasicBlock(self.ctx, func, "rl.scan");
        const found_bb = llvm.appendBasicBlock(self.ctx, func, "rl.found");
        const not_found_bb = llvm.appendBasicBlock(self.ctx, func, "rl.not_found");
        const eof_bb = llvm.appendBasicBlock(self.ctx, func, "rl.eof");
        const done_bb = llvm.appendBasicBlock(self.ctx, func, "rl.done");

        _ = self.builder.buildBr(loop_bb);

        // --- Loop entry: check if buffer has data ---
        self.builder.positionAtEnd(loop_bb);
        const pos = self.builder.buildLoad(i32_type, pos_ptr, "rl.pos");
        const cap = self.builder.buildLoad(i32_type, cap_ptr, "rl.cap");
        const available = llvm.c.LLVMBuildSub(self.builder.ref, cap, pos, "rl.available");
        const has_data = self.builder.buildICmp(llvm.c.LLVMIntSGT, available, zero_i32, "rl.has_data");
        _ = self.builder.buildCondBr(has_data, scan_bb, refill_bb);

        // --- Refill buffer ---
        self.builder.positionAtEnd(refill_bb);
        _ = self.builder.buildStore(zero_i32, pos_ptr);
        const file_handle = self.builder.buildLoad(ptr_type, inner_ptr, "rl.file");
        const fread_fn = self.getOrDeclareFread();
        const one_i64 = llvm.Const.int64(self.ctx, 1);
        const buf_size_i64 = llvm.Const.int64(self.ctx, BUF_SIZE);
        var fread_args = [_]llvm.ValueRef{ buf_ptr_field, one_i64, buf_size_i64, file_handle };
        const bytes_read = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fread_fn), fread_fn, &fread_args, "rl.bytes_read");
        const new_cap = llvm.c.LLVMBuildTrunc(self.builder.ref, bytes_read, i32_type, "rl.new_cap");
        _ = self.builder.buildStore(new_cap, cap_ptr);

        // Check if EOF (bytes_read == 0)
        const is_eof = self.builder.buildICmp(llvm.c.LLVMIntEQ, new_cap, zero_i32, "rl.is_eof");
        _ = self.builder.buildCondBr(is_eof, eof_bb, scan_bb);

        // --- Scan for newline ---
        self.builder.positionAtEnd(scan_bb);
        // Get current pos (may have changed after refill)
        const cur_pos = self.builder.buildLoad(i32_type, pos_ptr, "rl.cur_pos");
        const cur_cap = self.builder.buildLoad(i32_type, cap_ptr, "rl.cur_cap");
        const scan_len = llvm.c.LLVMBuildSub(self.builder.ref, cur_cap, cur_pos, "rl.scan_len");

        // Get pointer to buffer[pos]
        var buf_indices = [_]llvm.ValueRef{ zero_i32, cur_pos };
        const scan_start = llvm.c.LLVMBuildGEP2(self.builder.ref, llvm.Types.array(i8_type, BUF_SIZE), buf_ptr_field, &buf_indices, 2, "rl.scan_start");

        // Call memchr(scan_start, '\n', scan_len)
        const memchr_fn = self.getOrDeclareMemchr();
        const scan_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, scan_len, i64_type, "rl.scan_len_i64");
        var memchr_args = [_]llvm.ValueRef{ scan_start, newline_char, scan_len_i64 };
        const nl_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memchr_fn), memchr_fn, &memchr_args, "rl.nl_ptr");

        // Check if found
        const null_ptr_const = llvm.c.LLVMConstNull(ptr_type);
        const found_nl = self.builder.buildICmp(llvm.c.LLVMIntNE, nl_ptr, null_ptr_const, "rl.found_nl");
        _ = self.builder.buildCondBr(found_nl, found_bb, not_found_bb);

        // --- Found newline: copy up to and including newline, then done ---
        self.builder.positionAtEnd(found_bb);
        // Calculate bytes to copy: (nl_ptr - scan_start) + 1 (include newline)
        const scan_start_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, scan_start, i64_type, "rl.scan_int");
        const nl_ptr_int = llvm.c.LLVMBuildPtrToInt(self.builder.ref, nl_ptr, i64_type, "rl.nl_int");
        const offset_found = llvm.c.LLVMBuildSub(self.builder.ref, nl_ptr_int, scan_start_int, "rl.offset_f");
        const copy_len_found = llvm.c.LLVMBuildAdd(self.builder.ref, offset_found, llvm.Const.int64(self.ctx, 1), "rl.copy_f");
        const copy_len_found_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, copy_len_found, i32_type, "rl.copy_f_i32");

        // Grow string if needed and copy
        try self.emitReadLineAppend(str_alloca, scan_start, copy_len_found_i32);

        // Update BufReader pos = cur_pos + copy_len
        const cur_pos_found = self.builder.buildLoad(i32_type, pos_ptr, "rl.cur_pos_f");
        const new_br_pos = llvm.c.LLVMBuildAdd(self.builder.ref, cur_pos_found, copy_len_found_i32, "rl.new_br_pos");
        _ = self.builder.buildStore(new_br_pos, pos_ptr);

        _ = self.builder.buildBr(done_bb);

        // --- Not found: copy all remaining bytes and continue loop ---
        self.builder.positionAtEnd(not_found_bb);

        // Grow string if needed and copy all scan_len bytes
        try self.emitReadLineAppend(str_alloca, scan_start, scan_len);

        // Mark buffer as consumed: pos = cap
        const cap_nf = self.builder.buildLoad(i32_type, cap_ptr, "rl.cap_nf");
        _ = self.builder.buildStore(cap_nf, pos_ptr);

        // Continue loop (will refill buffer)
        _ = self.builder.buildBr(loop_bb);

        // --- EOF: return what we have ---
        self.builder.positionAtEnd(eof_bb);
        // String is already null-terminated from initialization or previous appends
        _ = self.builder.buildBr(done_bb);

        // --- Done: build Result[String, IoError] ---
        self.builder.positionAtEnd(done_bb);
        const result_alloca = self.builder.buildAlloca(result_type, "rl.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "rl.tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

        const result_str_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "rl.result_str_ptr");
        const final_str = self.builder.buildLoad(string_type, str_alloca, "rl.final_str");
        _ = self.builder.buildStore(final_str, result_str_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "rl.result_val");
    }

    /// Helper for read_line: append bytes to the String, growing if needed.
    /// str_alloca: pointer to String struct on stack
    /// src: pointer to source bytes
    /// len: number of bytes to copy (i32)
    fn emitReadLineAppend(self: *Emitter, str_alloca: llvm.ValueRef, src: llvm.ValueRef, len: llvm.ValueRef) EmitError!void {
        const func = self.current_function orelse return EmitError.InvalidAST;

        const ptr_type = llvm.Types.pointer(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const string_type = self.getStringStructType();

        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        const one_i32 = llvm.Const.int32(self.ctx, 1);

        // Load current string state
        const str_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_alloca, 0, "rla.ptr_ptr");
        const str_len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_alloca, 1, "rla.len_ptr");
        const str_cap_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, string_type, str_alloca, 2, "rla.cap_ptr");

        const current_ptr = self.builder.buildLoad(ptr_type, str_ptr_ptr, "rla.cur_ptr");
        const current_len = self.builder.buildLoad(i32_type, str_len_ptr, "rla.cur_len");
        const current_cap = self.builder.buildLoad(i32_type, str_cap_ptr, "rla.cur_cap");

        // Check if len is 0 (early exit)
        const len_is_zero = self.builder.buildICmp(llvm.c.LLVMIntEQ, len, zero_i32, "rla.len_zero");
        const do_copy_bb = llvm.appendBasicBlock(self.ctx, func, "rla.do_copy");
        const end_bb = llvm.appendBasicBlock(self.ctx, func, "rla.end");
        _ = self.builder.buildCondBr(len_is_zero, end_bb, do_copy_bb);

        self.builder.positionAtEnd(do_copy_bb);

        // new_len = current_len + len
        const new_len = llvm.c.LLVMBuildAdd(self.builder.ref, current_len, len, "rla.new_len");
        // need_space = new_len + 1 (for null terminator)
        const need_space = llvm.c.LLVMBuildAdd(self.builder.ref, new_len, one_i32, "rla.need_space");

        // Check if we need to grow
        const need_grow = self.builder.buildICmp(llvm.c.LLVMIntSGT, need_space, current_cap, "rla.need_grow");

        const grow_bb = llvm.appendBasicBlock(self.ctx, func, "rla.grow");
        const copy_bb = llvm.appendBasicBlock(self.ctx, func, "rla.copy");

        _ = self.builder.buildCondBr(need_grow, grow_bb, copy_bb);

        // --- Grow block ---
        self.builder.positionAtEnd(grow_bb);
        // new_cap = max(need_space * 2, 16)
        const doubled = llvm.c.LLVMBuildMul(self.builder.ref, need_space, llvm.Const.int32(self.ctx, 2), "rla.doubled");
        const sixteen = llvm.Const.int32(self.ctx, 16);
        const cmp = self.builder.buildICmp(llvm.c.LLVMIntSGT, doubled, sixteen, "rla.cmp");
        const new_cap = llvm.c.LLVMBuildSelect(self.builder.ref, cmp, doubled, sixteen, "rla.new_cap");

        // realloc
        const new_cap_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_cap, i64_type, "rla.new_cap_i64");
        const realloc_fn = self.getOrDeclareRealloc();
        var realloc_args = [_]llvm.ValueRef{ current_ptr, new_cap_i64 };
        const grown_ptr = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(realloc_fn), realloc_fn, &realloc_args, "rla.grown_ptr");

        // Store new ptr and cap
        _ = self.builder.buildStore(grown_ptr, str_ptr_ptr);
        _ = self.builder.buildStore(new_cap, str_cap_ptr);

        _ = self.builder.buildBr(copy_bb);

        // --- Copy block ---
        self.builder.positionAtEnd(copy_bb);
        // PHI for data pointer
        const data_phi = llvm.c.LLVMBuildPhi(self.builder.ref, ptr_type, "rla.data_ptr");
        var incoming_values = [_]llvm.ValueRef{ current_ptr, grown_ptr };
        var incoming_blocks = [_]llvm.BasicBlockRef{ do_copy_bb, grow_bb };
        llvm.c.LLVMAddIncoming(data_phi, &incoming_values, &incoming_blocks, 2);

        // memcpy(data_ptr + current_len, src, len)
        const current_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_len, i64_type, "rla.cur_len_i64");
        var dest_indices = [_]llvm.ValueRef{current_len_i64};
        const dest_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, data_phi, &dest_indices, 1, "rla.dest");

        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, len, i64_type, "rla.len_i64");
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ dest_ptr, src, len_i64 };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Store null terminator at data_ptr + new_len
        const new_len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, new_len, i64_type, "rla.new_len_i64");
        var null_indices = [_]llvm.ValueRef{new_len_i64};
        const null_addr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, data_phi, &null_indices, 1, "rla.null_addr");
        _ = self.builder.buildStore(llvm.Const.int(i8_type, 0, false), null_addr);

        // Update len
        _ = self.builder.buildStore(new_len, str_len_ptr);

        _ = self.builder.buildBr(end_bb);

        // --- End block ---
        self.builder.positionAtEnd(end_bb);
    }

    /// Emit bufreader.read_to_string() -> Result[String, IoError]
    fn emitBufReaderReadToString(self: *Emitter, br_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        // Reuse read_line for now - would need full implementation
        return self.emitBufReaderReadLine(br_ptr);
    }

    /// Emit bufreader.fill_buf() -> Result[[u8], IoError]
    fn emitBufReaderFillBuf(self: *Emitter, br_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        _ = br_ptr;
        // Return empty slice for now
        const slice_type = self.getSliceStructType();
        const result_type = self.getSliceResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "br.fillbuf.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "br.fillbuf.tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

        // Empty slice { null, 0 }
        const slice_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "br.fillbuf.slice_ptr");
        const null_ptr = llvm.c.LLVMConstNull(llvm.Types.pointer(self.ctx));
        var slice_vals = [_]llvm.ValueRef{ null_ptr, llvm.Const.int64(self.ctx, 0) };
        const empty_slice = llvm.c.LLVMConstNamedStruct(slice_type, &slice_vals, 2);
        _ = self.builder.buildStore(empty_slice, slice_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "br.fillbuf.result_val");
    }

    /// Emit bufreader.consume(n)
    fn emitBufReaderConsume(self: *Emitter, br_ptr: llvm.ValueRef, n: llvm.ValueRef) EmitError!llvm.ValueRef {
        const i32_type = llvm.Types.int32(self.ctx);
        const br_type = self.getBufReaderStructType();

        const pos_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 2, "br.pos_ptr");
        const pos = self.builder.buildLoad(i32_type, pos_ptr, "br.pos");
        const new_pos = llvm.c.LLVMBuildAdd(self.builder.ref, pos, n, "br.new_pos");
        _ = self.builder.buildStore(new_pos, pos_ptr);

        // Return void
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit bufreader.into_inner() -> R
    fn emitBufReaderIntoInner(self: *Emitter, br_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const br_type = self.getBufReaderStructType();

        const inner_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, br_type, br_ptr, 0, "br.inner_ptr");
        return self.builder.buildLoad(ptr_type, inner_ptr, "br.inner");
    }

    // ========================================================================
    // BufWriter Methods
    // ========================================================================

    /// Emit BufWriter.new[W](writer) -> BufWriter[W]
    fn emitBufWriterNew(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) return EmitError.InvalidAST;

        const bw_type = self.getBufWriterStructType();

        // Emit the inner writer (e.g., a File)
        // emitExpr returns the FILE* value (already loaded from alloca)
        const file_handle = try self.emitExpr(method.args[0]);

        // Allocate BufWriter struct
        const bw_alloca = self.builder.buildAlloca(bw_type, "bufwriter");

        // Initialize fields: inner = file_handle, len = 0
        const inner_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_alloca, 0, "bw.inner_ptr");
        _ = self.builder.buildStore(file_handle, inner_ptr);

        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_alloca, 2, "bw.len_ptr");
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_ptr);

        // Return the struct value
        return self.builder.buildLoad(bw_type, bw_alloca, "bufwriter.val");
    }

    /// Emit bufwriter.write(buf) -> Result[i32, IoError]
    fn emitBufWriterWrite(self: *Emitter, bw_ptr: llvm.ValueRef, buf_ref: llvm.ValueRef, buf_expr: ast.Expr) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const bw_type = self.getBufWriterStructType();

        // Get pointers to BufWriter fields
        const inner_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 0, "bw.inner_ptr");
        const buf_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 1, "bw.buf_ptr");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 2, "bw.len_ptr");

        // Load current values
        const file_handle = self.builder.buildLoad(ptr_type, inner_ptr, "bw.file");
        const current_len = self.builder.buildLoad(i32_type, len_ptr, "bw.len");

        // Extract source buffer pointer and length
        const src_info = try self.extractBufferPtrAndLen(buf_ref, buf_expr);
        const src_ptr = src_info.ptr;
        const src_len = src_info.len;
        const src_len_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, src_len, i32_type, "src_len_i32");

        // Calculate available space: available = BUF_SIZE - len
        const buf_size_i32 = llvm.Const.int32(self.ctx, BUF_SIZE);
        const available = llvm.c.LLVMBuildSub(self.builder.ref, buf_size_i32, current_len, "bw.available");

        // Create basic blocks for control flow
        const func = self.current_function orelse return EmitError.InvalidAST;
        const fits_bb = llvm.appendBasicBlock(self.ctx, func, "bw.fits");
        const flush_bb = llvm.appendBasicBlock(self.ctx, func, "bw.flush");
        const done_bb = llvm.appendBasicBlock(self.ctx, func, "bw.done");

        // Check if data fits in buffer
        const fits = self.builder.buildICmp(llvm.c.LLVMIntSGE, available, src_len_i32, "bw.fits");
        _ = self.builder.buildCondBr(fits, fits_bb, flush_bb);

        // --- Data fits: copy to buffer ---
        self.builder.positionAtEnd(fits_bb);
        // dst_ptr = buffer + len
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var indices = [_]llvm.ValueRef{ zero_i32, current_len };
        const dst_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, llvm.Types.array(llvm.Types.int8(self.ctx), BUF_SIZE), buf_ptr_field, &indices, 2, "bw.dst_ptr");

        // memcpy(dst, src, src_len)
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ dst_ptr, src_ptr, src_len };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        // Update len = len + src_len
        const new_len = llvm.c.LLVMBuildAdd(self.builder.ref, current_len, src_len_i32, "bw.new_len");
        _ = self.builder.buildStore(new_len, len_ptr);
        _ = self.builder.buildBr(done_bb);

        // --- Doesn't fit: flush and write directly ---
        self.builder.positionAtEnd(flush_bb);
        // First flush the buffer
        const fwrite_fn = self.getOrDeclareFwrite();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_len, i64_type, "bw.len_i64");
        var flush_args = [_]llvm.ValueRef{ buf_ptr_field, one_i64, len_i64, file_handle };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &flush_args, "bw.flush_write");

        // Reset buffer len = 0
        _ = self.builder.buildStore(zero_i32, len_ptr);

        // Write data directly to file
        var write_args = [_]llvm.ValueRef{ src_ptr, one_i64, src_len, file_handle };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &write_args, "bw.direct_write");
        _ = self.builder.buildBr(done_bb);

        // --- Done: return Result[i32, IoError] ---
        self.builder.positionAtEnd(done_bb);
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "bw.write.result");

        const tag_ptr_res = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "bw.write.tag_ptr");
        const val_ptr_res = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "bw.write.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr_res);
        _ = self.builder.buildStore(src_len_i32, val_ptr_res);

        return self.builder.buildLoad(result_type, result_alloca, "bw.write.result_val");
    }

    /// Emit bufwriter.write_string(s) -> Result[i32, IoError]
    fn emitBufWriterWriteString(self: *Emitter, bw_ptr: llvm.ValueRef, str_val: llvm.ValueRef) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const bw_type = self.getBufWriterStructType();

        // Get string length using strlen
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{str_val};
        const str_len = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(strlen_fn), strlen_fn, &strlen_args, "bw.str_len");
        const str_len_i32 = llvm.c.LLVMBuildTrunc(self.builder.ref, str_len, i32_type, "bw.str_len_i32");

        // Get pointers to BufWriter fields
        const inner_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 0, "bw.inner_ptr");
        const buf_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 1, "bw.buf_ptr");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 2, "bw.len_ptr");

        // Load current values
        const file_handle = self.builder.buildLoad(ptr_type, inner_ptr, "bw.file");
        const current_len = self.builder.buildLoad(i32_type, len_ptr, "bw.len");

        // Calculate available space
        const buf_size_i32 = llvm.Const.int32(self.ctx, BUF_SIZE);
        const available = llvm.c.LLVMBuildSub(self.builder.ref, buf_size_i32, current_len, "bw.available");

        // Create basic blocks
        const func = self.current_function orelse return EmitError.InvalidAST;
        const fits_bb = llvm.appendBasicBlock(self.ctx, func, "bw.str.fits");
        const flush_bb = llvm.appendBasicBlock(self.ctx, func, "bw.str.flush");
        const done_bb = llvm.appendBasicBlock(self.ctx, func, "bw.str.done");

        const fits = self.builder.buildICmp(llvm.c.LLVMIntSGE, available, str_len_i32, "bw.str.fits");
        _ = self.builder.buildCondBr(fits, fits_bb, flush_bb);

        // --- Fits: copy to buffer ---
        self.builder.positionAtEnd(fits_bb);
        const zero_i32 = llvm.Const.int32(self.ctx, 0);
        var indices = [_]llvm.ValueRef{ zero_i32, current_len };
        const dst_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, llvm.Types.array(llvm.Types.int8(self.ctx), BUF_SIZE), buf_ptr_field, &indices, 2, "bw.str.dst_ptr");

        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ dst_ptr, str_val, str_len };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(memcpy_fn), memcpy_fn, &memcpy_args, "");

        const new_len = llvm.c.LLVMBuildAdd(self.builder.ref, current_len, str_len_i32, "bw.str.new_len");
        _ = self.builder.buildStore(new_len, len_ptr);
        _ = self.builder.buildBr(done_bb);

        // --- Doesn't fit: flush and write ---
        self.builder.positionAtEnd(flush_bb);
        const fwrite_fn = self.getOrDeclareFwrite();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_len, i64_type, "bw.str.len_i64");
        var flush_args = [_]llvm.ValueRef{ buf_ptr_field, one_i64, len_i64, file_handle };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &flush_args, "");

        _ = self.builder.buildStore(zero_i32, len_ptr);

        var write_args = [_]llvm.ValueRef{ str_val, one_i64, str_len, file_handle };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &write_args, "");
        _ = self.builder.buildBr(done_bb);

        // --- Done ---
        self.builder.positionAtEnd(done_bb);
        const result_type = self.getI32ResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "bw.str.result");

        const tag_ptr_res = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "bw.str.tag_ptr");
        const val_ptr_res = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "bw.str.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr_res);
        _ = self.builder.buildStore(str_len_i32, val_ptr_res);

        return self.builder.buildLoad(result_type, result_alloca, "bw.str.result_val");
    }

    /// Emit bufwriter.flush() -> Result[void, IoError]
    fn emitBufWriterFlush(self: *Emitter, bw_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const bw_type = self.getBufWriterStructType();

        // Get pointers to BufWriter fields
        const inner_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 0, "bw.flush.inner_ptr");
        const buf_ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 1, "bw.flush.buf_ptr");
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 2, "bw.flush.len_ptr");

        // Load current values
        const file_handle = self.builder.buildLoad(ptr_type, inner_ptr, "bw.flush.file");
        const current_len = self.builder.buildLoad(i32_type, len_ptr, "bw.flush.len");

        // Write buffer to file: fwrite(buffer, 1, len, file)
        const fwrite_fn = self.getOrDeclareFwrite();
        const one_i64 = llvm.Const.int(i64_type, 1, false);
        const len_i64 = llvm.c.LLVMBuildSExt(self.builder.ref, current_len, i64_type, "bw.flush.len_i64");
        var fwrite_args = [_]llvm.ValueRef{ buf_ptr_field, one_i64, len_i64, file_handle };
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fwrite_fn), fwrite_fn, &fwrite_args, "bw.flush.write");

        // Reset len = 0
        _ = self.builder.buildStore(llvm.Const.int32(self.ctx, 0), len_ptr);

        // Call fflush on the underlying file
        const fflush_fn = self.getOrDeclareFflush();
        var fflush_args = [_]llvm.ValueRef{file_handle};
        _ = self.builder.buildCall(llvm.c.LLVMGlobalGetValueType(fflush_fn), fflush_fn, &fflush_args, "");

        // Build Result[void, IoError]
        const result_type = self.getVoidResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "bw.flush.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "bw.flush.tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "bw.flush.result_val");
    }

    /// Emit bufwriter.into_inner() -> Result[W, IoError]
    fn emitBufWriterIntoInner(self: *Emitter, bw_ptr: llvm.ValueRef) EmitError!llvm.ValueRef {
        // First flush the buffer
        _ = try self.emitBufWriterFlush(bw_ptr);

        const ptr_type = llvm.Types.pointer(self.ctx);
        const bw_type = self.getBufWriterStructType();

        // Get the inner writer
        const inner_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, bw_type, bw_ptr, 0, "bw.into.inner_ptr");
        const inner_val = self.builder.buildLoad(ptr_type, inner_ptr, "bw.into.inner");

        // Build Result[FILE*, IoError] - always Ok after successful flush
        const result_type = self.getFileResultType();
        const result_alloca = self.builder.buildAlloca(result_type, "bw.into.result");

        const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 0, "bw.into.tag_ptr");
        const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, result_type, result_alloca, 1, "bw.into.val_ptr");

        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);
        _ = self.builder.buildStore(inner_val, val_ptr);

        return self.builder.buildLoad(result_type, result_alloca, "bw.into.result_val");
    }

    /// Get Result[[u8], IoError] type (slice result)
    fn getSliceResultType(self: *Emitter) llvm.TypeRef {
        var fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag
            self.getSliceStructType(), // slice
            self.getIoErrorStructType(), // IoError
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get slice struct type { ptr, len }
    fn getSliceStructType(self: *Emitter) llvm.TypeRef {
        var fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx), // ptr
            llvm.Types.int64(self.ctx), // len
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Get the LLVM struct type for List: { ptr, i32, i32 }
    fn getListStructType(self: *Emitter) llvm.TypeRef {
        var fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx), // ptr
            llvm.Types.int32(self.ctx), // len
            llvm.Types.int32(self.ctx), // capacity
        };
        return llvm.Types.struct_(self.ctx, &fields, false);
    }

    /// Convert a fixed-size array value to a slice struct { ptr, len }.
    /// The array_value must be stored in an alloca first, as we need a pointer to it.
    /// array_alloca is the alloca where the array is stored.
    /// array_len is the number of elements in the array.
    fn convertArrayToSlice(self: *Emitter, array_alloca: llvm.ValueRef, array_len: u64) llvm.ValueRef {
        const slice_type = self.getSliceStructType();

        // Create a slice struct
        const slice_alloca = self.builder.buildAlloca(slice_type, "arr_to_slice");

        // Store pointer to array data (ptr field at index 0)
        const ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, slice_alloca, 0, "slice.ptr_field");
        _ = self.builder.buildStore(array_alloca, ptr_field);

        // Store length (len field at index 1)
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, slice_alloca, 1, "slice.len_field");
        const len_val = llvm.Const.int64(self.ctx, @intCast(array_len));
        _ = self.builder.buildStore(len_val, len_field);

        // Load and return the slice struct value
        return self.builder.buildLoad(slice_type, slice_alloca, "slice.val");
    }

    /// Convert an emitted argument value to match the expected parameter type if needed.
    /// This handles array-to-slice conversion for function call arguments.
    fn convertArgIfNeeded(self: *Emitter, arg_value: llvm.ValueRef, expected_type: llvm.TypeRef) llvm.ValueRef {
        const arg_type = llvm.typeOf(arg_value);

        // Check if the emitted value is an array and expected type is a slice struct
        const arg_kind = llvm.c.LLVMGetTypeKind(arg_type);
        const expected_kind = llvm.c.LLVMGetTypeKind(expected_type);

        if (arg_kind == llvm.c.LLVMArrayTypeKind and expected_kind == llvm.c.LLVMStructTypeKind) {
            // Check if expected type is a slice struct { ptr, i64 }
            const num_fields = llvm.c.LLVMCountStructElementTypes(expected_type);
            if (num_fields == 2) {
                var field_types: [2]llvm.TypeRef = undefined;
                llvm.c.LLVMGetStructElementTypes(expected_type, &field_types);

                const first_is_ptr = llvm.c.LLVMGetTypeKind(field_types[0]) == llvm.c.LLVMPointerTypeKind;
                const second_is_i64 = llvm.c.LLVMGetTypeKind(field_types[1]) == llvm.c.LLVMIntegerTypeKind and
                    llvm.c.LLVMGetIntTypeWidth(field_types[1]) == 64;

                if (first_is_ptr and second_is_i64) {
                    // This is an array-to-slice conversion
                    const array_len = llvm.Types.getArrayLength(arg_type);

                    // Store the array value in an alloca so we can get a pointer to it
                    const array_alloca = self.builder.buildAlloca(arg_type, "arg.arr.storage");
                    _ = self.builder.buildStore(arg_value, array_alloca);

                    // Convert to slice
                    return self.convertArrayToSlice(array_alloca, array_len);
                }
            }
        }

        // No conversion needed
        return arg_value;
    }

    /// Get type size in bytes from LLVM type.
    fn getLLVMTypeSize(self: *Emitter, ty: llvm.TypeRef) u64 {
        const type_kind = llvm.getTypeKind(ty);
        return switch (type_kind) {
            llvm.c.LLVMIntegerTypeKind => @as(u64, llvm.c.LLVMGetIntTypeWidth(ty)) / 8,
            llvm.c.LLVMFloatTypeKind => 4,
            llvm.c.LLVMDoubleTypeKind => 8,
            llvm.c.LLVMPointerTypeKind => 8, // 64-bit pointers
            llvm.c.LLVMStructTypeKind => blk: {
                // Calculate struct size with proper alignment padding
                const num_fields = llvm.c.LLVMCountStructElementTypes(ty);
                if (num_fields == 0) break :blk 0;

                var offset: u64 = 0;
                var max_align: u64 = 1;

                for (0..num_fields) |i| {
                    const field_ty = llvm.c.LLVMStructGetTypeAtIndex(ty, @intCast(i));
                    const field_size = self.getLLVMTypeSize(field_ty);
                    const field_align = self.getLLVMTypeAlignment(field_ty);

                    // Track maximum alignment for struct alignment
                    if (field_align > max_align) max_align = field_align;

                    // Pad offset to field alignment
                    const remainder = offset % field_align;
                    if (remainder != 0) {
                        offset += field_align - remainder;
                    }

                    // Add field size
                    offset += field_size;
                }

                // Pad struct size to struct alignment (max of field alignments)
                const remainder = offset % max_align;
                if (remainder != 0) {
                    offset += max_align - remainder;
                }

                break :blk offset;
            },
            llvm.c.LLVMArrayTypeKind => blk: {
                const elem_ty = llvm.c.LLVMGetElementType(ty);
                const elem_count = llvm.c.LLVMGetArrayLength(ty);
                break :blk self.getLLVMTypeSize(elem_ty) * @as(u64, elem_count);
            },
            else => 8, // Default
        };
    }

    /// Get alignment for an LLVM type.
    fn getLLVMTypeAlignment(self: *Emitter, ty: llvm.TypeRef) u64 {
        const type_kind = llvm.getTypeKind(ty);
        return switch (type_kind) {
            llvm.c.LLVMIntegerTypeKind => blk: {
                const bits = llvm.c.LLVMGetIntTypeWidth(ty);
                const bytes = @as(u64, bits) / 8;
                // Alignment is min(8, size) for integers
                break :blk if (bytes > 8) 8 else if (bytes == 0) 1 else bytes;
            },
            llvm.c.LLVMFloatTypeKind => 4,
            llvm.c.LLVMDoubleTypeKind => 8,
            llvm.c.LLVMPointerTypeKind => 8,
            llvm.c.LLVMStructTypeKind => blk: {
                // Struct alignment is max of field alignments
                const num_fields = llvm.c.LLVMCountStructElementTypes(ty);
                var max_align: u64 = 1;
                for (0..num_fields) |i| {
                    const field_ty = llvm.c.LLVMStructGetTypeAtIndex(ty, @intCast(i));
                    const field_align = self.getLLVMTypeAlignment(field_ty);
                    if (field_align > max_align) max_align = field_align;
                }
                break :blk max_align;
            },
            llvm.c.LLVMArrayTypeKind => blk: {
                const elem_ty = llvm.c.LLVMGetElementType(ty);
                break :blk self.getLLVMTypeAlignment(elem_ty);
            },
            else => 8,
        };
    }

    /// Get alignment as log2 for a type.
    fn getAlignLog2(self: *Emitter, ty: llvm.TypeRef) u8 {
        const size = self.getLLVMTypeSize(ty);
        // Alignment is typically min(8, size) for basic types
        const alignment: u8 = if (size >= 8) 3 else if (size >= 4) 2 else if (size >= 2) 1 else 0;
        return alignment;
    }

    // ---- List runtime function declarations ----

    fn getOrDeclareListNew(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_new";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // ListHeader klar_list_new()
        const list_type = self.getListStructType();
        var param_types = [_]llvm.TypeRef{};
        const fn_type = llvm.c.LLVMFunctionType(list_type, &param_types, 0, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListLen(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_len";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // i32 klar_list_len(ListHeader*)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListIsEmpty(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_is_empty";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // bool klar_list_is_empty(ListHeader*)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(i1_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListCapacity(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_capacity";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // i32 klar_list_capacity(ListHeader*)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListPush(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_push";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // void klar_list_push(ListHeader*, usize element_size, u8 align_log2, void* value)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i8_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 4, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListPop(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_pop";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // bool klar_list_pop(ListHeader*, usize element_size, void* value_out)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(i1_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListGet(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_get";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // bool klar_list_get(ListHeader*, usize element_size, i32 index, void* value_out)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i32_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(i1_type, &param_types, 4, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListSet(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_set";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // void klar_list_set(ListHeader*, usize element_size, i32 index, void* value)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i32_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 4, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListFirst(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_first";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // bool klar_list_first(ListHeader*, usize element_size, void* value_out)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(i1_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListLast(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_last";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // bool klar_list_last(ListHeader*, usize element_size, void* value_out)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i1_type = llvm.Types.int1(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(i1_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListClear(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_clear";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // void klar_list_clear(ListHeader*)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListWithCapacity(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_with_capacity";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // ListHeader klar_list_with_capacity(usize element_size, u8 align_log2, i32 capacity)
        const list_type = self.getListStructType();
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ i64_type, i8_type, i32_type };
        const fn_type = llvm.c.LLVMFunctionType(list_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListClone(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_clone";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // ListHeader klar_list_clone(ListHeader*, usize element_size, u8 align_log2)
        const list_type = self.getListStructType();
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i8_type };
        const fn_type = llvm.c.LLVMFunctionType(list_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareListDrop(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_list_drop";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // void klar_list_drop(ListHeader*, usize element_size, u8 align_log2)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i8_type };
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    // ========================================================================
    // String Runtime Function Declarations
    // ========================================================================

    fn getOrDeclareStringFrom(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_from";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // StringHeader klar_string_from(const char* src)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const string_type = self.getStringStructType();
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(string_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringWithCapacity(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_with_capacity";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // StringHeader klar_string_with_capacity(i32 capacity)
        const i32_type = llvm.Types.int32(self.ctx);
        const string_type = self.getStringStructType();
        var param_types = [_]llvm.TypeRef{i32_type};
        const fn_type = llvm.c.LLVMFunctionType(string_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringPushChar(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_push_char";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // void klar_string_push_char(StringHeader* s, i32 codepoint)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i32_type };
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 2, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringConcat(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_concat";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // StringHeader klar_string_concat(const StringHeader* a, const StringHeader* b)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const string_type = self.getStringStructType();
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(string_type, &param_types, 2, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringAppend(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_append";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // void klar_string_append(StringHeader* s, const StringHeader* other)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 2, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringAsPtr(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_as_ptr";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // const char* klar_string_as_ptr(const StringHeader* s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringClear(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_clear";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // void klar_string_clear(StringHeader* s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringClone(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_clone_heap";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // StringHeader klar_string_clone_heap(const StringHeader* s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const string_type = self.getStringStructType();
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(string_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringDrop(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_drop";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // void klar_string_drop(StringHeader* s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const void_type = llvm.Types.void_(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(void_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringEq(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_eq";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // bool klar_string_eq(const StringHeader* a, const StringHeader* b)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const bool_type = llvm.Types.int1(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(bool_type, &param_types, 2, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStringDataHash(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_hash_heap";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }
        // i64 klar_string_hash_heap(const StringHeader* s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(i64_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    // ========================================================================
    // Array/Slice Methods
    // ========================================================================

    /// Emit array.len() - returns length as i32.
    /// For fixed-size arrays, returns the compile-time known size.
    /// For slices, loads the length field from the slice struct.
    fn emitArrayLen(self: *Emitter, expr: ast.Expr, object: llvm.ValueRef) EmitError!llvm.ValueRef {
        // For fixed-size arrays, we know the size at compile time
        if (self.getArraySize(expr)) |size| {
            return llvm.Const.int32(self.ctx, @intCast(size));
        }

        // For slices, load the length from the struct's second field
        // Slice is { ptr, i64 }
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);

        // Build slice struct type
        var slice_fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx), // data pointer
            i64_type, // length
        };
        const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);

        // Need to get length from slice struct - field 1
        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 1, "len_ptr");
        const len_i64 = self.builder.buildLoad(i64_type, len_ptr, "len");
        // Truncate from i64 to i32
        return llvm.c.LLVMBuildTrunc(self.builder.ref, len_i64, i32_type, "len_i32");
    }

    /// Emit array.is_empty() - returns true if len == 0.
    fn emitArrayIsEmpty(self: *Emitter, expr: ast.Expr, object: llvm.ValueRef) EmitError!llvm.ValueRef {
        // For fixed-size arrays, we know if it's empty at compile time
        if (self.getArraySize(expr)) |size| {
            return llvm.Const.int1(self.ctx, size == 0);
        }

        // For slices, compare length to 0
        const i64_type = llvm.Types.int64(self.ctx);

        // Build slice struct type
        var slice_fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx),
            i64_type,
        };
        const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);

        const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 1, "len_ptr");
        const len = self.builder.buildLoad(i64_type, len_ptr, "len");
        const zero = llvm.Const.int64(self.ctx, 0);
        return self.builder.buildICmp(llvm.c.LLVMIntEQ, len, zero, "is_empty");
    }

    /// Emit array.first() - returns Optional[T], Some(first element) or None if empty.
    fn emitArrayFirst(self: *Emitter, expr: ast.Expr, object: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type = self.getArrayElementType(expr) orelse return EmitError.InvalidAST;
        const elem_llvm_type = self.typeToLLVM(element_type);
        const i64_type = llvm.Types.int64(self.ctx);

        // Build optional type: { i1 tag, T value } where tag 0 = None, 1 = Some
        // Uses i1 to match built-in Optional type
        var opt_fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag (bool)
            elem_llvm_type, // value
        };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Build slice struct type
        var slice_fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx),
            i64_type,
        };
        const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);

        // Allocate space for the result
        const result_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, opt_type, "first_result");

        // Get array length
        const array_size = self.getArraySize(expr);
        const is_fixed_array = array_size != null;

        // For fixed arrays with size > 0, we know first() will always succeed
        if (is_fixed_array) {
            const size = array_size.?;
            // Build the fixed array type for GEP
            const array_type = llvm.Types.array(elem_llvm_type, @intCast(size));

            if (size > 0) {
                // Set tag to 1 (Some)
                const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
                _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

                // Get first element - object is the alloca pointer to the array
                const zero = llvm.Const.int64(self.ctx, 0);
                var indices = [_]llvm.ValueRef{ zero, zero };
                const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, array_type, object, &indices, 2, "first_elem_ptr");
                const elem_val = self.builder.buildLoad(elem_llvm_type, elem_ptr, "first_elem");

                // Store value
                const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 1, "val_ptr");
                _ = self.builder.buildStore(elem_val, val_ptr);
            } else {
                // Empty array - return None (tag = 0)
                const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
                _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr);
            }
        } else {
            // For slices, we need runtime check
            const current_fn = self.current_function orelse return EmitError.InvalidAST;
            const some_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "first_some");
            const none_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "first_none");
            const merge_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "first_merge");

            // Check if length > 0
            const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 1, "len_ptr");
            const len = self.builder.buildLoad(i64_type, len_ptr, "len");
            const zero = llvm.Const.int64(self.ctx, 0);
            const is_nonempty = self.builder.buildICmp(llvm.c.LLVMIntUGT, len, zero, "is_nonempty");
            _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_nonempty, some_bb, none_bb);

            // Some block - get first element
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, some_bb);
            const tag_ptr_some = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
            _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr_some);

            // Get data pointer from slice
            const data_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 0, "data_ptr_ptr");
            const data_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), data_ptr_ptr, "data_ptr");
            const elem_val = self.builder.buildLoad(elem_llvm_type, data_ptr, "first_elem");

            const val_ptr_some = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 1, "val_ptr");
            _ = self.builder.buildStore(elem_val, val_ptr_some);
            _ = llvm.c.LLVMBuildBr(self.builder.ref, merge_bb);

            // None block
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, none_bb);
            const tag_ptr_none = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
            _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr_none);
            _ = llvm.c.LLVMBuildBr(self.builder.ref, merge_bb);

            // Merge block
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, merge_bb);
        }

        // Load and return the result
        return self.builder.buildLoad(opt_type, result_ptr, "first_opt");
    }

    /// Emit array.last() - returns Optional[T], Some(last element) or None if empty.
    fn emitArrayLast(self: *Emitter, expr: ast.Expr, object: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type = self.getArrayElementType(expr) orelse return EmitError.InvalidAST;
        const elem_llvm_type = self.typeToLLVM(element_type);
        const i64_type = llvm.Types.int64(self.ctx);

        // Build optional type: { i1 tag, T value } where tag 0 = None, 1 = Some
        // Uses i1 to match built-in Optional type
        var opt_fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag (bool)
            elem_llvm_type, // value
        };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Build slice struct type
        var slice_fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx),
            i64_type,
        };
        const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);

        const result_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, opt_type, "last_result");

        const array_size = self.getArraySize(expr);
        const is_fixed_array = array_size != null;

        if (is_fixed_array) {
            const size = array_size.?;
            const array_type = llvm.Types.array(elem_llvm_type, @intCast(size));

            if (size > 0) {
                const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
                _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr);

                // Get last element (index = size - 1)
                const zero = llvm.Const.int64(self.ctx, 0);
                const last_idx = llvm.Const.int64(self.ctx, @intCast(size - 1));
                var indices = [_]llvm.ValueRef{ zero, last_idx };
                const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, array_type, object, &indices, 2, "last_elem_ptr");
                const elem_val = self.builder.buildLoad(elem_llvm_type, elem_ptr, "last_elem");

                const val_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 1, "val_ptr");
                _ = self.builder.buildStore(elem_val, val_ptr);
            } else {
                const tag_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
                _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr);
            }
        } else {
            // For slices, we need runtime check
            const current_fn = self.current_function orelse return EmitError.InvalidAST;
            const some_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "last_some");
            const none_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "last_none");
            const merge_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "last_merge");

            const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 1, "len_ptr");
            const len = self.builder.buildLoad(i64_type, len_ptr, "len");
            const zero = llvm.Const.int64(self.ctx, 0);
            const is_nonempty = self.builder.buildICmp(llvm.c.LLVMIntUGT, len, zero, "is_nonempty");
            _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_nonempty, some_bb, none_bb);

            // Some block
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, some_bb);
            const tag_ptr_some = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
            _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr_some);

            // Calculate last index = len - 1
            const one = llvm.Const.int64(self.ctx, 1);
            const last_idx = llvm.c.LLVMBuildSub(self.builder.ref, len, one, "last_idx");

            // Get data pointer and index into it
            const data_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 0, "data_ptr_ptr");
            const data_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), data_ptr_ptr, "data_ptr");
            var gep_idx = [_]llvm.ValueRef{last_idx};
            const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, elem_llvm_type, data_ptr, &gep_idx, 1, "last_elem_ptr");
            const elem_val = self.builder.buildLoad(elem_llvm_type, elem_ptr, "last_elem");

            const val_ptr_some = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 1, "val_ptr");
            _ = self.builder.buildStore(elem_val, val_ptr_some);
            _ = llvm.c.LLVMBuildBr(self.builder.ref, merge_bb);

            // None block
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, none_bb);
            const tag_ptr_none = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
            _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr_none);
            _ = llvm.c.LLVMBuildBr(self.builder.ref, merge_bb);

            // Merge block
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, merge_bb);
        }

        return self.builder.buildLoad(opt_type, result_ptr, "last_opt");
    }

    /// Emit array.get(index) - returns Optional[T], Some(element) if in bounds, None otherwise.
    fn emitArrayGet(self: *Emitter, expr: ast.Expr, object: llvm.ValueRef, index: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type = self.getArrayElementType(expr) orelse return EmitError.InvalidAST;
        const elem_llvm_type = self.typeToLLVM(element_type);
        const i64_type = llvm.Types.int64(self.ctx);

        // Build optional type: { i1 tag, T value } where tag 0 = None, 1 = Some
        // Uses i1 to match built-in Optional type
        var opt_fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag (bool)
            elem_llvm_type, // value
        };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

        // Build slice struct type
        var slice_fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx),
            i64_type,
        };
        const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);

        // Create alloca in entry block to prevent stack growth in loops
        const result_ptr = self.buildEntryBlockAlloca(opt_type, "get_result");

        const current_fn = self.current_function orelse return EmitError.InvalidAST;
        const some_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "get_some");
        const none_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "get_none");
        const merge_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "get_merge");

        // Convert index to i64 if needed
        const idx_type = llvm.typeOf(index);
        const idx_i64 = if (idx_type == i64_type)
            index
        else
            llvm.c.LLVMBuildSExt(self.builder.ref, index, i64_type, "idx_i64");

        // Get array length
        const array_size = self.getArraySize(expr);
        const len = if (array_size) |size|
            llvm.Const.int64(self.ctx, @intCast(size))
        else blk: {
            const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 1, "len_ptr");
            break :blk self.builder.buildLoad(i64_type, len_ptr, "len");
        };

        // Check if index < 0 or index >= len
        const zero = llvm.Const.int64(self.ctx, 0);
        const idx_negative = self.builder.buildICmp(llvm.c.LLVMIntSLT, idx_i64, zero, "idx_negative");
        const idx_ge_len = self.builder.buildICmp(llvm.c.LLVMIntSGE, idx_i64, len, "idx_ge_len");
        const out_of_bounds = self.builder.buildOr(idx_negative, idx_ge_len, "out_of_bounds");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, out_of_bounds, none_bb, some_bb);

        // Some block - index is valid
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, some_bb);
        const tag_ptr_some = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), tag_ptr_some);

        // Get element at index
        const elem_val = if (array_size) |size| blk: {
            // Fixed array - use 2D GEP with explicit array type
            const array_type = llvm.Types.array(elem_llvm_type, @intCast(size));
            var indices = [_]llvm.ValueRef{ zero, idx_i64 };
            const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, array_type, object, &indices, 2, "elem_ptr");
            break :blk self.builder.buildLoad(elem_llvm_type, elem_ptr, "elem");
        } else blk: {
            // Slice - get data pointer and index
            const data_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 0, "data_ptr_ptr");
            const data_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), data_ptr_ptr, "data_ptr");
            var gep_idx = [_]llvm.ValueRef{idx_i64};
            const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, elem_llvm_type, data_ptr, &gep_idx, 1, "elem_ptr");
            break :blk self.builder.buildLoad(elem_llvm_type, elem_ptr, "elem");
        };

        const val_ptr_some = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 1, "val_ptr");
        _ = self.builder.buildStore(elem_val, val_ptr_some);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, merge_bb);

        // None block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, none_bb);
        const tag_ptr_none = llvm.c.LLVMBuildStructGEP2(self.builder.ref, opt_type, result_ptr, 0, "tag_ptr");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), tag_ptr_none);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, merge_bb);

        // Merge block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, merge_bb);

        return self.builder.buildLoad(opt_type, result_ptr, "get_opt");
    }

    /// Emit array.contains(value) - returns true if any element equals value.
    fn emitArrayContains(self: *Emitter, expr: ast.Expr, object: llvm.ValueRef, value: llvm.ValueRef) EmitError!llvm.ValueRef {
        const element_type = self.getArrayElementType(expr) orelse return EmitError.InvalidAST;
        const elem_llvm_type = self.typeToLLVM(element_type);
        const i64_type = llvm.Types.int64(self.ctx);

        const current_fn = self.current_function orelse return EmitError.InvalidAST;

        // Build slice struct type
        var slice_fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx),
            i64_type,
        };
        const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);

        // Allocate result variable
        const i1_type = llvm.Types.int1(self.ctx);
        const result_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, i1_type, "contains_result");
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, false), result_ptr); // Initialize to false

        // Get array length
        const array_size = self.getArraySize(expr);
        const len = if (array_size) |size|
            llvm.Const.int64(self.ctx, @intCast(size))
        else blk: {
            const len_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 1, "len_ptr");
            break :blk self.builder.buildLoad(i64_type, len_ptr, "len");
        };

        // Loop through array
        const loop_init_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "contains_init");
        const loop_cond_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "contains_cond");
        const loop_body_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "contains_body");
        const found_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "contains_found");
        const loop_inc_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "contains_inc");
        const loop_end_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, current_fn, "contains_end");

        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_init_bb);

        // Loop init - allocate index
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_init_bb);
        const idx_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, i64_type, "idx_ptr");
        _ = self.builder.buildStore(llvm.Const.int64(self.ctx, 0), idx_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_cond_bb);

        // Loop condition - idx < len
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_cond_bb);
        const idx = self.builder.buildLoad(i64_type, idx_ptr, "idx");
        const continue_loop = self.builder.buildICmp(llvm.c.LLVMIntULT, idx, len, "continue_loop");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_loop, loop_body_bb, loop_end_bb);

        // Loop body - compare element
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_body_bb);
        const elem_val = if (array_size) |size| blk: {
            // Fixed array - use 2D GEP with explicit array type
            const array_type = llvm.Types.array(elem_llvm_type, @intCast(size));
            const zero = llvm.Const.int64(self.ctx, 0);
            var indices = [_]llvm.ValueRef{ zero, idx };
            const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, array_type, object, &indices, 2, "elem_ptr");
            break :blk self.builder.buildLoad(elem_llvm_type, elem_ptr, "elem");
        } else blk: {
            const data_ptr_ptr = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, object, 0, "data_ptr_ptr");
            const data_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), data_ptr_ptr, "data_ptr");
            var gep_idx = [_]llvm.ValueRef{idx};
            const elem_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, elem_llvm_type, data_ptr, &gep_idx, 1, "elem_ptr");
            break :blk self.builder.buildLoad(elem_llvm_type, elem_ptr, "elem");
        };

        // Compare with value
        const is_eq = if (element_type.isInteger() or element_type == .primitive and element_type.primitive == .bool_)
            self.builder.buildICmp(llvm.c.LLVMIntEQ, elem_val, value, "is_eq")
        else if (element_type.isFloat())
            self.builder.buildFCmp(llvm.c.LLVMRealOEQ, elem_val, value, "is_eq")
        else
            // For other types (strings, structs), use pointer comparison for now
            // TODO: Use proper equality
            self.builder.buildICmp(llvm.c.LLVMIntEQ, elem_val, value, "is_eq");

        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_eq, found_bb, loop_inc_bb);

        // Found block - set result to true and exit
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, found_bb);
        _ = self.builder.buildStore(llvm.Const.int1(self.ctx, true), result_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_end_bb);

        // Loop increment
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_inc_bb);
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, llvm.Const.int64(self.ctx, 1), "next_idx");
        _ = self.builder.buildStore(next_idx, idx_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_cond_bb);

        // Loop end
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_end_bb);

        return self.builder.buildLoad(i1_type, result_ptr, "contains");
    }

    /// Declare or get the klar_string_chars runtime function.
    /// This function treats each byte as a character (ASCII-only for now).
    /// TODO: Implement proper UTF-8 decoding.
    fn getOrDeclareStringChars(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_chars";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Return type is a struct { ptr, i64 }
        const ptr_type = llvm.Types.pointer(self.ctx);
        var slice_fields = [_]llvm.TypeRef{
            ptr_type, // data pointer
            llvm.Types.int64(self.ctx), // length
        };
        const slice_type = llvm.Types.struct_(self.ctx, &slice_fields, false);

        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(slice_type, &param_types, 1, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Build the function body inline
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const loop_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop");
        const loop_body_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop_body");
        const loop_end_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop_end");
        const ret_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "return");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        const i8_type = llvm.Types.int8(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const zero_i64 = llvm.Const.int64(self.ctx, 0);
        const one_i64 = llvm.Const.int64(self.ctx, 1);
        const four_i64 = llvm.Const.int64(self.ctx, 4); // sizeof(i32)

        // Entry block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);
        const s = llvm.c.LLVMGetParam(func, 0);

        // Get string length using strlen
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{s};
        const len = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(strlen_fn),
            strlen_fn,
            &strlen_args,
            1,
            "len",
        );

        // Allocate array of i32 (len * 4 bytes)
        const alloc_size = llvm.c.LLVMBuildMul(self.builder.ref, len, four_i64, "alloc_size");
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const result = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(malloc_fn),
            malloc_fn,
            &malloc_args,
            1,
            "result",
        );

        // Allocate index variable
        const idx_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, i64_type, "idx_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, zero_i64, idx_ptr);

        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_bb);

        // Loop condition
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_bb);
        const idx = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, idx_ptr, "idx");
        const cond = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntULT, idx, len, "cond");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, cond, loop_body_bb, loop_end_bb);

        // Loop body: copy byte as i32
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_body_bb);

        // Load source byte
        var src_indices = [_]llvm.ValueRef{idx};
        const src_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, s, &src_indices, 1, "src_ptr");
        const byte = llvm.c.LLVMBuildLoad2(self.builder.ref, i8_type, src_ptr, "byte");

        // Zero-extend byte to i32
        const char_val = llvm.c.LLVMBuildZExt(self.builder.ref, byte, i32_type, "char_val");

        // Store to result array
        var dst_indices = [_]llvm.ValueRef{idx};
        const dst_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i32_type, result, &dst_indices, 1, "dst_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, char_val, dst_ptr);

        // Increment index
        const next_idx = llvm.c.LLVMBuildAdd(self.builder.ref, idx, one_i64, "next_idx");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, next_idx, idx_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_bb);

        // Loop end: build result struct
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_end_bb);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, ret_bb);

        // Return the slice struct
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, ret_bb);

        // Build slice struct { ptr, len } using alloca + store + load
        const slice_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, slice_type, "slice_ptr");

        // Store pointer field (index 0)
        const ptr_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, slice_ptr, 0, "ptr_field");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, result, ptr_field);

        // Store length field (index 1)
        const len_field = llvm.c.LLVMBuildStructGEP2(self.builder.ref, slice_type, slice_ptr, 1, "len_field");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, len, len_field);

        // Load the complete slice struct and return
        const slice_val = llvm.c.LLVMBuildLoad2(self.builder.ref, slice_type, slice_ptr, "slice_val");
        _ = llvm.c.LLVMBuildRet(self.builder.ref, slice_val);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    /// Declare or get the klar_string_trim runtime function.
    /// This function trims leading and trailing whitespace from a string.
    fn getOrDeclareStringTrim(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_trim";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Declare: char* klar_string_trim(const char* s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 1, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Build the function body inline
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const loop_start_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop_start");
        const loop_end_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop_end");
        const copy_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "copy");
        const ret_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "return");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        const i8_type = llvm.Types.int8(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const zero_i64 = llvm.Const.int64(self.ctx, 0);
        const one_i64 = llvm.Const.int64(self.ctx, 1);

        // Entry block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);
        const s = llvm.c.LLVMGetParam(func, 0);

        // Get string length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{s};
        const len = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(strlen_fn),
            strlen_fn,
            &strlen_args,
            1,
            "len",
        );

        // Allocate variables for start and end indices
        const start_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, i64_type, "start_ptr");
        const end_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, i64_type, "end_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, zero_i64, start_ptr);
        _ = llvm.c.LLVMBuildStore(self.builder.ref, len, end_ptr);

        // Loop to find start (skip leading whitespace)
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_start_bb);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_start_bb);
        const start_val = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, start_ptr, "start");
        const start_lt_len = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntULT, start_val, len, "start_lt_len");

        // Get character at start position
        var gep_indices = [_]llvm.ValueRef{start_val};
        const char_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, s, &gep_indices, 1, "char_ptr");
        const ch = llvm.c.LLVMBuildLoad2(self.builder.ref, i8_type, char_ptr, "ch");

        // Check if whitespace (space, tab, newline, carriage return)
        const is_space = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, ch, llvm.Const.int8(self.ctx, ' '), "is_space");
        const is_tab = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, ch, llvm.Const.int8(self.ctx, '\t'), "is_tab");
        const is_nl = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, ch, llvm.Const.int8(self.ctx, '\n'), "is_nl");
        const is_cr = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, ch, llvm.Const.int8(self.ctx, '\r'), "is_cr");
        const is_ws1 = llvm.c.LLVMBuildOr(self.builder.ref, is_space, is_tab, "is_ws1");
        const is_ws2 = llvm.c.LLVMBuildOr(self.builder.ref, is_nl, is_cr, "is_ws2");
        const is_ws = llvm.c.LLVMBuildOr(self.builder.ref, is_ws1, is_ws2, "is_ws");

        const continue_start = llvm.c.LLVMBuildAnd(self.builder.ref, start_lt_len, is_ws, "continue_start");

        // If still whitespace, increment start and loop
        const inc_start_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "inc_start");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_start, inc_start_bb, loop_end_bb);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, inc_start_bb);
        const new_start = llvm.c.LLVMBuildAdd(self.builder.ref, start_val, one_i64, "new_start");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, new_start, start_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_start_bb);

        // Loop to find end (skip trailing whitespace)
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_end_bb);
        const end_val = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, end_ptr, "end");
        const start_val2 = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, start_ptr, "start2");
        const end_gt_start = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntUGT, end_val, start_val2, "end_gt_start");

        // Get character at end-1 position
        const end_minus1 = llvm.c.LLVMBuildSub(self.builder.ref, end_val, one_i64, "end_minus1");
        var gep_indices2 = [_]llvm.ValueRef{end_minus1};
        const char_ptr2 = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, s, &gep_indices2, 1, "char_ptr2");
        const ch2 = llvm.c.LLVMBuildLoad2(self.builder.ref, i8_type, char_ptr2, "ch2");

        // Check if whitespace
        const is_space2 = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, ch2, llvm.Const.int8(self.ctx, ' '), "is_space2");
        const is_tab2 = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, ch2, llvm.Const.int8(self.ctx, '\t'), "is_tab2");
        const is_nl2 = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, ch2, llvm.Const.int8(self.ctx, '\n'), "is_nl2");
        const is_cr2 = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, ch2, llvm.Const.int8(self.ctx, '\r'), "is_cr2");
        const is_ws12 = llvm.c.LLVMBuildOr(self.builder.ref, is_space2, is_tab2, "is_ws12");
        const is_ws22 = llvm.c.LLVMBuildOr(self.builder.ref, is_nl2, is_cr2, "is_ws22");
        const is_ws_end = llvm.c.LLVMBuildOr(self.builder.ref, is_ws12, is_ws22, "is_ws_end");

        const continue_end = llvm.c.LLVMBuildAnd(self.builder.ref, end_gt_start, is_ws_end, "continue_end");

        const dec_end_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "dec_end");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, continue_end, dec_end_bb, copy_bb);

        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, dec_end_bb);
        const new_end = llvm.c.LLVMBuildSub(self.builder.ref, end_val, one_i64, "new_end");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, new_end, end_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_end_bb);

        // Copy the trimmed substring
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, copy_bb);
        const final_start = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, start_ptr, "final_start");
        const final_end = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, end_ptr, "final_end");
        const trimmed_len = llvm.c.LLVMBuildSub(self.builder.ref, final_end, final_start, "trimmed_len");
        const alloc_size = llvm.c.LLVMBuildAdd(self.builder.ref, trimmed_len, one_i64, "alloc_size");

        // Allocate new string
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const result = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(malloc_fn),
            malloc_fn,
            &malloc_args,
            1,
            "result",
        );

        // Copy using memcpy
        const memcpy_fn = self.getOrDeclareMemcpy();
        var gep_indices3 = [_]llvm.ValueRef{final_start};
        const src_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, s, &gep_indices3, 1, "src_ptr");
        var memcpy_args = [_]llvm.ValueRef{ result, src_ptr, trimmed_len };
        _ = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(memcpy_fn),
            memcpy_fn,
            &memcpy_args,
            3,
            "",
        );

        // Add null terminator
        var gep_indices4 = [_]llvm.ValueRef{trimmed_len};
        const null_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, result, &gep_indices4, 1, "null_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, llvm.Const.int1(self.ctx, false), null_ptr);

        _ = llvm.c.LLVMBuildBr(self.builder.ref, ret_bb);

        // Return
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, ret_bb);
        _ = llvm.c.LLVMBuildRet(self.builder.ref, result);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    /// Declare or get the klar_string_to_uppercase runtime function.
    fn getOrDeclareStringToUppercase(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_to_uppercase";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Declare: char* klar_string_to_uppercase(const char* s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 1, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Build the function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const loop_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop");
        const body_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "body");
        const ret_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "return");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        const i8_type = llvm.Types.int8(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const zero_i64 = llvm.Const.int64(self.ctx, 0);
        const one_i64 = llvm.Const.int64(self.ctx, 1);

        // Entry block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);
        const s = llvm.c.LLVMGetParam(func, 0);

        // Get string length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{s};
        const len = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(strlen_fn),
            strlen_fn,
            &strlen_args,
            1,
            "len",
        );

        // Allocate new string
        const alloc_size = llvm.c.LLVMBuildAdd(self.builder.ref, len, one_i64, "alloc_size");
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const result = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(malloc_fn),
            malloc_fn,
            &malloc_args,
            1,
            "result",
        );

        // Initialize loop counter
        const i_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, i64_type, "i_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, zero_i64, i_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_bb);

        // Loop condition
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_bb);
        const i = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, i_ptr, "i");
        const cond = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntULT, i, len, "cond");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, cond, body_bb, ret_bb);

        // Loop body - convert to uppercase
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, body_bb);
        var gep_src = [_]llvm.ValueRef{i};
        const src_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, s, &gep_src, 1, "src_ptr");
        const ch = llvm.c.LLVMBuildLoad2(self.builder.ref, i8_type, src_ptr, "ch");

        // Check if lowercase letter (a-z) and convert to uppercase
        const is_lower = llvm.c.LLVMBuildAnd(
            self.builder.ref,
            llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntUGE, ch, llvm.Const.int8(self.ctx, 'a'), "ge_a"),
            llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntULE, ch, llvm.Const.int8(self.ctx, 'z'), "le_z"),
            "is_lower",
        );

        // Subtract 32 to convert lowercase to uppercase
        const upper_ch = llvm.c.LLVMBuildSub(self.builder.ref, ch, llvm.Const.int8(self.ctx, 32), "upper_ch");
        const result_ch = llvm.c.LLVMBuildSelect(self.builder.ref, is_lower, upper_ch, ch, "result_ch");

        // Store result
        var gep_dst = [_]llvm.ValueRef{i};
        const dst_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, result, &gep_dst, 1, "dst_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, result_ch, dst_ptr);

        // Increment counter
        const next_i = llvm.c.LLVMBuildAdd(self.builder.ref, i, one_i64, "next_i");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, next_i, i_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_bb);

        // Return block - add null terminator and return
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, ret_bb);
        var gep_null = [_]llvm.ValueRef{len};
        const null_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, result, &gep_null, 1, "null_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, llvm.Const.int1(self.ctx, false), null_ptr);
        _ = llvm.c.LLVMBuildRet(self.builder.ref, result);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    /// Declare or get the klar_string_to_lowercase runtime function.
    fn getOrDeclareStringToLowercase(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_to_lowercase";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Declare: char* klar_string_to_lowercase(const char* s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 1, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Build the function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const loop_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop");
        const body_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "body");
        const ret_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "return");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        const i8_type = llvm.Types.int8(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const zero_i64 = llvm.Const.int64(self.ctx, 0);
        const one_i64 = llvm.Const.int64(self.ctx, 1);

        // Entry block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);
        const s = llvm.c.LLVMGetParam(func, 0);

        // Get string length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{s};
        const len = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(strlen_fn),
            strlen_fn,
            &strlen_args,
            1,
            "len",
        );

        // Allocate new string
        const alloc_size = llvm.c.LLVMBuildAdd(self.builder.ref, len, one_i64, "alloc_size");
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const result = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(malloc_fn),
            malloc_fn,
            &malloc_args,
            1,
            "result",
        );

        // Initialize loop counter
        const i_ptr = llvm.c.LLVMBuildAlloca(self.builder.ref, i64_type, "i_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, zero_i64, i_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_bb);

        // Loop condition
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_bb);
        const i = llvm.c.LLVMBuildLoad2(self.builder.ref, i64_type, i_ptr, "i");
        const cond = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntULT, i, len, "cond");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, cond, body_bb, ret_bb);

        // Loop body - convert to lowercase
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, body_bb);
        var gep_src = [_]llvm.ValueRef{i};
        const src_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, s, &gep_src, 1, "src_ptr");
        const ch = llvm.c.LLVMBuildLoad2(self.builder.ref, i8_type, src_ptr, "ch");

        // Check if uppercase letter (A-Z) and convert to lowercase
        const is_upper = llvm.c.LLVMBuildAnd(
            self.builder.ref,
            llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntUGE, ch, llvm.Const.int8(self.ctx, 'A'), "ge_A"),
            llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntULE, ch, llvm.Const.int8(self.ctx, 'Z'), "le_Z"),
            "is_upper",
        );

        // Add 32 to convert uppercase to lowercase
        const lower_ch = llvm.c.LLVMBuildAdd(self.builder.ref, ch, llvm.Const.int8(self.ctx, 32), "lower_ch");
        const result_ch = llvm.c.LLVMBuildSelect(self.builder.ref, is_upper, lower_ch, ch, "result_ch");

        // Store result
        var gep_dst = [_]llvm.ValueRef{i};
        const dst_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, result, &gep_dst, 1, "dst_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, result_ch, dst_ptr);

        // Increment counter
        const next_i = llvm.c.LLVMBuildAdd(self.builder.ref, i, one_i64, "next_i");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, next_i, i_ptr);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_bb);

        // Return block - add null terminator and return
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, ret_bb);
        var gep_null = [_]llvm.ValueRef{len};
        const null_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, result, &gep_null, 1, "null_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, llvm.Const.int1(self.ctx, false), null_ptr);
        _ = llvm.c.LLVMBuildRet(self.builder.ref, result);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    /// Declare or get the klar_string_slice runtime function.
    /// Implements string.slice(start, end) with clamping semantics.
    fn getOrDeclareStringSlice(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_slice";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // Declare: char* klar_string_slice(const char* s, int64_t start, int64_t end)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i64_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 3, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Build the function body
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const copy_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "copy");
        const ret_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "return");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
        const saved_func = self.current_function;

        const i8_type = llvm.Types.int8(self.ctx);
        const zero_i64 = llvm.Const.int64(self.ctx, 0);
        const one_i64 = llvm.Const.int64(self.ctx, 1);

        // Entry block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);
        const s = llvm.c.LLVMGetParam(func, 0);
        const start_arg = llvm.c.LLVMGetParam(func, 1);
        const end_arg = llvm.c.LLVMGetParam(func, 2);

        // Get string length
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args = [_]llvm.ValueRef{s};
        const len = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(strlen_fn),
            strlen_fn,
            &strlen_args,
            1,
            "len",
        );

        // Clamp start to [0, len]
        // start = max(0, min(start, len))
        const start_ge_0 = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntSGT, start_arg, zero_i64, "start_ge_0");
        const start_clamped_low = llvm.c.LLVMBuildSelect(self.builder.ref, start_ge_0, start_arg, zero_i64, "start_clamped_low");
        const start_le_len = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntSLT, start_clamped_low, len, "start_le_len");
        const start_clamped = llvm.c.LLVMBuildSelect(self.builder.ref, start_le_len, start_clamped_low, len, "start_clamped");

        // Clamp end to [start, len]
        // end = max(start, min(end, len))
        const end_ge_start = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntSGT, end_arg, start_clamped, "end_ge_start");
        const end_clamped_low = llvm.c.LLVMBuildSelect(self.builder.ref, end_ge_start, end_arg, start_clamped, "end_clamped_low");
        const end_le_len = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntSLT, end_clamped_low, len, "end_le_len");
        const end_clamped = llvm.c.LLVMBuildSelect(self.builder.ref, end_le_len, end_clamped_low, len, "end_clamped");

        // Calculate slice length
        const slice_len = llvm.c.LLVMBuildSub(self.builder.ref, end_clamped, start_clamped, "slice_len");

        // Allocate result buffer (slice_len + 1 for null terminator)
        const alloc_size = llvm.c.LLVMBuildAdd(self.builder.ref, slice_len, one_i64, "alloc_size");
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const result = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(malloc_fn),
            malloc_fn,
            &malloc_args,
            1,
            "result",
        );

        // Check if we have bytes to copy
        const has_bytes = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntSGT, slice_len, zero_i64, "has_bytes");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, has_bytes, copy_bb, ret_bb);

        // Copy block - use memcpy
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, copy_bb);
        var src_gep = [_]llvm.ValueRef{start_clamped};
        const src_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, s, &src_gep, 1, "src_ptr");
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args = [_]llvm.ValueRef{ result, src_ptr, slice_len };
        _ = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(memcpy_fn),
            memcpy_fn,
            &memcpy_args,
            3,
            "",
        );
        _ = llvm.c.LLVMBuildBr(self.builder.ref, ret_bb);

        // Return block - add null terminator and return
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, ret_bb);
        var gep_null = [_]llvm.ValueRef{slice_len};
        const null_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, result, &gep_null, 1, "null_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, llvm.Const.int1(self.ctx, false), null_ptr);
        _ = llvm.c.LLVMBuildRet(self.builder.ref, result);

        // Restore builder position
        if (saved_bb) |bb| {
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
        }
        self.current_function = saved_func;

        return func;
    }

    /// Declare or get the memcpy function.
    fn getOrDeclareMemcpy(self: *Emitter) llvm.ValueRef {
        const fn_name = "memcpy";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type, i64_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Declare or get the memcmp function.
    fn getOrDeclareMemcmp(self: *Emitter) llvm.ValueRef {
        const fn_name = "memcmp";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int memcmp(const void* s1, const void* s2, size_t n)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type, i64_type };
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Declare or get the memset function.
    fn getOrDeclareMemset(self: *Emitter) llvm.ValueRef {
        const fn_name = "memset";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // void *memset(void *s, int c, size_t n)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i32_type, i64_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Emit Ok(value) - Result::Ok constructor.
    /// Uses expected_type from context if available (e.g., from type annotation),
    /// otherwise defaults to Result[T, i32] where T is the value type.
    fn emitOkCall(self: *Emitter, args: []const ast.Expr) EmitError!llvm.ValueRef {
        if (args.len != 1) {
            return EmitError.InvalidAST;
        }

        // Emit the value
        const value = try self.emitExpr(args[0]);
        const ok_type = llvm.typeOf(value);

        // Use expected_type if it's a Result type, otherwise default to i32
        const err_type = if (self.expected_type) |et| blk: {
            if (et == .result) {
                break :blk self.typeToLLVM(et.result.err_type);
            }
            break :blk llvm.Types.int32(self.ctx);
        } else llvm.Types.int32(self.ctx);

        return self.emitOk(value, ok_type, err_type);
    }

    /// Emit Err(error) - Result::Err constructor.
    /// Uses expected_type from context if available (e.g., from type annotation),
    /// otherwise defaults to Result[i32, E] where E is the error type.
    fn emitErrCall(self: *Emitter, args: []const ast.Expr) EmitError!llvm.ValueRef {
        if (args.len != 1) {
            return EmitError.InvalidAST;
        }

        // Emit the error value
        const error_val = try self.emitExpr(args[0]);
        const err_type = llvm.typeOf(error_val);

        // Use expected_type if it's a Result type, otherwise default to i32
        const ok_type = if (self.expected_type) |et| blk: {
            if (et == .result) {
                break :blk self.typeToLLVM(et.result.ok_type);
            }
            break :blk llvm.Types.int32(self.ctx);
        } else llvm.Types.int32(self.ctx);

        return self.emitErr(error_val, ok_type, err_type);
    }

    /// Emit Result.ok(value) via method call syntax.
    fn emitResultOk(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) {
            return EmitError.InvalidAST;
        }

        const value = try self.emitExpr(method.args[0]);
        const ok_type = llvm.typeOf(value);
        const err_type = llvm.Types.int32(self.ctx);

        return self.emitOk(value, ok_type, err_type);
    }

    /// Emit Result.err(error) via method call syntax.
    fn emitResultErr(self: *Emitter, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        if (method.args.len != 1) {
            return EmitError.InvalidAST;
        }

        const error_val = try self.emitExpr(method.args[0]);
        const err_type = llvm.typeOf(error_val);
        const ok_type = llvm.Types.int32(self.ctx);

        return self.emitErr(error_val, ok_type, err_type);
    }

    /// Emit Some(value) - Optional::Some constructor.
    /// Uses expected_type from context if available (e.g., from type annotation),
    /// otherwise infers ?T where T is the value type.
    fn emitSomeCall(self: *Emitter, args: []const ast.Expr) EmitError!llvm.ValueRef {
        if (args.len != 1) {
            return EmitError.InvalidAST;
        }

        // Emit the value
        const value = try self.emitExpr(args[0]);
        const inner_type = llvm.typeOf(value);

        return self.emitSome(value, inner_type);
    }

    /// Emit None - Optional::None constructor.
    /// Requires expected_type from context to know the optional's inner type.
    fn emitNoneCall(self: *Emitter) EmitError!llvm.ValueRef {
        // Get the inner type from expected_type context
        const inner_type = if (self.expected_type) |et| blk: {
            if (et == .optional) {
                break :blk self.typeToLLVM(et.optional.*);
            }
            // Default to i32 if no Optional context
            break :blk llvm.Types.int32(self.ctx);
        } else llvm.Types.int32(self.ctx);

        // Build the Optional type { i1, T }
        var opt_fields = [_]llvm.TypeRef{
            llvm.Types.int1(self.ctx), // tag
            inner_type, // value
        };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

        return self.emitNone(opt_type);
    }

    /// Emit Result.is_ok() - returns true if tag == 1 (Ok).
    fn emitResultIsOk(self: *Emitter, result_val: llvm.ValueRef, result_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        // Store result to temp for GEP access
        const result_alloca = self.builder.buildAlloca(result_type, "result.is_ok.tmp");
        _ = self.builder.buildStore(result_val, result_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(result_type, result_alloca, &tag_indices, "result.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "result.tag");

        // Tag == 1 means Ok
        return tag;
    }

    /// Emit Result.is_err() - returns true if tag == 0 (Err).
    fn emitResultIsErr(self: *Emitter, result_val: llvm.ValueRef, result_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        // Store result to temp for GEP access
        const result_alloca = self.builder.buildAlloca(result_type, "result.is_err.tmp");
        _ = self.builder.buildStore(result_val, result_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(result_type, result_alloca, &tag_indices, "result.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "result.tag");

        // Tag == 0 means Err, so NOT tag
        return self.builder.buildNot(tag, "result.is_err");
    }

    /// Emit Optional.is_some() - returns true if tag == 1 (Some).
    fn emitOptionalIsSome(self: *Emitter, opt_val: llvm.ValueRef, opt_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        // Store optional to temp for GEP access
        const opt_alloca = self.builder.buildAlloca(opt_type, "opt.is_some.tmp");
        _ = self.builder.buildStore(opt_val, opt_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &tag_indices, "opt.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "opt.tag");

        // Tag == 1 means Some
        return tag;
    }

    /// Emit Optional.is_none() - returns true if tag == 0 (None).
    fn emitOptionalIsNone(self: *Emitter, opt_val: llvm.ValueRef, opt_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        // Store optional to temp for GEP access
        const opt_alloca = self.builder.buildAlloca(opt_type, "opt.is_none.tmp");
        _ = self.builder.buildStore(opt_val, opt_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &tag_indices, "opt.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "opt.tag");

        // Tag == 0 means None, so NOT tag
        return self.builder.buildNot(tag, "opt.is_none");
    }

    /// Emit Optional.eq(other) - compares two optionals for equality.
    /// Both None => true, both Some with equal values => true, otherwise => false.
    fn emitOptionalEq(self: *Emitter, left: llvm.ValueRef, right: llvm.ValueRef, opt_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store both optionals for GEP access
        const left_alloca = self.builder.buildAlloca(opt_type, "opt.eq.left");
        _ = self.builder.buildStore(left, left_alloca);
        const right_alloca = self.builder.buildAlloca(opt_type, "opt.eq.right");
        _ = self.builder.buildStore(right, right_alloca);

        // Get left tag
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const left_tag_ptr = self.builder.buildGEP(opt_type, left_alloca, &tag_indices, "opt.eq.left.tag.ptr");
        const left_tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), left_tag_ptr, "opt.eq.left.tag");

        // Get right tag
        const right_tag_ptr = self.builder.buildGEP(opt_type, right_alloca, &tag_indices, "opt.eq.right.tag.ptr");
        const right_tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), right_tag_ptr, "opt.eq.right.tag");

        // Check if tags are equal
        const tags_equal = self.builder.buildICmp(llvm.c.LLVMIntEQ, left_tag, right_tag, "opt.eq.tags");

        // Basic blocks
        const tags_match_block = llvm.appendBasicBlock(self.ctx, func, "opt.eq.tags_match");
        const tags_differ_block = llvm.appendBasicBlock(self.ctx, func, "opt.eq.tags_differ");
        const both_some_block = llvm.appendBasicBlock(self.ctx, func, "opt.eq.both_some");
        const both_none_block = llvm.appendBasicBlock(self.ctx, func, "opt.eq.both_none");
        const merge_block = llvm.appendBasicBlock(self.ctx, func, "opt.eq.merge");

        // Branch on tags equality
        _ = self.builder.buildCondBr(tags_equal, tags_match_block, tags_differ_block);

        // Tags differ => false
        self.builder.positionAtEnd(tags_differ_block);
        _ = self.builder.buildBr(merge_block);

        // Tags match => check if both Some or both None
        self.builder.positionAtEnd(tags_match_block);
        _ = self.builder.buildCondBr(left_tag, both_some_block, both_none_block);

        // Both None => true
        self.builder.positionAtEnd(both_none_block);
        _ = self.builder.buildBr(merge_block);

        // Both Some => compare values
        self.builder.positionAtEnd(both_some_block);
        var val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const left_val_ptr = self.builder.buildGEP(opt_type, left_alloca, &val_indices, "opt.eq.left.val.ptr");
        const right_val_ptr = self.builder.buildGEP(opt_type, right_alloca, &val_indices, "opt.eq.right.val.ptr");
        const inner_type = llvm.c.LLVMStructGetTypeAtIndex(opt_type, 1);
        const left_val = self.builder.buildLoad(inner_type, left_val_ptr, "opt.eq.left.val");
        const right_val = self.builder.buildLoad(inner_type, right_val_ptr, "opt.eq.right.val");

        // Compare inner values based on type
        const inner_kind = llvm.c.LLVMGetTypeKind(inner_type);
        const values_equal = switch (inner_kind) {
            llvm.c.LLVMIntegerTypeKind => self.builder.buildICmp(llvm.c.LLVMIntEQ, left_val, right_val, "opt.eq.val"),
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => self.builder.buildFCmp(llvm.c.LLVMRealOEQ, left_val, right_val, "opt.eq.val"),
            llvm.c.LLVMPointerTypeKind => blk: {
                // Likely string - use strcmp
                const strcmp_fn = self.getOrDeclareStrcmp();
                var args = [_]llvm.ValueRef{ left_val, right_val };
                const result = self.builder.buildCall(
                    llvm.c.LLVMGlobalGetValueType(strcmp_fn),
                    strcmp_fn,
                    &args,
                    "opt.eq.strcmp",
                );
                break :blk self.builder.buildICmp(llvm.c.LLVMIntEQ, result, llvm.Const.int32(self.ctx, 0), "opt.eq.str");
            },
            else => llvm.Const.int1(self.ctx, false),
        };
        _ = self.builder.buildBr(merge_block);
        const both_some_end = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Merge block with phi
        self.builder.positionAtEnd(merge_block);
        const phi = self.builder.buildPhi(llvm.Types.int1(self.ctx), "opt.eq.result");
        var incoming_vals = [_]llvm.ValueRef{
            llvm.Const.int1(self.ctx, false), // tags differ
            llvm.Const.int1(self.ctx, true), // both none
            values_equal, // both some
        };
        var incoming_blocks = [_]llvm.c.LLVMBasicBlockRef{
            tags_differ_block,
            both_none_block,
            both_some_end,
        };
        llvm.c.LLVMAddIncoming(phi, &incoming_vals, &incoming_blocks, 3);

        return phi;
    }

    /// Emit Result.eq(other) - compares two results for equality.
    /// Both Ok with equal values => true, both Err with equal values => true, otherwise => false.
    fn emitResultEq(self: *Emitter, left: llvm.ValueRef, right: llvm.ValueRef, result_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store both results for GEP access
        const left_alloca = self.builder.buildAlloca(result_type, "res.eq.left");
        _ = self.builder.buildStore(left, left_alloca);
        const right_alloca = self.builder.buildAlloca(result_type, "res.eq.right");
        _ = self.builder.buildStore(right, right_alloca);

        // Get left tag
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const left_tag_ptr = self.builder.buildGEP(result_type, left_alloca, &tag_indices, "res.eq.left.tag.ptr");
        const left_tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), left_tag_ptr, "res.eq.left.tag");

        // Get right tag
        const right_tag_ptr = self.builder.buildGEP(result_type, right_alloca, &tag_indices, "res.eq.right.tag.ptr");
        const right_tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), right_tag_ptr, "res.eq.right.tag");

        // Check if tags are equal
        const tags_equal = self.builder.buildICmp(llvm.c.LLVMIntEQ, left_tag, right_tag, "res.eq.tags");

        // Basic blocks
        const tags_match_block = llvm.appendBasicBlock(self.ctx, func, "res.eq.tags_match");
        const tags_differ_block = llvm.appendBasicBlock(self.ctx, func, "res.eq.tags_differ");
        const both_ok_block = llvm.appendBasicBlock(self.ctx, func, "res.eq.both_ok");
        const both_err_block = llvm.appendBasicBlock(self.ctx, func, "res.eq.both_err");
        const merge_block = llvm.appendBasicBlock(self.ctx, func, "res.eq.merge");

        // Branch on tags equality
        _ = self.builder.buildCondBr(tags_equal, tags_match_block, tags_differ_block);

        // Tags differ => false
        self.builder.positionAtEnd(tags_differ_block);
        _ = self.builder.buildBr(merge_block);

        // Tags match => check if both Ok or both Err
        self.builder.positionAtEnd(tags_match_block);
        _ = self.builder.buildCondBr(left_tag, both_ok_block, both_err_block);

        // Both Ok => compare ok values
        self.builder.positionAtEnd(both_ok_block);
        var ok_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const left_ok_ptr = self.builder.buildGEP(result_type, left_alloca, &ok_indices, "res.eq.left.ok.ptr");
        const right_ok_ptr = self.builder.buildGEP(result_type, right_alloca, &ok_indices, "res.eq.right.ok.ptr");
        const ok_type = llvm.c.LLVMStructGetTypeAtIndex(result_type, 1);
        const left_ok = self.builder.buildLoad(ok_type, left_ok_ptr, "res.eq.left.ok");
        const right_ok = self.builder.buildLoad(ok_type, right_ok_ptr, "res.eq.right.ok");

        // Compare ok values
        const ok_kind = llvm.c.LLVMGetTypeKind(ok_type);
        const ok_equal = switch (ok_kind) {
            llvm.c.LLVMIntegerTypeKind => self.builder.buildICmp(llvm.c.LLVMIntEQ, left_ok, right_ok, "res.eq.ok"),
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => self.builder.buildFCmp(llvm.c.LLVMRealOEQ, left_ok, right_ok, "res.eq.ok"),
            llvm.c.LLVMPointerTypeKind => blk: {
                const strcmp_fn = self.getOrDeclareStrcmp();
                var args = [_]llvm.ValueRef{ left_ok, right_ok };
                const result = self.builder.buildCall(
                    llvm.c.LLVMGlobalGetValueType(strcmp_fn),
                    strcmp_fn,
                    &args,
                    "res.eq.ok.strcmp",
                );
                break :blk self.builder.buildICmp(llvm.c.LLVMIntEQ, result, llvm.Const.int32(self.ctx, 0), "res.eq.ok.str");
            },
            else => llvm.Const.int1(self.ctx, false),
        };
        _ = self.builder.buildBr(merge_block);
        const both_ok_end = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Both Err => compare err values
        self.builder.positionAtEnd(both_err_block);
        var err_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 2),
        };
        const left_err_ptr = self.builder.buildGEP(result_type, left_alloca, &err_indices, "res.eq.left.err.ptr");
        const right_err_ptr = self.builder.buildGEP(result_type, right_alloca, &err_indices, "res.eq.right.err.ptr");
        const err_type = llvm.c.LLVMStructGetTypeAtIndex(result_type, 2);
        const left_err = self.builder.buildLoad(err_type, left_err_ptr, "res.eq.left.err");
        const right_err = self.builder.buildLoad(err_type, right_err_ptr, "res.eq.right.err");

        // Compare err values
        const err_kind = llvm.c.LLVMGetTypeKind(err_type);
        const err_equal = switch (err_kind) {
            llvm.c.LLVMIntegerTypeKind => self.builder.buildICmp(llvm.c.LLVMIntEQ, left_err, right_err, "res.eq.err"),
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => self.builder.buildFCmp(llvm.c.LLVMRealOEQ, left_err, right_err, "res.eq.err"),
            llvm.c.LLVMPointerTypeKind => blk: {
                const strcmp_fn = self.getOrDeclareStrcmp();
                var args = [_]llvm.ValueRef{ left_err, right_err };
                const result = self.builder.buildCall(
                    llvm.c.LLVMGlobalGetValueType(strcmp_fn),
                    strcmp_fn,
                    &args,
                    "res.eq.err.strcmp",
                );
                break :blk self.builder.buildICmp(llvm.c.LLVMIntEQ, result, llvm.Const.int32(self.ctx, 0), "res.eq.err.str");
            },
            else => llvm.Const.int1(self.ctx, false),
        };
        _ = self.builder.buildBr(merge_block);
        const both_err_end = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Merge block with phi
        self.builder.positionAtEnd(merge_block);
        const phi = self.builder.buildPhi(llvm.Types.int1(self.ctx), "res.eq.result");
        var incoming_vals = [_]llvm.ValueRef{
            llvm.Const.int1(self.ctx, false), // tags differ
            ok_equal, // both ok
            err_equal, // both err
        };
        var incoming_blocks = [_]llvm.c.LLVMBasicBlockRef{
            tags_differ_block,
            both_ok_end,
            both_err_end,
        };
        llvm.c.LLVMAddIncoming(phi, &incoming_vals, &incoming_blocks, 3);

        return phi;
    }

    /// Emit Optional.clone() - returns a clone of the optional.
    /// For value types (integers, floats, bools), this is just a copy.
    fn emitOptionalClone(_: *Emitter, opt_val: llvm.ValueRef, _: llvm.TypeRef) EmitError!llvm.ValueRef {
        // For value types, the optional is already a value - just return it
        // The struct itself is copied (shallow copy), which is correct for primitives
        return opt_val;
    }

    /// Emit Result.clone() - returns a clone of the result.
    /// For value types (integers, floats, bools), this is just a copy.
    fn emitResultClone(_: *Emitter, result_val: llvm.ValueRef, _: llvm.TypeRef) EmitError!llvm.ValueRef {
        // For value types, the result is already a value - just return it
        // The struct itself is copied (shallow copy), which is correct for primitives
        return result_val;
    }

    /// Emit Result.unwrap() / Optional.unwrap() - traps if Err/None, returns value if Ok/Some.
    fn emitResultUnwrap(self: *Emitter, value: llvm.ValueRef, value_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store to temp for GEP access (in entry block to prevent stack growth in loops)
        const val_alloca = self.buildEntryBlockAlloca(value_type, "unwrap.tmp");
        _ = self.builder.buildStore(value, val_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(value_type, val_alloca, &tag_indices, "unwrap.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "unwrap.tag");

        // Get the value (index 1)
        var val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const inner_ptr = self.builder.buildGEP(value_type, val_alloca, &val_indices, "unwrap.val.ptr");
        const inner_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 1);

        const ok_block = llvm.appendBasicBlock(self.ctx, func, "unwrap.ok");
        const fail_block = llvm.appendBasicBlock(self.ctx, func, "unwrap.fail");

        // Branch based on tag
        _ = self.builder.buildCondBr(tag, ok_block, fail_block);

        // Fail block: trap
        self.builder.positionAtEnd(fail_block);
        _ = self.builder.buildUnreachable();

        // Ok block: return value
        self.builder.positionAtEnd(ok_block);
        return self.builder.buildLoad(inner_type, inner_ptr, "unwrap.val");
    }

    /// Emit Result.unwrap_err() - traps if Ok, returns error value if Err.
    fn emitResultUnwrapErr(self: *Emitter, result_val: llvm.ValueRef, result_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store to temp for GEP access
        const result_alloca = self.builder.buildAlloca(result_type, "unwrap_err.tmp");
        _ = self.builder.buildStore(result_val, result_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(result_type, result_alloca, &tag_indices, "unwrap_err.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "unwrap_err.tag");

        // Get the error value (index 2 for Result)
        var err_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 2),
        };
        const err_ptr = self.builder.buildGEP(result_type, result_alloca, &err_indices, "unwrap_err.err.ptr");
        const err_type = llvm.c.LLVMStructGetTypeAtIndex(result_type, 2);

        const err_block = llvm.appendBasicBlock(self.ctx, func, "unwrap_err.err");
        const fail_block = llvm.appendBasicBlock(self.ctx, func, "unwrap_err.fail");

        // Branch based on tag: tag==0 means Err, tag==1 means Ok
        _ = self.builder.buildCondBr(tag, fail_block, err_block);

        // Fail block (Ok case): trap
        self.builder.positionAtEnd(fail_block);
        _ = self.builder.buildUnreachable();

        // Err block: return error value
        self.builder.positionAtEnd(err_block);
        return self.builder.buildLoad(err_type, err_ptr, "unwrap_err.val");
    }

    /// Emit Optional.unwrap_or(default) or Result.unwrap_or(default).
    /// Returns the inner value if Some/Ok, otherwise returns the default value.
    fn emitUnwrapOr(self: *Emitter, value: llvm.ValueRef, value_type: llvm.TypeRef, default_val: llvm.ValueRef) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store to temp for GEP access
        const val_alloca = self.builder.buildAlloca(value_type, "unwrap_or.tmp");
        _ = self.builder.buildStore(value, val_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(value_type, val_alloca, &tag_indices, "unwrap_or.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "unwrap_or.tag");

        // Get the inner value (index 1 for Optional/Result Ok value)
        var val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const inner_ptr = self.builder.buildGEP(value_type, val_alloca, &val_indices, "unwrap_or.val.ptr");
        const inner_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 1);

        // Create basic blocks
        const some_block = llvm.appendBasicBlock(self.ctx, func, "unwrap_or.some");
        const none_block = llvm.appendBasicBlock(self.ctx, func, "unwrap_or.none");
        const merge_block = llvm.appendBasicBlock(self.ctx, func, "unwrap_or.merge");

        // Branch based on tag: tag==1 means Some/Ok, tag==0 means None/Err
        _ = self.builder.buildCondBr(tag, some_block, none_block);

        // Some block: load the inner value
        self.builder.positionAtEnd(some_block);
        const some_val = self.builder.buildLoad(inner_type, inner_ptr, "unwrap_or.inner");
        _ = self.builder.buildBr(merge_block);

        // None block: use default value (already computed)
        self.builder.positionAtEnd(none_block);
        _ = self.builder.buildBr(merge_block);

        // Merge block: phi to select the result
        self.builder.positionAtEnd(merge_block);
        var incoming_values = [_]llvm.ValueRef{ some_val, default_val };
        var incoming_blocks = [_]llvm.BasicBlockRef{ some_block, none_block };
        const result = self.builder.buildPhi(inner_type, "unwrap_or.result");
        llvm.c.LLVMAddIncoming(result, &incoming_values, &incoming_blocks, 2);

        return result;
    }

    /// Emit Result.ok() method - converts Result[T, E] to ?T.
    /// Returns Some(value) if Ok, None if Err.
    fn emitResultOkMethod(self: *Emitter, result_val: llvm.ValueRef, result_type: llvm.TypeRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store Result to temp for GEP access
        const result_alloca = self.builder.buildAlloca(result_type, "result.ok.tmp");
        _ = self.builder.buildStore(result_val, result_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(result_type, result_alloca, &tag_indices, "result.ok.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "result.ok.tag");

        // Get the ok value (index 1)
        var ok_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const ok_ptr = self.builder.buildGEP(result_type, result_alloca, &ok_indices, "result.ok.val.ptr");
        const ok_type = llvm.c.LLVMStructGetTypeAtIndex(result_type, 1);

        // Build Optional type: struct { i1, T } where T is the ok_type
        var opt_field_types = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), ok_type };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_field_types, false);
        _ = method; // Unused, type built from Result's inner type

        // Create basic blocks
        const is_ok_block = llvm.appendBasicBlock(self.ctx, func, "result.ok.some");
        const is_err_block = llvm.appendBasicBlock(self.ctx, func, "result.ok.none");
        const merge_block = llvm.appendBasicBlock(self.ctx, func, "result.ok.merge");

        // Alloca for the optional result
        const opt_alloca = self.builder.buildAlloca(opt_type, "result.ok.opt");

        // Branch based on tag: tag==1 means Ok, tag==0 means Err
        _ = self.builder.buildCondBr(tag, is_ok_block, is_err_block);

        // Ok block: create Some(value)
        self.builder.positionAtEnd(is_ok_block);
        const ok_val = self.builder.buildLoad(ok_type, ok_ptr, "result.ok.inner");
        // Set tag to 1 (Some)
        var opt_tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const opt_tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &opt_tag_indices, "opt.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 1, false), opt_tag_ptr);
        // Set value
        var opt_val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const opt_val_ptr = self.builder.buildGEP(opt_type, opt_alloca, &opt_val_indices, "opt.val.ptr");
        _ = self.builder.buildStore(ok_val, opt_val_ptr);
        _ = self.builder.buildBr(merge_block);

        // Err block: create None
        self.builder.positionAtEnd(is_err_block);
        // Set tag to 0 (None)
        const none_tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &opt_tag_indices, "opt.tag.ptr.none");
        _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 0, false), none_tag_ptr);
        _ = self.builder.buildBr(merge_block);

        // Merge block: load and return the optional
        self.builder.positionAtEnd(merge_block);
        return self.builder.buildLoad(opt_type, opt_alloca, "result.ok.result");
    }

    /// Emit Result.err() method - converts Result[T, E] to ?E.
    /// Returns Some(error) if Err, None if Ok.
    fn emitResultErrMethod(self: *Emitter, result_val: llvm.ValueRef, result_type: llvm.TypeRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store Result to temp for GEP access
        const result_alloca = self.builder.buildAlloca(result_type, "result.err.tmp");
        _ = self.builder.buildStore(result_val, result_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(result_type, result_alloca, &tag_indices, "result.err.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "result.err.tag");

        // Get the err value (index 2)
        var err_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 2),
        };
        const err_ptr = self.builder.buildGEP(result_type, result_alloca, &err_indices, "result.err.val.ptr");
        const err_type = llvm.c.LLVMStructGetTypeAtIndex(result_type, 2);

        // Build Optional type: struct { i1, E } where E is the err_type
        var opt_field_types = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), err_type };
        const opt_type = llvm.Types.struct_(self.ctx, &opt_field_types, false);
        _ = method; // Unused, type built from Result's inner type

        // Create basic blocks
        const is_err_block = llvm.appendBasicBlock(self.ctx, func, "result.err.some");
        const is_ok_block = llvm.appendBasicBlock(self.ctx, func, "result.err.none");
        const merge_block = llvm.appendBasicBlock(self.ctx, func, "result.err.merge");

        // Alloca for the optional result
        const opt_alloca = self.builder.buildAlloca(opt_type, "result.err.opt");

        // Branch based on tag: tag==0 means Err, tag==1 means Ok
        _ = self.builder.buildCondBr(tag, is_ok_block, is_err_block);

        // Err block: create Some(error)
        self.builder.positionAtEnd(is_err_block);
        const err_val = self.builder.buildLoad(err_type, err_ptr, "result.err.inner");
        // Set tag to 1 (Some)
        var opt_tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const opt_tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &opt_tag_indices, "opt.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 1, false), opt_tag_ptr);
        // Set value
        var opt_val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const opt_val_ptr = self.builder.buildGEP(opt_type, opt_alloca, &opt_val_indices, "opt.val.ptr");
        _ = self.builder.buildStore(err_val, opt_val_ptr);
        _ = self.builder.buildBr(merge_block);

        // Ok block: create None
        self.builder.positionAtEnd(is_ok_block);
        // Set tag to 0 (None)
        const none_tag_ptr = self.builder.buildGEP(opt_type, opt_alloca, &opt_tag_indices, "opt.tag.ptr.none");
        _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 0, false), none_tag_ptr);
        _ = self.builder.buildBr(merge_block);

        // Merge block: load and return the optional
        self.builder.positionAtEnd(merge_block);
        return self.builder.buildLoad(opt_type, opt_alloca, "result.err.result");
    }

    /// Emit Optional.map(f) or Result.map(f) - applies f to inner value.
    /// For Optional[T].map(f: fn(T) -> U) -> Optional[U]: Some(v) -> Some(f(v)), None -> None
    /// For Result[T, E].map(f: fn(T) -> U) -> Result[U, E]: Ok(v) -> Ok(f(v)), Err(e) -> Err(e)
    fn emitMapMethod(self: *Emitter, value: llvm.ValueRef, value_type: llvm.TypeRef, func_val: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store value to temp for GEP access
        const val_alloca = self.builder.buildAlloca(value_type, "map.tmp");
        _ = self.builder.buildStore(value, val_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(value_type, val_alloca, &tag_indices, "map.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "map.tag");

        // Get the inner value (index 1 for Optional/Result Ok value)
        var inner_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const inner_ptr = self.builder.buildGEP(value_type, val_alloca, &inner_indices, "map.inner.ptr");
        const inner_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 1);

        // Determine if this is a Result (has 3 fields) or Optional (has 2 fields)
        const num_fields = llvm.c.LLVMCountStructElementTypes(value_type);
        const is_result = num_fields == 3;

        // Create basic blocks
        const some_block = llvm.appendBasicBlock(self.ctx, func, "map.some");
        const none_block = llvm.appendBasicBlock(self.ctx, func, "map.none");
        const merge_block = llvm.appendBasicBlock(self.ctx, func, "map.merge");

        // Branch based on tag
        _ = self.builder.buildCondBr(tag, some_block, none_block);

        // Some/Ok block: call the function and wrap result
        self.builder.positionAtEnd(some_block);
        const inner_val = self.builder.buildLoad(inner_type, inner_ptr, "map.inner");

        // Call the closure with the inner value (map closure returns i32)
        const mapped_val = try self.emitClosureCallWithValue(func_val, inner_val, inner_type, llvm.Types.int32(self.ctx));
        const mapped_type = llvm.c.LLVMTypeOf(mapped_val);

        // Build result type and wrap the mapped value
        var some_result: llvm.ValueRef = undefined;
        var result_type: llvm.TypeRef = undefined;

        if (is_result) {
            // Result: build Result[U, E] with ok_type = mapped_type, err_type unchanged
            const err_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 2);
            var result_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), mapped_type, err_type };
            result_type = llvm.Types.struct_(self.ctx, &result_fields, false);

            // Create Ok(mapped_val)
            const result_alloca = self.builder.buildAlloca(result_type, "map.result.ok");
            var res_tag_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 0),
            };
            const res_tag_ptr = self.builder.buildGEP(result_type, result_alloca, &res_tag_indices, "map.result.tag.ptr");
            _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 1, false), res_tag_ptr);

            var res_val_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 1),
            };
            const res_val_ptr = self.builder.buildGEP(result_type, result_alloca, &res_val_indices, "map.result.val.ptr");
            _ = self.builder.buildStore(mapped_val, res_val_ptr);

            some_result = self.builder.buildLoad(result_type, result_alloca, "map.result.ok.val");
        } else {
            // Optional: build Optional[U]
            var opt_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), mapped_type };
            result_type = llvm.Types.struct_(self.ctx, &opt_fields, false);

            // Create Some(mapped_val)
            some_result = self.emitSome(mapped_val, mapped_type);
        }
        _ = self.builder.buildBr(merge_block);
        const some_end_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // None/Err block: return None or propagate Err
        self.builder.positionAtEnd(none_block);
        var none_result: llvm.ValueRef = undefined;

        if (is_result) {
            // Result: propagate the Err unchanged (but need to build with new ok_type)
            const err_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 2);
            var err_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 2),
            };
            const err_ptr = self.builder.buildGEP(value_type, val_alloca, &err_indices, "map.err.ptr");
            const err_val = self.builder.buildLoad(err_type, err_ptr, "map.err");

            // Create Err(err_val) with new result type
            const result_alloca = self.builder.buildAlloca(result_type, "map.result.err");
            var res_tag_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 0),
            };
            const res_tag_ptr = self.builder.buildGEP(result_type, result_alloca, &res_tag_indices, "map.result.err.tag.ptr");
            _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 0, false), res_tag_ptr);

            var res_err_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 2),
            };
            const res_err_ptr = self.builder.buildGEP(result_type, result_alloca, &res_err_indices, "map.result.err.ptr");
            _ = self.builder.buildStore(err_val, res_err_ptr);

            none_result = self.builder.buildLoad(result_type, result_alloca, "map.result.err.val");
        } else {
            // Optional: return None
            none_result = self.emitNone(result_type);
        }
        _ = self.builder.buildBr(merge_block);
        const none_end_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Merge block
        self.builder.positionAtEnd(merge_block);
        var incoming_vals = [_]llvm.ValueRef{ some_result, none_result };
        var incoming_blocks = [_]llvm.BasicBlockRef{ some_end_block, none_end_block };
        const phi = self.builder.buildPhi(result_type, "map.result");
        llvm.addIncoming(phi, &incoming_vals, &incoming_blocks);

        _ = method; // AST node used for type info if needed
        return phi;
    }

    /// Emit Result.map_err(f) - applies f to error value.
    /// For Result[T, E].map_err(f: fn(E) -> F) -> Result[T, F]: Ok(v) -> Ok(v), Err(e) -> Err(f(e))
    fn emitMapErrMethod(self: *Emitter, value: llvm.ValueRef, value_type: llvm.TypeRef, func_val: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store value to temp for GEP access
        const val_alloca = self.builder.buildAlloca(value_type, "map_err.tmp");
        _ = self.builder.buildStore(value, val_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(value_type, val_alloca, &tag_indices, "map_err.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "map_err.tag");

        // Get the ok value type (index 1) - unchanged in map_err
        const ok_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 1);

        // Get the error value (index 2)
        var err_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 2),
        };
        const err_ptr = self.builder.buildGEP(value_type, val_alloca, &err_indices, "map_err.err.ptr");
        const err_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 2);

        // Create basic blocks
        const ok_block = llvm.appendBasicBlock(self.ctx, func, "map_err.ok");
        const err_block = llvm.appendBasicBlock(self.ctx, func, "map_err.err");
        const merge_block = llvm.appendBasicBlock(self.ctx, func, "map_err.merge");

        // Branch based on tag (1 = Ok, 0 = Err)
        _ = self.builder.buildCondBr(tag, ok_block, err_block);

        // Ok block: propagate Ok unchanged (but need to build with new err_type)
        self.builder.positionAtEnd(ok_block);

        // Get the ok value
        var ok_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const ok_ptr = self.builder.buildGEP(value_type, val_alloca, &ok_indices, "map_err.ok.ptr");
        const ok_val = self.builder.buildLoad(ok_type, ok_ptr, "map_err.ok");

        // Err block: call the function and wrap result
        self.builder.positionAtEnd(err_block);
        const err_val = self.builder.buildLoad(err_type, err_ptr, "map_err.err");

        // Call the closure with the error value
        const mapped_err_val = try self.emitClosureCallWithValue(func_val, err_val, err_type, llvm.Types.int32(self.ctx));
        const mapped_err_type = llvm.c.LLVMTypeOf(mapped_err_val);

        // Build result type: Result[T, F] where T is unchanged, F is the mapped error type
        var result_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), ok_type, mapped_err_type };
        const result_type = llvm.Types.struct_(self.ctx, &result_fields, false);

        // Go back to Ok block and create Ok(ok_val) with new result type
        self.builder.positionAtEnd(ok_block);
        const ok_result_alloca = self.builder.buildAlloca(result_type, "map_err.result.ok");
        var ok_res_tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const ok_res_tag_ptr = self.builder.buildGEP(result_type, ok_result_alloca, &ok_res_tag_indices, "map_err.result.ok.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 1, false), ok_res_tag_ptr);

        var ok_res_val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const ok_res_val_ptr = self.builder.buildGEP(result_type, ok_result_alloca, &ok_res_val_indices, "map_err.result.ok.val.ptr");
        _ = self.builder.buildStore(ok_val, ok_res_val_ptr);

        const ok_result = self.builder.buildLoad(result_type, ok_result_alloca, "map_err.result.ok.val");
        _ = self.builder.buildBr(merge_block);
        const ok_end_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Continue Err block: create Err(mapped_err_val)
        self.builder.positionAtEnd(err_block);
        const err_result_alloca = self.builder.buildAlloca(result_type, "map_err.result.err");
        var err_res_tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const err_res_tag_ptr = self.builder.buildGEP(result_type, err_result_alloca, &err_res_tag_indices, "map_err.result.err.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 0, false), err_res_tag_ptr);

        var err_res_val_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 2),
        };
        const err_res_val_ptr = self.builder.buildGEP(result_type, err_result_alloca, &err_res_val_indices, "map_err.result.err.val.ptr");
        _ = self.builder.buildStore(mapped_err_val, err_res_val_ptr);

        const err_result = self.builder.buildLoad(result_type, err_result_alloca, "map_err.result.err.val");
        _ = self.builder.buildBr(merge_block);
        const err_end_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Merge block
        self.builder.positionAtEnd(merge_block);
        var incoming_vals = [_]llvm.ValueRef{ ok_result, err_result };
        var incoming_blocks = [_]llvm.BasicBlockRef{ ok_end_block, err_end_block };
        const phi = self.builder.buildPhi(result_type, "map_err.result");
        llvm.addIncoming(phi, &incoming_vals, &incoming_blocks);

        _ = method; // AST node used for type info if needed
        return phi;
    }

    /// Emit Optional.and_then(f) or Result.and_then(f) - applies f and flattens.
    /// For Optional[T].and_then(f: fn(T) -> ?U) -> ?U: Some(v) -> f(v), None -> None
    /// For Result[T, E].and_then(f: fn(T) -> Result[U, E]) -> Result[U, E]: Ok(v) -> f(v), Err(e) -> Err(e)
    fn emitAndThenMethod(self: *Emitter, value: llvm.ValueRef, value_type: llvm.TypeRef, func_val: llvm.ValueRef, method: *ast.MethodCall) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store value to temp for GEP access
        const val_alloca = self.builder.buildAlloca(value_type, "and_then.tmp");
        _ = self.builder.buildStore(value, val_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(value_type, val_alloca, &tag_indices, "and_then.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "and_then.tag");

        // Get the inner value (index 1)
        var inner_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const inner_ptr = self.builder.buildGEP(value_type, val_alloca, &inner_indices, "and_then.inner.ptr");
        const inner_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 1);

        // Determine if this is a Result (has 3 fields) or Optional (has 2 fields)
        const num_fields = llvm.c.LLVMCountStructElementTypes(value_type);
        const is_result = num_fields == 3;

        // Create basic blocks
        const some_block = llvm.appendBasicBlock(self.ctx, func, "and_then.some");
        const none_block = llvm.appendBasicBlock(self.ctx, func, "and_then.none");
        const merge_block = llvm.appendBasicBlock(self.ctx, func, "and_then.merge");

        // Branch based on tag
        _ = self.builder.buildCondBr(tag, some_block, none_block);

        // Determine the result type BEFORE branching (for the closure return type)
        // For and_then, the closure returns Optional[U] or Result[U, E]
        // Since we're in the Some/Ok branch, the result type is the same structure as input
        // but possibly with different inner type U
        var result_type: llvm.TypeRef = undefined;
        if (is_result) {
            // Result[U, E] - for now assume U is i32 (same as original ok_type)
            const err_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 2);
            var result_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), llvm.Types.int32(self.ctx), err_type };
            result_type = llvm.Types.struct_(self.ctx, &result_fields, false);
        } else {
            // Optional[U] - for now assume U is i32
            var opt_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), llvm.Types.int32(self.ctx) };
            result_type = llvm.Types.struct_(self.ctx, &opt_fields, false);
        }

        // Some/Ok block: call the function (result is already Optional/Result)
        self.builder.positionAtEnd(some_block);
        const inner_val = self.builder.buildLoad(inner_type, inner_ptr, "and_then.inner");

        // Call the closure - returns the new Optional/Result directly
        const func_result = try self.emitClosureCallWithValue(func_val, inner_val, inner_type, result_type);
        _ = self.builder.buildBr(merge_block);
        const some_end_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // None/Err block: return None or propagate Err
        self.builder.positionAtEnd(none_block);
        var none_result: llvm.ValueRef = undefined;

        if (is_result) {
            // Result: propagate the Err with the new result type
            const err_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 2);
            var err_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 2),
            };
            const err_ptr = self.builder.buildGEP(value_type, val_alloca, &err_indices, "and_then.err.ptr");
            const err_val = self.builder.buildLoad(err_type, err_ptr, "and_then.err");

            // Create Err with result_type (already computed above)
            const result_alloca = self.builder.buildAlloca(result_type, "and_then.result.err");
            var res_tag_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 0),
            };
            const res_tag_ptr = self.builder.buildGEP(result_type, result_alloca, &res_tag_indices, "and_then.result.err.tag.ptr");
            _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 0, false), res_tag_ptr);

            var res_err_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 2),
            };
            const res_err_ptr = self.builder.buildGEP(result_type, result_alloca, &res_err_indices, "and_then.result.err.ptr");
            _ = self.builder.buildStore(err_val, res_err_ptr);

            none_result = self.builder.buildLoad(result_type, result_alloca, "and_then.result.err.val");
        } else {
            // Optional: return None of the result type
            none_result = self.emitNone(result_type);
        }
        _ = self.builder.buildBr(merge_block);
        const none_end_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Merge block
        self.builder.positionAtEnd(merge_block);
        var incoming_vals = [_]llvm.ValueRef{ func_result, none_result };
        var incoming_blocks = [_]llvm.BasicBlockRef{ some_end_block, none_end_block };
        const phi = self.builder.buildPhi(result_type, "and_then.result");
        llvm.addIncoming(phi, &incoming_vals, &incoming_blocks);

        _ = method; // AST node for type info if needed
        return phi;
    }

    /// Helper to call a closure with a single value argument.
    /// return_type: the expected return type of the closure (use int32 for map, Optional/Result for and_then)
    fn emitClosureCallWithValue(self: *Emitter, closure_val: llvm.ValueRef, arg_val: llvm.ValueRef, arg_type: llvm.TypeRef, return_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        const closure_struct_type = self.getClosureStructType();

        // Allocate space to store the closure value
        const closure_alloca = self.builder.buildAlloca(closure_struct_type, "map.closure.tmp");
        _ = self.builder.buildStore(closure_val, closure_alloca);

        // Load function pointer
        var fn_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const fn_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &fn_ptr_indices, "map.fn.ptr.ptr");
        const fn_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), fn_ptr_gep, "map.fn.ptr");

        // Load environment pointer
        var env_ptr_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const env_ptr_gep = self.builder.buildGEP(closure_struct_type, closure_alloca, &env_ptr_indices, "map.env.ptr.ptr");
        const env_ptr = self.builder.buildLoad(llvm.Types.pointer(self.ctx), env_ptr_gep, "map.env.ptr");

        // Build call args: env_ptr + arg_val
        var call_args = [_]llvm.ValueRef{ env_ptr, arg_val };

        // Build function type: fn(ptr, arg_type) -> return_type
        var param_types = [_]llvm.TypeRef{ llvm.Types.pointer(self.ctx), arg_type };
        const fn_type = llvm.Types.function(return_type, &param_types, false);

        return self.builder.buildCall(fn_type, fn_ptr, &call_args, "map.closure.call");
    }

    /// Emit Result.context(msg) - wraps error with context message.
    /// For Result[T, E].context(msg: string) -> Result[T, ContextError[E]]: Ok(v) -> Ok(v), Err(e) -> Err(ContextError{msg, e})
    /// In debug mode, captures file:line:column location of the .context() call.
    fn emitContextMethod(self: *Emitter, value: llvm.ValueRef, value_type: llvm.TypeRef, msg_val: llvm.ValueRef, span: ast.Span) EmitError!llvm.ValueRef {
        const func = self.current_function orelse return EmitError.InvalidAST;

        // Store value to temp for GEP access
        const val_alloca = self.builder.buildAlloca(value_type, "context.tmp");
        _ = self.builder.buildStore(value, val_alloca);

        // Get the tag (index 0)
        var tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const tag_ptr = self.builder.buildGEP(value_type, val_alloca, &tag_indices, "context.tag.ptr");
        const tag = self.builder.buildLoad(llvm.Types.int1(self.ctx), tag_ptr, "context.tag");

        // Get the ok value (index 1)
        const ok_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 1);
        var ok_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const ok_ptr = self.builder.buildGEP(value_type, val_alloca, &ok_indices, "context.ok.ptr");

        // Get the err value (index 2)
        const err_type = llvm.c.LLVMStructGetTypeAtIndex(value_type, 2);
        var err_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 2),
        };
        const err_ptr = self.builder.buildGEP(value_type, val_alloca, &err_indices, "context.err.ptr");

        // ContextError[E] layout: { message: ptr, cause: E, file: ptr, line: i32, column: i32 }
        // In debug mode, file/line/column are populated; in release, file=null, line=0, column=0
        var context_err_fields = [_]llvm.TypeRef{
            llvm.Types.pointer(self.ctx), // message
            err_type, // cause
            llvm.Types.pointer(self.ctx), // file
            llvm.Types.int32(self.ctx), // line
            llvm.Types.int32(self.ctx), // column
        };
        const context_err_type = llvm.Types.struct_(self.ctx, &context_err_fields, false);

        // Result[T, ContextError[E]] layout: { tag: i1, ok_value: T, err_value: ContextError[E] }
        var result_fields = [_]llvm.TypeRef{ llvm.Types.int1(self.ctx), ok_type, context_err_type };
        const result_type = llvm.Types.struct_(self.ctx, &result_fields, false);

        // Allocate result
        const result_alloca = self.builder.buildAlloca(result_type, "context.result");

        // Create basic blocks
        const ok_block = llvm.appendBasicBlock(self.ctx, func, "context.ok");
        const err_block = llvm.appendBasicBlock(self.ctx, func, "context.err");
        const merge_block = llvm.appendBasicBlock(self.ctx, func, "context.merge");

        // Branch based on tag (1 = Ok, 0 = Err)
        _ = self.builder.buildCondBr(tag, ok_block, err_block);

        // Ok block: create Ok(v) with new result type
        self.builder.positionAtEnd(ok_block);
        const ok_val = self.builder.buildLoad(ok_type, ok_ptr, "context.ok.val");

        // Set tag to 1 (Ok)
        var res_tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const res_tag_ptr = self.builder.buildGEP(result_type, result_alloca, &res_tag_indices, "context.result.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 1, false), res_tag_ptr);

        // Store ok value
        var res_ok_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const res_ok_ptr = self.builder.buildGEP(result_type, result_alloca, &res_ok_indices, "context.result.ok.ptr");
        _ = self.builder.buildStore(ok_val, res_ok_ptr);

        const ok_result = self.builder.buildLoad(result_type, result_alloca, "context.result.ok");
        _ = self.builder.buildBr(merge_block);
        const ok_end_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Err block: create Err(ContextError{msg, e})
        self.builder.positionAtEnd(err_block);
        const err_val = self.builder.buildLoad(err_type, err_ptr, "context.err.val");

        // Allocate a new result for the error case
        const err_result_alloca = self.builder.buildAlloca(result_type, "context.result.err.alloca");

        // Allocate ContextError
        const ctx_err_alloca = self.builder.buildAlloca(context_err_type, "context.ctx_err");

        // Store message (index 0)
        var ctx_msg_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const ctx_msg_ptr = self.builder.buildGEP(context_err_type, ctx_err_alloca, &ctx_msg_indices, "context.ctx_err.msg.ptr");
        _ = self.builder.buildStore(msg_val, ctx_msg_ptr);

        // Store cause (index 1)
        var ctx_cause_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const ctx_cause_ptr = self.builder.buildGEP(context_err_type, ctx_err_alloca, &ctx_cause_indices, "context.ctx_err.cause.ptr");
        _ = self.builder.buildStore(err_val, ctx_cause_ptr);

        // Store file (index 2) - null in release, filename in debug
        var ctx_file_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 2),
        };
        const ctx_file_ptr = self.builder.buildGEP(context_err_type, ctx_err_alloca, &ctx_file_indices, "context.ctx_err.file.ptr");
        const file_val = if (self.source_filename) |filename|
            self.builder.buildGlobalStringPtr(filename, "context.file")
        else
            llvm.Const.null_(llvm.Types.pointer(self.ctx));
        _ = self.builder.buildStore(file_val, ctx_file_ptr);

        // Store line (index 3) - 0 in release, actual line in debug
        var ctx_line_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 3),
        };
        const ctx_line_ptr = self.builder.buildGEP(context_err_type, ctx_err_alloca, &ctx_line_indices, "context.ctx_err.line.ptr");
        const line_val = if (self.source_filename != null)
            llvm.Const.int32(self.ctx, @intCast(span.line))
        else
            llvm.Const.int32(self.ctx, 0);
        _ = self.builder.buildStore(line_val, ctx_line_ptr);

        // Store column (index 4) - 0 in release, actual column in debug
        var ctx_col_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 4),
        };
        const ctx_col_ptr = self.builder.buildGEP(context_err_type, ctx_err_alloca, &ctx_col_indices, "context.ctx_err.col.ptr");
        const col_val = if (self.source_filename != null)
            llvm.Const.int32(self.ctx, @intCast(span.column))
        else
            llvm.Const.int32(self.ctx, 0);
        _ = self.builder.buildStore(col_val, ctx_col_ptr);

        // Load the ContextError
        const ctx_err_val = self.builder.buildLoad(context_err_type, ctx_err_alloca, "context.ctx_err.val");

        // Set tag to 0 (Err) - compute GEP in this block
        var err_res_tag_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const err_res_tag_ptr = self.builder.buildGEP(result_type, err_result_alloca, &err_res_tag_indices, "context.result.err.tag.ptr");
        _ = self.builder.buildStore(llvm.Const.int(llvm.Types.int1(self.ctx), 0, false), err_res_tag_ptr);

        // Store ContextError as err value
        var res_err_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 2),
        };
        const res_err_ptr = self.builder.buildGEP(result_type, err_result_alloca, &res_err_indices, "context.result.err.ptr");
        _ = self.builder.buildStore(ctx_err_val, res_err_ptr);

        const err_result = self.builder.buildLoad(result_type, err_result_alloca, "context.result.err");
        _ = self.builder.buildBr(merge_block);
        const err_end_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        // Merge block
        self.builder.positionAtEnd(merge_block);
        var incoming_vals = [_]llvm.ValueRef{ ok_result, err_result };
        var incoming_blocks = [_]llvm.BasicBlockRef{ ok_end_block, err_end_block };
        const phi = self.builder.buildPhi(result_type, "context.result");
        llvm.addIncoming(phi, &incoming_vals, &incoming_blocks);

        return phi;
    }

    /// Emit ContextError.message() - returns the context message string.
    fn emitContextErrorMessage(self: *Emitter, ctx_err_val: llvm.ValueRef, ctx_err_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        // Store ContextError to temp for GEP access
        const ctx_err_alloca = self.builder.buildAlloca(ctx_err_type, "ctx_err.msg.tmp");
        _ = self.builder.buildStore(ctx_err_val, ctx_err_alloca);

        // Get message (index 0)
        var msg_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const msg_ptr = self.builder.buildGEP(ctx_err_type, ctx_err_alloca, &msg_indices, "ctx_err.msg.ptr");
        return self.builder.buildLoad(llvm.Types.pointer(self.ctx), msg_ptr, "ctx_err.msg");
    }

    /// Emit ContextError.cause() - returns the original error.
    fn emitContextErrorCause(self: *Emitter, ctx_err_val: llvm.ValueRef, ctx_err_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        // Store ContextError to temp for GEP access
        const ctx_err_alloca = self.builder.buildAlloca(ctx_err_type, "ctx_err.cause.tmp");
        _ = self.builder.buildStore(ctx_err_val, ctx_err_alloca);

        // Get cause (index 1)
        var cause_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const cause_type = llvm.c.LLVMStructGetTypeAtIndex(ctx_err_type, 1);
        const cause_ptr = self.builder.buildGEP(ctx_err_type, ctx_err_alloca, &cause_indices, "ctx_err.cause.ptr");
        return self.builder.buildLoad(cause_type, cause_ptr, "ctx_err.cause");
    }

    /// Emit ContextError.display_chain() - returns formatted error chain as string.
    /// Uses snprintf to build "Error: msg1\n  Caused by: msg2\n  Caused by: root"
    fn emitContextErrorDisplayChain(self: *Emitter, ctx_err_val: llvm.ValueRef, ctx_err_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i8_type = llvm.Types.int8(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx);

        // Helper function to check if a type is a ContextError (struct with 5 fields, first is pointer)
        // ContextError layout: { message: ptr, cause: E, file: ptr, line: i32, column: i32 }
        const isContextErrorType = struct {
            fn check(ty: llvm.TypeRef) bool {
                if (llvm.c.LLVMGetTypeKind(ty) != llvm.c.LLVMStructTypeKind) return false;
                if (llvm.c.LLVMCountStructElementTypes(ty) != 5) return false;
                const first = llvm.c.LLVMStructGetTypeAtIndex(ty, 0);
                return llvm.c.LLVMGetTypeKind(first) == llvm.c.LLVMPointerTypeKind;
            }
        }.check;

        // Count nesting depth using LLVM type info
        var nesting_depth: usize = 0;
        var current_llvm_type = ctx_err_type;
        while (isContextErrorType(current_llvm_type)) {
            nesting_depth += 1;
            current_llvm_type = llvm.c.LLVMStructGetTypeAtIndex(current_llvm_type, 1);
        }

        // Allocate a buffer (1024 bytes should be enough for most error chains)
        const buffer_size: u64 = 1024;
        const buffer_type = llvm.Types.array(i8_type, buffer_size);
        const buffer = self.builder.buildAlloca(buffer_type, "display_chain.buf");

        // Get pointer to buffer start
        var buf_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        const buffer_ptr = self.builder.buildGEP(buffer_type, buffer, &buf_indices, "display_chain.buf_ptr");

        // Track current position in buffer
        const offset_alloca = self.builder.buildAlloca(i64_type, "display_chain.offset");
        _ = self.builder.buildStore(llvm.Const.int64(self.ctx, 0), offset_alloca);

        // Helper to append a string to the buffer
        const snprintf_fn = self.getOrDeclareSnprintf();
        const snprintf_type = llvm.c.LLVMGlobalGetValueType(snprintf_fn);

        // Format strings
        const error_prefix = self.builder.buildGlobalStringPtr("Error: %s", "display_chain.prefix");
        const location_fmt = self.builder.buildGlobalStringPtr(" (at %s:%d:%d)", "display_chain.loc_fmt");
        const i32_type = llvm.Types.int32(self.ctx);
        var current_ctx_err_type = ctx_err_type;

        // Store the ContextError for GEP access
        var ctx_err_alloca = self.builder.buildAlloca(ctx_err_type, "display_chain.ctx_err");
        _ = self.builder.buildStore(ctx_err_val, ctx_err_alloca);

        // Get first message
        var msg_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 0),
        };
        var msg_ptr = self.builder.buildGEP(current_ctx_err_type, ctx_err_alloca, &msg_indices, "display_chain.msg_ptr");
        var current_msg = self.builder.buildLoad(ptr_type, msg_ptr, "display_chain.msg");

        // Write "Error: <first_message>"
        var curr_offset = self.builder.buildLoad(i64_type, offset_alloca, "display_chain.curr_offset");
        var remaining = self.builder.buildSub(
            llvm.Const.int64(self.ctx, @intCast(buffer_size)),
            curr_offset,
            "display_chain.remaining",
        );
        var dest_ptr = self.builder.buildGEP(i8_type, buffer_ptr, &[_]llvm.ValueRef{curr_offset}, "display_chain.dest_ptr");

        var snprintf_args = [_]llvm.ValueRef{ dest_ptr, remaining, error_prefix, current_msg };
        var written = self.builder.buildCall(snprintf_type, snprintf_fn, &snprintf_args, "display_chain.written");

        // Update offset (extend written from i32 to i64)
        var written_ext = llvm.c.LLVMBuildSExt(self.builder.ref, written, i64_type, "display_chain.written_ext");
        curr_offset = self.builder.buildLoad(i64_type, offset_alloca, "display_chain.curr_offset2");
        var new_offset = self.builder.buildAdd(curr_offset, written_ext, "display_chain.new_offset");
        _ = self.builder.buildStore(new_offset, offset_alloca);

        // Get file/line/column from first ContextError and append location if file is non-null
        var file_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 2) };
        var file_ptr = self.builder.buildGEP(current_ctx_err_type, ctx_err_alloca, &file_indices, "display_chain.file_ptr");
        var file_val = self.builder.buildLoad(ptr_type, file_ptr, "display_chain.file");
        var line_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 3) };
        var line_ptr = self.builder.buildGEP(current_ctx_err_type, ctx_err_alloca, &line_indices, "display_chain.line_ptr");
        var line_val = self.builder.buildLoad(i32_type, line_ptr, "display_chain.line");
        var col_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 4) };
        var col_ptr = self.builder.buildGEP(current_ctx_err_type, ctx_err_alloca, &col_indices, "display_chain.col_ptr");
        var col_val = self.builder.buildLoad(i32_type, col_ptr, "display_chain.col");

        // Check if file is non-null
        const null_ptr = llvm.Const.null_(ptr_type);
        var has_loc = self.builder.buildICmp(llvm.c.LLVMIntNE, file_val, null_ptr, "display_chain.has_loc");

        // Create blocks for conditional location output
        const func = self.current_function orelse return EmitError.InvalidAST;
        var loc_block = llvm.appendBasicBlock(self.ctx, func, "display_chain.loc");
        var no_loc_block = llvm.appendBasicBlock(self.ctx, func, "display_chain.no_loc");
        _ = self.builder.buildCondBr(has_loc, loc_block, no_loc_block);

        // Block: write location
        self.builder.positionAtEnd(loc_block);
        curr_offset = self.builder.buildLoad(i64_type, offset_alloca, "display_chain.curr_offset_loc");
        remaining = self.builder.buildSub(llvm.Const.int64(self.ctx, @intCast(buffer_size)), curr_offset, "display_chain.remaining_loc");
        dest_ptr = self.builder.buildGEP(i8_type, buffer_ptr, &[_]llvm.ValueRef{curr_offset}, "display_chain.dest_ptr_loc");
        var loc_args = [_]llvm.ValueRef{ dest_ptr, remaining, location_fmt, file_val, line_val, col_val };
        written = self.builder.buildCall(snprintf_type, snprintf_fn, &loc_args, "display_chain.written_loc");
        written_ext = llvm.c.LLVMBuildSExt(self.builder.ref, written, i64_type, "display_chain.written_ext_loc");
        curr_offset = self.builder.buildLoad(i64_type, offset_alloca, "display_chain.curr_offset_loc2");
        new_offset = self.builder.buildAdd(curr_offset, written_ext, "display_chain.new_offset_loc");
        _ = self.builder.buildStore(new_offset, offset_alloca);
        _ = self.builder.buildBr(no_loc_block);

        // Continue from no_loc_block
        self.builder.positionAtEnd(no_loc_block);

        // Format string for subsequent causes
        const caused_by_fmt = self.builder.buildGlobalStringPtr("\n  Caused by: %s", "display_chain.caused_by");

        // Now traverse each nested ContextError level
        var depth: usize = 1;
        while (depth < nesting_depth) : (depth += 1) {
            // Get cause from current ContextError
            var cause_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 1),
            };
            const cause_type = llvm.c.LLVMStructGetTypeAtIndex(current_ctx_err_type, 1);
            const cause_ptr = self.builder.buildGEP(current_ctx_err_type, ctx_err_alloca, &cause_indices, "display_chain.cause_ptr");
            const cause_val = self.builder.buildLoad(cause_type, cause_ptr, "display_chain.cause");

            // Store the inner ContextError
            current_ctx_err_type = cause_type;
            ctx_err_alloca = self.builder.buildAlloca(cause_type, "display_chain.inner_ctx_err");
            _ = self.builder.buildStore(cause_val, ctx_err_alloca);

            // Get message from inner ContextError
            msg_indices = [_]llvm.ValueRef{
                llvm.Const.int32(self.ctx, 0),
                llvm.Const.int32(self.ctx, 0),
            };
            msg_ptr = self.builder.buildGEP(cause_type, ctx_err_alloca, &msg_indices, "display_chain.inner_msg_ptr");
            current_msg = self.builder.buildLoad(ptr_type, msg_ptr, "display_chain.inner_msg");

            // Write "\n  Caused by: <message>"
            curr_offset = self.builder.buildLoad(i64_type, offset_alloca, "display_chain.curr_offset3");
            remaining = self.builder.buildSub(
                llvm.Const.int64(self.ctx, @intCast(buffer_size)),
                curr_offset,
                "display_chain.remaining2",
            );
            dest_ptr = self.builder.buildGEP(i8_type, buffer_ptr, &[_]llvm.ValueRef{curr_offset}, "display_chain.dest_ptr2");

            snprintf_args = [_]llvm.ValueRef{ dest_ptr, remaining, caused_by_fmt, current_msg };
            written = self.builder.buildCall(snprintf_type, snprintf_fn, &snprintf_args, "display_chain.written2");

            // Update offset
            written_ext = llvm.c.LLVMBuildSExt(self.builder.ref, written, i64_type, "display_chain.written_ext2");
            curr_offset = self.builder.buildLoad(i64_type, offset_alloca, "display_chain.curr_offset4");
            new_offset = self.builder.buildAdd(curr_offset, written_ext, "display_chain.new_offset2");
            _ = self.builder.buildStore(new_offset, offset_alloca);

            // Get file/line/column from this ContextError and append location if file is non-null
            file_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 2) };
            file_ptr = self.builder.buildGEP(current_ctx_err_type, ctx_err_alloca, &file_indices, "display_chain.inner_file_ptr");
            file_val = self.builder.buildLoad(ptr_type, file_ptr, "display_chain.inner_file");
            line_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 3) };
            line_ptr = self.builder.buildGEP(current_ctx_err_type, ctx_err_alloca, &line_indices, "display_chain.inner_line_ptr");
            line_val = self.builder.buildLoad(i32_type, line_ptr, "display_chain.inner_line");
            col_indices = [_]llvm.ValueRef{ llvm.Const.int32(self.ctx, 0), llvm.Const.int32(self.ctx, 4) };
            col_ptr = self.builder.buildGEP(current_ctx_err_type, ctx_err_alloca, &col_indices, "display_chain.inner_col_ptr");
            col_val = self.builder.buildLoad(i32_type, col_ptr, "display_chain.inner_col");

            // Check if file is non-null
            has_loc = self.builder.buildICmp(llvm.c.LLVMIntNE, file_val, null_ptr, "display_chain.inner_has_loc");

            // Create blocks for conditional location output
            loc_block = llvm.appendBasicBlock(self.ctx, func, "display_chain.inner_loc");
            no_loc_block = llvm.appendBasicBlock(self.ctx, func, "display_chain.inner_no_loc");
            _ = self.builder.buildCondBr(has_loc, loc_block, no_loc_block);

            // Block: write location
            self.builder.positionAtEnd(loc_block);
            curr_offset = self.builder.buildLoad(i64_type, offset_alloca, "display_chain.inner_curr_offset_loc");
            remaining = self.builder.buildSub(llvm.Const.int64(self.ctx, @intCast(buffer_size)), curr_offset, "display_chain.inner_remaining_loc");
            dest_ptr = self.builder.buildGEP(i8_type, buffer_ptr, &[_]llvm.ValueRef{curr_offset}, "display_chain.inner_dest_ptr_loc");
            loc_args = [_]llvm.ValueRef{ dest_ptr, remaining, location_fmt, file_val, line_val, col_val };
            written = self.builder.buildCall(snprintf_type, snprintf_fn, &loc_args, "display_chain.inner_written_loc");
            written_ext = llvm.c.LLVMBuildSExt(self.builder.ref, written, i64_type, "display_chain.inner_written_ext_loc");
            curr_offset = self.builder.buildLoad(i64_type, offset_alloca, "display_chain.inner_curr_offset_loc2");
            new_offset = self.builder.buildAdd(curr_offset, written_ext, "display_chain.inner_new_offset_loc");
            _ = self.builder.buildStore(new_offset, offset_alloca);
            _ = self.builder.buildBr(no_loc_block);

            // Continue from no_loc_block
            self.builder.positionAtEnd(no_loc_block);
        }

        // Finally, write the root cause
        // Get cause from the innermost ContextError
        var cause_indices = [_]llvm.ValueRef{
            llvm.Const.int32(self.ctx, 0),
            llvm.Const.int32(self.ctx, 1),
        };
        const final_cause_type = llvm.c.LLVMStructGetTypeAtIndex(current_ctx_err_type, 1);
        const final_cause_ptr = self.builder.buildGEP(current_ctx_err_type, ctx_err_alloca, &cause_indices, "display_chain.final_cause_ptr");
        const root_cause = self.builder.buildLoad(final_cause_type, final_cause_ptr, "display_chain.root_cause");

        // Determine how to format the root cause based on its type
        // For now, assume it's a string (most common case)
        curr_offset = self.builder.buildLoad(i64_type, offset_alloca, "display_chain.curr_offset5");
        remaining = self.builder.buildSub(
            llvm.Const.int64(self.ctx, @intCast(buffer_size)),
            curr_offset,
            "display_chain.remaining3",
        );
        dest_ptr = self.builder.buildGEP(i8_type, buffer_ptr, &[_]llvm.ValueRef{curr_offset}, "display_chain.dest_ptr3");

        snprintf_args = [_]llvm.ValueRef{ dest_ptr, remaining, caused_by_fmt, root_cause };
        _ = self.builder.buildCall(snprintf_type, snprintf_fn, &snprintf_args, "display_chain.written3");

        // Allocate the result string on the heap using strdup
        const strdup_fn = self.getOrDeclareStrdup();
        var strdup_args = [_]llvm.ValueRef{buffer_ptr};
        return self.builder.buildCall(
            llvm.c.LLVMGlobalGetValueType(strdup_fn),
            strdup_fn,
            &strdup_args,
            "display_chain.result",
        );
    }

    /// Emit the Eq trait's eq() method for equality comparison.
    /// Works for primitives (integers, floats, bools, chars, strings).
    fn emitEqMethod(self: *Emitter, method: *ast.MethodCall, left: llvm.ValueRef, left_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        // Get the other argument
        if (method.args.len != 1) {
            return EmitError.InvalidAST;
        }

        var right = try self.emitExpr(method.args[0]);

        // Dispatch based on the LLVM type kind of the left operand
        const left_kind = llvm.c.LLVMGetTypeKind(left_type);

        // For non-pointer primitives (int, float, bool), if the right side is
        // a pointer (reference), dereference it. But for pointers (strings),
        // don't dereference - the pointer IS the value.
        if (left_kind != llvm.c.LLVMPointerTypeKind) {
            const right_type = llvm.typeOf(right);
            const right_kind = llvm.c.LLVMGetTypeKind(right_type);
            if (right_kind == llvm.c.LLVMPointerTypeKind) {
                // Dereference the pointer to get the actual value
                right = self.builder.buildLoad(left_type, right, "eq.deref");
            }
        }

        switch (left_kind) {
            llvm.c.LLVMIntegerTypeKind => {
                // Integer or bool comparison
                return self.builder.buildICmp(llvm.c.LLVMIntEQ, left, right, "eq.int");
            },
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => {
                // Float comparison (OEQ = ordered equal)
                return self.builder.buildFCmp(llvm.c.LLVMRealOEQ, left, right, "eq.float");
            },
            llvm.c.LLVMPointerTypeKind => {
                // This is likely a string (char*) - use strcmp
                const strcmp_fn = self.getOrDeclareStrcmp();
                var args = [_]llvm.ValueRef{ left, right };
                const result = self.builder.buildCall(
                    llvm.c.LLVMGlobalGetValueType(strcmp_fn),
                    strcmp_fn,
                    &args,
                    "eq.strcmp.result",
                );
                // strcmp returns 0 if equal, so compare result == 0
                return self.builder.buildICmp(
                    llvm.c.LLVMIntEQ,
                    result,
                    llvm.Const.int32(self.ctx, 0),
                    "eq.str",
                );
            },
            llvm.c.LLVMStructTypeKind => {
                // Check if this is Optional (2 fields) or Result (3 fields)
                const num_fields = llvm.c.LLVMCountStructElementTypes(left_type);
                if (num_fields == 2) {
                    // Optional[T] - compare: both None = true, both Some with equal values = true
                    return self.emitOptionalEq(left, right, left_type);
                } else if (num_fields == 3) {
                    // Result[T, E] - compare: both Ok with equal values = true, both Err with equal values = true
                    return self.emitResultEq(left, right, left_type);
                }
                // For user-defined structs, we need to call the user-defined eq method
                // This should be handled by the user-defined method lookup before we get here
                // For now, fall through to placeholder
                return llvm.Const.int1(self.ctx, false);
            },
            else => {
                // Unsupported type - return false
                return llvm.Const.int1(self.ctx, false);
            },
        }
    }

    /// Emit the Ordered trait's comparison methods (lt, le, gt, ge).
    /// Works for primitives (integers, floats, strings).
    fn emitOrderedMethod(self: *Emitter, method: *ast.MethodCall, left: llvm.ValueRef, left_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        // Get the other argument
        if (method.args.len != 1) {
            return EmitError.InvalidAST;
        }

        var right = try self.emitExpr(method.args[0]);

        // Dispatch based on the LLVM type kind of the left operand
        const left_kind = llvm.c.LLVMGetTypeKind(left_type);

        // For non-pointer primitives (int, float), if the right side is
        // a pointer (reference), dereference it. But for pointers (strings),
        // don't dereference - the pointer IS the value.
        if (left_kind != llvm.c.LLVMPointerTypeKind) {
            const right_type = llvm.typeOf(right);
            const right_kind = llvm.c.LLVMGetTypeKind(right_type);
            if (right_kind == llvm.c.LLVMPointerTypeKind) {
                // Dereference the pointer to get the actual value
                right = self.builder.buildLoad(left_type, right, "ord.deref");
            }
        }

        // Determine the comparison predicate based on method name
        const method_name = method.method_name;

        switch (left_kind) {
            llvm.c.LLVMIntegerTypeKind => {
                // Integer comparison (signed)
                const predicate: llvm.c.LLVMIntPredicate = if (std.mem.eql(u8, method_name, "lt"))
                    llvm.c.LLVMIntSLT
                else if (std.mem.eql(u8, method_name, "le"))
                    llvm.c.LLVMIntSLE
                else if (std.mem.eql(u8, method_name, "gt"))
                    llvm.c.LLVMIntSGT
                else // ge
                    llvm.c.LLVMIntSGE;
                return self.builder.buildICmp(predicate, left, right, "ord.int");
            },
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => {
                // Float comparison (ordered)
                const predicate: llvm.c.LLVMRealPredicate = if (std.mem.eql(u8, method_name, "lt"))
                    llvm.c.LLVMRealOLT
                else if (std.mem.eql(u8, method_name, "le"))
                    llvm.c.LLVMRealOLE
                else if (std.mem.eql(u8, method_name, "gt"))
                    llvm.c.LLVMRealOGT
                else // ge
                    llvm.c.LLVMRealOGE;
                return self.builder.buildFCmp(predicate, left, right, "ord.float");
            },
            llvm.c.LLVMPointerTypeKind => {
                // This is likely a string (char*) - use strcmp
                const strcmp_fn = self.getOrDeclareStrcmp();
                var args = [_]llvm.ValueRef{ left, right };
                const result = self.builder.buildCall(
                    llvm.c.LLVMGlobalGetValueType(strcmp_fn),
                    strcmp_fn,
                    &args,
                    "ord.strcmp.result",
                );
                // strcmp returns: negative if s1 < s2, 0 if equal, positive if s1 > s2
                // lt: result < 0
                // le: result <= 0
                // gt: result > 0
                // ge: result >= 0
                const predicate: llvm.c.LLVMIntPredicate = if (std.mem.eql(u8, method_name, "lt"))
                    llvm.c.LLVMIntSLT
                else if (std.mem.eql(u8, method_name, "le"))
                    llvm.c.LLVMIntSLE
                else if (std.mem.eql(u8, method_name, "gt"))
                    llvm.c.LLVMIntSGT
                else // ge
                    llvm.c.LLVMIntSGE;
                return self.builder.buildICmp(
                    predicate,
                    result,
                    llvm.Const.int32(self.ctx, 0),
                    "ord.str",
                );
            },
            llvm.c.LLVMStructTypeKind => {
                // For structs that implement Ordered, we need to call the user-defined method
                // This should be handled by the user-defined method lookup before we get here
                // For now, fall through to placeholder
                return llvm.Const.int1(self.ctx, false);
            },
            else => {
                // Unsupported type - return false
                return llvm.Const.int1(self.ctx, false);
            },
        }
    }

    /// Emit the Clone trait's clone() method for explicit cloning.
    /// Works for primitives (integers, floats, bools, chars) and strings.
    fn emitCloneMethod(self: *Emitter, method: *ast.MethodCall, value: llvm.ValueRef, value_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = method; // clone() takes no arguments

        // Dispatch based on the LLVM type kind
        const kind = llvm.c.LLVMGetTypeKind(value_type);

        switch (kind) {
            llvm.c.LLVMIntegerTypeKind => {
                // Integers and bools are value types - cloning is just returning the value
                return value;
            },
            llvm.c.LLVMFloatTypeKind, llvm.c.LLVMDoubleTypeKind => {
                // Floats are value types - cloning is just returning the value
                return value;
            },
            llvm.c.LLVMPointerTypeKind => {
                // This is likely a string (char*) - use strdup to create a copy
                const strdup_fn = self.getOrDeclareStrdup();
                var args = [_]llvm.ValueRef{value};
                return self.builder.buildCall(
                    llvm.c.LLVMGlobalGetValueType(strdup_fn),
                    strdup_fn,
                    &args,
                    "clone.str",
                );
            },
            llvm.c.LLVMStructTypeKind => {
                // Check if this is Optional (2 fields) or Result (3 fields)
                const num_fields = llvm.c.LLVMCountStructElementTypes(value_type);
                if (num_fields == 2) {
                    // Optional[T] - clone the optional
                    return self.emitOptionalClone(value, value_type);
                } else if (num_fields == 3) {
                    // Result[T, E] - clone the result
                    return self.emitResultClone(value, value_type);
                }
                // For user-defined structs that implement Clone, we need to call the user-defined clone method
                // This should be handled by the user-defined method lookup before we get here
                // For now, just return the value (shallow copy)
                return value;
            },
            else => {
                // Unsupported type - just return the value
                return value;
            },
        }
    }

    /// Emit the Drop trait's drop() method for explicit destruction.
    /// This calls the user-defined drop method on structs that implement Drop.
    /// Primitives don't have drop() - they are trivially destroyed.
    fn emitDropMethod(self: *Emitter, method: *ast.MethodCall, object: llvm.ValueRef, object_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = object_type;

        // For structs that implement Drop, we look up the user-defined drop method
        if (self.type_checker) |tc| {
            const struct_name = self.getStructNameFromExpr(method.object);
            if (struct_name) |name| {
                // Look up the drop method in the struct's impl block
                if (tc.lookupStructMethod(name, "drop")) |drop_method| {
                    // Call the user-defined drop method with the object as self
                    return self.emitUserDefinedMethod(method, object, name, drop_method);
                }
            }
        }

        // No drop method found - return void (0)
        // The type checker should have caught this already
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Emit the Hash trait's hash() method for computing hash codes.
    /// Returns i64 hash value. All primitives have builtin Hash.
    /// Uses FNV-1a hash algorithm for consistent, good distribution.
    fn emitHashMethod(self: *Emitter, method: *ast.MethodCall, value: llvm.ValueRef, value_type: llvm.TypeRef) EmitError!llvm.ValueRef {
        _ = method; // hash() takes no arguments

        // Dispatch based on the LLVM type kind
        const kind = llvm.c.LLVMGetTypeKind(value_type);
        const i64_type = llvm.Types.int64(self.ctx);

        switch (kind) {
            llvm.c.LLVMIntegerTypeKind => {
                // For integers: convert to i64 and XOR with FNV offset basis
                // This gives a simple but effective hash for integer values
                const bit_width = llvm.c.LLVMGetIntTypeWidth(value_type);
                if (bit_width <= 64) {
                    // Sign extend or zero extend to i64
                    const ext_value = if (bit_width < 64)
                        self.builder.buildSExt(value, i64_type, "hash.ext")
                    else
                        value;
                    // XOR with FNV-1a offset basis for better distribution
                    // FNV offset basis: 14695981039346656037 (0xcbf29ce484222325)
                    const fnv_offset = llvm.Const.int64(self.ctx, @bitCast(@as(u64, 0xcbf29ce484222325)));
                    return self.builder.buildXor(ext_value, fnv_offset, "hash.int");
                } else {
                    // For larger integers (i128), truncate to i64 and hash
                    const trunc_value = self.builder.buildTrunc(value, i64_type, "hash.trunc");
                    const fnv_offset = llvm.Const.int64(self.ctx, @bitCast(@as(u64, 0xcbf29ce484222325)));
                    return self.builder.buildXor(trunc_value, fnv_offset, "hash.bigint");
                }
            },
            llvm.c.LLVMFloatTypeKind => {
                // For floats: bitcast to i32, then extend to i64
                const i32_type = llvm.Types.int32(self.ctx);
                const bits = llvm.c.LLVMBuildBitCast(self.builder.ref, value, i32_type, "hash.f32bits");
                const ext_bits = self.builder.buildSExt(bits, i64_type, "hash.ext");
                const fnv_offset = llvm.Const.int64(self.ctx, @bitCast(@as(u64, 0xcbf29ce484222325)));
                return self.builder.buildXor(ext_bits, fnv_offset, "hash.float");
            },
            llvm.c.LLVMDoubleTypeKind => {
                // For doubles: bitcast directly to i64
                const bits = llvm.c.LLVMBuildBitCast(self.builder.ref, value, i64_type, "hash.f64bits");
                const fnv_offset = llvm.Const.int64(self.ctx, @bitCast(@as(u64, 0xcbf29ce484222325)));
                return self.builder.buildXor(bits, fnv_offset, "hash.double");
            },
            llvm.c.LLVMPointerTypeKind => {
                // This is likely a string (char*) - call string hash helper
                const hash_fn = self.getOrDeclareStringHash();
                var args = [_]llvm.ValueRef{value};
                return self.builder.buildCall(
                    llvm.c.LLVMGlobalGetValueType(hash_fn),
                    hash_fn,
                    &args,
                    "hash.str",
                );
            },
            llvm.c.LLVMStructTypeKind => {
                // For structs that implement Hash, we need to call the user-defined hash method
                // This should be handled by the user-defined method lookup before we get here
                // For now, return a constant (should not reach here if type checker is correct)
                return llvm.Const.int64(self.ctx, 0);
            },
            else => {
                // Unsupported type - return 0
                return llvm.Const.int64(self.ctx, 0);
            },
        }
    }

    /// Get or declare the klar_string_hash helper function for hashing strings.
    /// Uses FNV-1a algorithm: hash = ((hash ^ byte) * FNV_prime) for each byte
    fn getOrDeclareStringHash(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_hash";

        // Check if already declared
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |existing| {
            return existing;
        }

        // Declare: i64 klar_string_hash(i8* str)
        const i64_type = llvm.Types.int64(self.ctx);
        const i8_ptr_type = llvm.Types.pointer(self.ctx);
        var param_types = [_]llvm.TypeRef{i8_ptr_type};
        const fn_type = llvm.Types.function(i64_type, &param_types, false);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Create the function body implementing FNV-1a hash
        const entry = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");
        const loop_block = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop");
        const loop_body = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "loop_body");
        const exit_block = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "exit");

        // Save current builder state
        const saved_block = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        const i8_type = llvm.Types.int8(self.ctx);
        const str_param = llvm.c.LLVMGetParam(func, 0);

        // Entry block: initialize hash with FNV offset basis, jump to loop
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        // Loop block: PHI nodes for hash and pointer, then check for null terminator
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_block);
        const hash_phi = llvm.c.LLVMBuildPhi(self.builder.ref, i64_type, "hash");
        const ptr_phi = llvm.c.LLVMBuildPhi(self.builder.ref, i8_ptr_type, "ptr");

        // Load current character
        const char_val = llvm.c.LLVMBuildLoad2(self.builder.ref, i8_type, ptr_phi, "char");

        // Check if null terminator
        const is_null = llvm.c.LLVMBuildICmp(self.builder.ref, llvm.c.LLVMIntEQ, char_val, llvm.Const.int(i8_type, 0, false), "is_null");
        _ = llvm.c.LLVMBuildCondBr(self.builder.ref, is_null, exit_block, loop_body);

        // Loop body: hash = (hash ^ byte) * FNV_prime
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, loop_body);
        const char_ext = llvm.c.LLVMBuildZExt(self.builder.ref, char_val, i64_type, "char.ext");
        const xored = llvm.c.LLVMBuildXor(self.builder.ref, hash_phi, char_ext, "xored");
        // FNV-1a prime: 1099511628211 (0x100000001b3)
        const fnv_prime = llvm.Const.int64(self.ctx, @bitCast(@as(u64, 0x100000001b3)));
        const new_hash = llvm.c.LLVMBuildMul(self.builder.ref, xored, fnv_prime, "new_hash");

        // Increment pointer
        var indices = [_]llvm.ValueRef{llvm.Const.int32(self.ctx, 1)};
        const next_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, ptr_phi, &indices, 1, "next_ptr");
        _ = llvm.c.LLVMBuildBr(self.builder.ref, loop_block);

        // Set up PHI incoming values
        // hash_phi: entry -> FNV offset basis, loop_body -> new_hash
        const fnv_offset = llvm.Const.int64(self.ctx, @bitCast(@as(u64, 0xcbf29ce484222325)));
        var hash_values = [_]llvm.ValueRef{ fnv_offset, new_hash };
        var hash_blocks = [_]llvm.BasicBlockRef{ entry, loop_body };
        llvm.c.LLVMAddIncoming(hash_phi, &hash_values, &hash_blocks, 2);

        // ptr_phi: entry -> str_param, loop_body -> next_ptr
        var ptr_values = [_]llvm.ValueRef{ str_param, next_ptr };
        var ptr_blocks = [_]llvm.BasicBlockRef{ entry, loop_body };
        llvm.c.LLVMAddIncoming(ptr_phi, &ptr_values, &ptr_blocks, 2);

        // Exit block: return the hash
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, exit_block);
        _ = llvm.c.LLVMBuildRet(self.builder.ref, hash_phi);

        // Restore builder position
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, saved_block);

        return func;
    }

    /// Emit the Default trait's default() static method.
    /// Returns the default value for the given type name.
    /// Primitives have builtin defaults:
    /// - integers -> 0
    /// - floats -> 0.0
    /// - bool -> false
    /// - char -> '\0' (0)
    /// - string -> "" (empty string)
    fn emitDefaultMethod(self: *Emitter, type_name: []const u8) EmitError!llvm.ValueRef {
        // Handle primitive types
        if (std.mem.eql(u8, type_name, "i8")) {
            return llvm.Const.int(llvm.Types.int8(self.ctx), 0, true);
        }
        if (std.mem.eql(u8, type_name, "i16")) {
            return llvm.Const.int(llvm.Types.int16(self.ctx), 0, true);
        }
        if (std.mem.eql(u8, type_name, "i32")) {
            return llvm.Const.int32(self.ctx, 0);
        }
        if (std.mem.eql(u8, type_name, "i64")) {
            return llvm.Const.int64(self.ctx, 0);
        }
        if (std.mem.eql(u8, type_name, "i128")) {
            return llvm.Const.int(llvm.Types.int128(self.ctx), 0, true);
        }
        if (std.mem.eql(u8, type_name, "isize")) {
            return llvm.Const.int64(self.ctx, 0); // isize is i64 on 64-bit
        }
        if (std.mem.eql(u8, type_name, "u8")) {
            return llvm.Const.int(llvm.Types.int8(self.ctx), 0, false);
        }
        if (std.mem.eql(u8, type_name, "u16")) {
            return llvm.Const.int(llvm.Types.int16(self.ctx), 0, false);
        }
        if (std.mem.eql(u8, type_name, "u32")) {
            return llvm.Const.int(llvm.Types.int32(self.ctx), 0, false);
        }
        if (std.mem.eql(u8, type_name, "u64")) {
            return llvm.Const.int64(self.ctx, 0);
        }
        if (std.mem.eql(u8, type_name, "u128")) {
            return llvm.Const.int(llvm.Types.int128(self.ctx), 0, false);
        }
        if (std.mem.eql(u8, type_name, "usize")) {
            return llvm.Const.int64(self.ctx, 0); // usize is u64 on 64-bit
        }
        if (std.mem.eql(u8, type_name, "f32")) {
            return llvm.Const.float32(self.ctx, 0.0);
        }
        if (std.mem.eql(u8, type_name, "f64")) {
            return llvm.Const.float64(self.ctx, 0.0);
        }
        if (std.mem.eql(u8, type_name, "bool")) {
            return llvm.Const.int1(self.ctx, false);
        }
        if (std.mem.eql(u8, type_name, "char")) {
            // char is represented as i32 (Unicode code point), default is '\0'
            return llvm.Const.int32(self.ctx, 0);
        }
        if (std.mem.eql(u8, type_name, "string")) {
            // String default is empty string ""
            return self.builder.buildGlobalStringPtr("", "default_str");
        }

        // For struct types that implement Default, look up the user-defined default method
        if (self.type_checker) |tc| {
            if (tc.lookupStructMethod(type_name, "default")) |default_method| {
                // Get the function name for the static method
                var name_buf: [256]u8 = undefined;
                const fn_name = std.fmt.bufPrint(&name_buf, "{s}.default", .{type_name}) catch return EmitError.OutOfMemory;

                // Look up the function - it should have been emitted earlier
                if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name.ptr)) |func| {
                    // Call the static default() function with no arguments
                    var args = [_]llvm.ValueRef{};
                    return self.builder.buildCall(
                        llvm.c.LLVMGlobalGetValueType(func),
                        func,
                        &args,
                        "default",
                    );
                }

                // Function not found, try to emit it
                _ = default_method;
                // TODO: emit the user-defined default method if not already emitted
            }
        }

        // Unknown type - return 0 as fallback (type checker should have caught this)
        return llvm.Const.int32(self.ctx, 0);
    }

    /// Declare the C strdup function if not already declared.
    fn getOrDeclareStrdup(self: *Emitter) llvm.ValueRef {
        const fn_name = "strdup";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // char* strdup(const char *s)
        const ptr_type = llvm.Types.pointer(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 1, 0); // not variadic
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Declare the C strcmp function if not already declared.
    fn getOrDeclareStrcmp(self: *Emitter) llvm.ValueRef {
        const fn_name = "strcmp";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int strcmp(const char *s1, const char *s2)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 2, 0); // not variadic
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    /// Declare or get the string concatenation function.
    /// Concatenates two null-terminated strings, returning a new allocated string.
    fn getOrDeclareStringConcatLiteral(self: *Emitter) llvm.ValueRef {
        const fn_name = "klar_string_concat_literal";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // char* klar_string_concat_literal(const char *a, const char *b)
        const ptr_type = llvm.Types.pointer(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 2, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

        // Build the function body inline
        const entry_bb = llvm.c.LLVMAppendBasicBlockInContext(self.ctx.ref, func, "entry");

        const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);

        const i8_type = llvm.Types.int8(self.ctx);
        const one_i64 = llvm.Const.int64(self.ctx, 1);

        // Entry block
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry_bb);
        const a = llvm.c.LLVMGetParam(func, 0);
        const b = llvm.c.LLVMGetParam(func, 1);

        // Get lengths of both strings
        const strlen_fn = self.getOrDeclareStrlen();
        var strlen_args_a = [_]llvm.ValueRef{a};
        const len_a = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(strlen_fn),
            strlen_fn,
            &strlen_args_a,
            1,
            "len_a",
        );
        var strlen_args_b = [_]llvm.ValueRef{b};
        const len_b = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(strlen_fn),
            strlen_fn,
            &strlen_args_b,
            1,
            "len_b",
        );

        // Total length = len_a + len_b + 1 (for null terminator)
        const total_len = llvm.c.LLVMBuildAdd(self.builder.ref, len_a, len_b, "total_len");
        const alloc_size = llvm.c.LLVMBuildAdd(self.builder.ref, total_len, one_i64, "alloc_size");

        // Allocate new buffer
        const malloc_fn = self.getOrDeclareMalloc();
        var malloc_args = [_]llvm.ValueRef{alloc_size};
        const result = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(malloc_fn),
            malloc_fn,
            &malloc_args,
            1,
            "result",
        );

        // Copy first string using memcpy
        const memcpy_fn = self.getOrDeclareMemcpy();
        var memcpy_args_a = [_]llvm.ValueRef{ result, a, len_a };
        _ = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(memcpy_fn),
            memcpy_fn,
            &memcpy_args_a,
            3,
            "",
        );

        // Copy second string: dest = result + len_a
        var gep_indices = [_]llvm.ValueRef{len_a};
        const dest_b = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, result, &gep_indices, 1, "dest_b");
        var memcpy_args_b = [_]llvm.ValueRef{ dest_b, b, len_b };
        _ = llvm.c.LLVMBuildCall2(
            self.builder.ref,
            llvm.c.LLVMGlobalGetValueType(memcpy_fn),
            memcpy_fn,
            &memcpy_args_b,
            3,
            "",
        );

        // Add null terminator at result[total_len]
        var gep_indices_null = [_]llvm.ValueRef{total_len};
        const null_ptr = llvm.c.LLVMBuildGEP2(self.builder.ref, i8_type, result, &gep_indices_null, 1, "null_ptr");
        _ = llvm.c.LLVMBuildStore(self.builder.ref, llvm.Const.int8(self.ctx, 0), null_ptr);

        // Return result
        _ = llvm.c.LLVMBuildRet(self.builder.ref, result);

        // Restore builder position
        llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, saved_bb);

        return func;
    }

    fn getOrDeclareFprintf(self: *Emitter) llvm.ValueRef {
        const fn_name = "fprintf";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int fprintf(FILE *stream, const char *format, ...)
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type };
        // variadic = 1 (true)
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 2, 1);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    // ==================== File I/O libc declarations ====================

    fn getOrDeclareFopen(self: *Emitter) llvm.ValueRef {
        const fn_name = "fopen";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // FILE *fopen(const char *path, const char *mode);
        const ptr_type = llvm.Types.pointer(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 2, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareFclose(self: *Emitter) llvm.ValueRef {
        const fn_name = "fclose";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int fclose(FILE *stream);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareFread(self: *Emitter) llvm.ValueRef {
        const fn_name = "fread";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const size_type = llvm.Types.int64(self.ctx); // size_t
        var param_types = [_]llvm.TypeRef{ ptr_type, size_type, size_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(size_type, &param_types, 4, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareFwrite(self: *Emitter) llvm.ValueRef {
        const fn_name = "fwrite";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const size_type = llvm.Types.int64(self.ctx); // size_t
        var param_types = [_]llvm.TypeRef{ ptr_type, size_type, size_type, ptr_type };
        const fn_type = llvm.c.LLVMFunctionType(size_type, &param_types, 4, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareFflush(self: *Emitter) llvm.ValueRef {
        const fn_name = "fflush";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int fflush(FILE *stream);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareFseek(self: *Emitter) llvm.ValueRef {
        const fn_name = "fseek";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int fseek(FILE *stream, long offset, int whence);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx); // long
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ ptr_type, i64_type, i32_type };
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareFtell(self: *Emitter) llvm.ValueRef {
        const fn_name = "ftell";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // long ftell(FILE *stream);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i64_type = llvm.Types.int64(self.ctx); // long
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(i64_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareFerror(self: *Emitter) llvm.ValueRef {
        const fn_name = "ferror";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // int ferror(FILE *stream);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        var param_types = [_]llvm.TypeRef{ptr_type};
        const fn_type = llvm.c.LLVMFunctionType(i32_type, &param_types, 1, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareMemchr(self: *Emitter) llvm.ValueRef {
        const fn_name = "memchr";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // void *memchr(const void *s, int c, size_t n);
        const ptr_type = llvm.Types.pointer(self.ctx);
        const i32_type = llvm.Types.int32(self.ctx);
        const size_type = llvm.Types.int64(self.ctx); // size_t
        var param_types = [_]llvm.TypeRef{ ptr_type, i32_type, size_type };
        const fn_type = llvm.c.LLVMFunctionType(ptr_type, &param_types, 3, 0);
        return llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
    }

    fn getOrDeclareStdout(self: *Emitter) llvm.ValueRef {
        // On macOS/BSD, stdout is accessed via __stdoutp
        // On Linux, it's accessed via stdout global
        const os = @import("builtin").os.tag;

        if (os == .macos) {
            const var_name = "__stdoutp";
            if (llvm.c.LLVMGetNamedGlobal(self.module.ref, var_name)) |global| {
                const fn_name = "klar_get_stdout";
                if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
                    return func;
                }

                const ptr_type = llvm.Types.pointer(self.ctx);
                const fn_type = llvm.c.LLVMFunctionType(ptr_type, null, 0, 0);
                const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

                const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
                const saved_func = self.current_function;

                const entry = llvm.appendBasicBlock(self.ctx, func, "entry");
                llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);

                const stdout_val = self.builder.buildLoad(ptr_type, global, "stdout");
                _ = llvm.c.LLVMBuildRet(self.builder.ref, stdout_val);

                if (saved_bb) |bb| {
                    llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
                }
                self.current_function = saved_func;

                return func;
            }

            const ptr_type = llvm.Types.pointer(self.ctx);
            const global = llvm.c.LLVMAddGlobal(self.module.ref, ptr_type, var_name);
            llvm.c.LLVMSetLinkage(global, llvm.c.LLVMExternalLinkage);

            const fn_name = "klar_get_stdout";
            const fn_type = llvm.c.LLVMFunctionType(ptr_type, null, 0, 0);
            const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

            const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            const saved_func = self.current_function;

            const entry = llvm.appendBasicBlock(self.ctx, func, "entry");
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);

            const stdout_val = self.builder.buildLoad(ptr_type, global, "stdout");
            _ = llvm.c.LLVMBuildRet(self.builder.ref, stdout_val);

            if (saved_bb) |bb| {
                llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
            }
            self.current_function = saved_func;

            return func;
        } else {
            const fn_name = "klar_get_stdout";
            if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
                return func;
            }

            const ptr_type = llvm.Types.pointer(self.ctx);
            const global = llvm.c.LLVMAddGlobal(self.module.ref, ptr_type, "stdout");
            llvm.c.LLVMSetLinkage(global, llvm.c.LLVMExternalLinkage);

            const fn_type = llvm.c.LLVMFunctionType(ptr_type, null, 0, 0);
            const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

            const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            const saved_func = self.current_function;

            const entry = llvm.appendBasicBlock(self.ctx, func, "entry");
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);

            const stdout_val = self.builder.buildLoad(ptr_type, global, "stdout");
            _ = llvm.c.LLVMBuildRet(self.builder.ref, stdout_val);

            if (saved_bb) |bb| {
                llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
            }
            self.current_function = saved_func;

            return func;
        }
    }

    fn getOrDeclareStderr(self: *Emitter) llvm.ValueRef {
        // On macOS/BSD, stderr is accessed via __stderrp
        // On Linux, it's accessed via stderr global
        const os = @import("builtin").os.tag;

        if (os == .macos) {
            // macOS: use __stderrp pointer
            const var_name = "__stderrp";
            if (llvm.c.LLVMGetNamedGlobal(self.module.ref, var_name)) |global| {
                // Declare a function that loads the global
                const fn_name = "klar_get_stderr";
                if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
                    return func;
                }

                const ptr_type = llvm.Types.pointer(self.ctx);
                const fn_type = llvm.c.LLVMFunctionType(ptr_type, null, 0, 0);
                const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

                // Create function body to load __stderrp
                const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
                const saved_func = self.current_function;

                const entry = llvm.appendBasicBlock(self.ctx, func, "entry");
                llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);

                const stderr_val = self.builder.buildLoad(ptr_type, global, "stderr");
                _ = llvm.c.LLVMBuildRet(self.builder.ref, stderr_val);

                if (saved_bb) |bb| {
                    llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
                }
                self.current_function = saved_func;

                return func;
            }

            // Declare __stderrp external global
            const ptr_type = llvm.Types.pointer(self.ctx);
            const global = llvm.c.LLVMAddGlobal(self.module.ref, ptr_type, var_name);
            llvm.c.LLVMSetLinkage(global, llvm.c.LLVMExternalLinkage);

            // Now create getter function
            const fn_name = "klar_get_stderr";
            const fn_type = llvm.c.LLVMFunctionType(ptr_type, null, 0, 0);
            const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

            // Create function body to load __stderrp
            const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            const saved_func = self.current_function;

            const entry = llvm.appendBasicBlock(self.ctx, func, "entry");
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);

            const stderr_val = self.builder.buildLoad(ptr_type, global, "stderr");
            _ = llvm.c.LLVMBuildRet(self.builder.ref, stderr_val);

            if (saved_bb) |bb| {
                llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
            }
            self.current_function = saved_func;

            return func;
        } else {
            // Linux: use stderr directly (declared as extern)
            const fn_name = "klar_get_stderr";
            if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
                return func;
            }

            // Declare stderr external global
            const ptr_type = llvm.Types.pointer(self.ctx);
            const global = llvm.c.LLVMAddGlobal(self.module.ref, ptr_type, "stderr");
            llvm.c.LLVMSetLinkage(global, llvm.c.LLVMExternalLinkage);

            // Create getter function
            const fn_type = llvm.c.LLVMFunctionType(ptr_type, null, 0, 0);
            const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

            const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            const saved_func = self.current_function;

            const entry = llvm.appendBasicBlock(self.ctx, func, "entry");
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);

            const stderr_val = self.builder.buildLoad(ptr_type, global, "stderr");
            _ = llvm.c.LLVMBuildRet(self.builder.ref, stderr_val);

            if (saved_bb) |bb| {
                llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
            }
            self.current_function = saved_func;

            return func;
        }
    }

    fn getOrDeclareStdin(self: *Emitter) llvm.ValueRef {
        // On macOS/BSD, stdin is accessed via __stdinp
        // On Linux, it's accessed via stdin global
        const os = @import("builtin").os.tag;

        if (os == .macos) {
            // macOS: use __stdinp pointer
            const var_name = "__stdinp";
            if (llvm.c.LLVMGetNamedGlobal(self.module.ref, var_name)) |global| {
                // Declare a function that loads the global
                const fn_name = "klar_get_stdin";
                if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
                    return func;
                }

                const ptr_type = llvm.Types.pointer(self.ctx);
                const fn_type = llvm.c.LLVMFunctionType(ptr_type, null, 0, 0);
                const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

                // Create function body to load __stdinp
                const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
                const saved_func = self.current_function;

                const entry = llvm.appendBasicBlock(self.ctx, func, "entry");
                llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);

                const stdin_val = self.builder.buildLoad(ptr_type, global, "stdin");
                _ = llvm.c.LLVMBuildRet(self.builder.ref, stdin_val);

                if (saved_bb) |bb| {
                    llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
                }
                self.current_function = saved_func;

                return func;
            }

            // Declare __stdinp external global
            const ptr_type = llvm.Types.pointer(self.ctx);
            const global = llvm.c.LLVMAddGlobal(self.module.ref, ptr_type, var_name);
            llvm.c.LLVMSetLinkage(global, llvm.c.LLVMExternalLinkage);

            // Now create getter function
            const fn_name = "klar_get_stdin";
            const fn_type = llvm.c.LLVMFunctionType(ptr_type, null, 0, 0);
            const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

            // Create function body to load __stdinp
            const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            const saved_func = self.current_function;

            const entry = llvm.appendBasicBlock(self.ctx, func, "entry");
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);

            const stdin_val = self.builder.buildLoad(ptr_type, global, "stdin");
            _ = llvm.c.LLVMBuildRet(self.builder.ref, stdin_val);

            if (saved_bb) |bb| {
                llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
            }
            self.current_function = saved_func;

            return func;
        } else {
            // Linux: use stdin directly (declared as extern)
            const fn_name = "klar_get_stdin";
            if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
                return func;
            }

            // Declare stdin external global
            const ptr_type = llvm.Types.pointer(self.ctx);
            const global = llvm.c.LLVMAddGlobal(self.module.ref, ptr_type, "stdin");
            llvm.c.LLVMSetLinkage(global, llvm.c.LLVMExternalLinkage);

            // Create getter function
            const fn_type = llvm.c.LLVMFunctionType(ptr_type, null, 0, 0);
            const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);

            const saved_bb = llvm.c.LLVMGetInsertBlock(self.builder.ref);
            const saved_func = self.current_function;

            const entry = llvm.appendBasicBlock(self.ctx, func, "entry");
            llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, entry);

            const stdin_val = self.builder.buildLoad(ptr_type, global, "stdin");
            _ = llvm.c.LLVMBuildRet(self.builder.ref, stdin_val);

            if (saved_bb) |bb| {
                llvm.c.LLVMPositionBuilderAtEnd(self.builder.ref, bb);
            }
            self.current_function = saved_func;

            return func;
        }
    }

    fn getOrDeclareAbort(self: *Emitter) llvm.ValueRef {
        const fn_name = "abort";
        if (llvm.c.LLVMGetNamedFunction(self.module.ref, fn_name)) |func| {
            return func;
        }

        // void abort(void) __attribute__((noreturn))
        const void_type = llvm.Types.void_(self.ctx);
        const fn_type = llvm.c.LLVMFunctionType(void_type, null, 0, 0);
        const func = llvm.c.LLVMAddFunction(self.module.ref, fn_name, fn_type);
        // Note: noreturn attribute would be nice but not critical - abort() always exits
        return func;
    }

    // ==================== Scope Management for Automatic Drop ====================

    /// Push a new scope onto the scope stack.
    fn pushScope(self: *Emitter, is_loop: bool) EmitError!void {
        self.scope_stack.append(self.allocator, .{
            .droppables = .{},
            .is_loop = is_loop,
        }) catch return EmitError.OutOfMemory;
    }

    /// Pop a scope and emit drops for all droppable variables in it.
    fn popScope(self: *Emitter) void {
        if (self.scope_stack.pop()) |scope| {
            // Emit drops in reverse order (LIFO - last declared, first dropped)
            self.emitDropsForVars(scope.droppables.items);
            var s = scope;
            s.droppables.deinit(self.allocator);
        }
    }

    /// Emit drops for all variables in the given list (in reverse order).
    fn emitDropsForVars(self: *Emitter, droppables: []const DroppableVar) void {
        if (droppables.len == 0) return;

        // Drop in reverse declaration order
        var i: usize = droppables.len;
        while (i > 0) {
            i -= 1;
            const v = droppables[i];
            self.emitDropForVar(v);
        }
    }

    /// Emit a drop call for a single variable.
    fn emitDropForVar(self: *Emitter, v: DroppableVar) void {
        if (v.is_rc) {
            // Load the Rc/Arc pointer from the alloca
            const ptr_type = llvm.Types.pointer(self.ctx);
            const rc_ptr = self.builder.buildLoad(ptr_type, v.alloca, "rc_ptr_drop");

            // Get the size of the inner type
            const inner_size = llvm.c.LLVMSizeOf(v.inner_type);
            const i64_type = llvm.Types.int64(self.ctx);
            const size_val = llvm.c.LLVMBuildIntCast2(self.builder.ref, inner_size, i64_type, 0, "size");

            // Alignment (8 is a safe default for most types)
            const align_val = llvm.Const.int64(self.ctx, 8);

            // No destructor callback for primitive types (null pointer)
            const null_ptr = llvm.c.LLVMConstNull(ptr_type);

            // Call klar_rc_drop or klar_arc_drop depending on type
            const drop_fn = if (v.is_arc) self.getOrDeclareArcDrop() else self.getOrDeclareRcDrop();
            var args = [_]llvm.ValueRef{ rc_ptr, size_val, align_val, null_ptr };
            _ = llvm.c.LLVMBuildCall2(
                self.builder.ref,
                llvm.c.LLVMGlobalGetValueType(drop_fn),
                drop_fn,
                &args,
                4,
                "",
            );
        } else if (v.is_buf_writer) {
            // Flush BufWriter buffer on drop - call emitBufWriterFlush
            // This ensures any buffered data is written before the variable goes out of scope
            _ = self.emitBufWriterFlush(v.alloca) catch {};
        } else if (v.is_cstr_owned) {
            // Free CStrOwned memory on drop
            const ptr_type = llvm.Types.pointer(self.ctx);
            const cstr_ptr = self.builder.buildLoad(ptr_type, v.alloca, "cstr_owned_drop");

            // Call free to release the memory
            const free_fn = self.getOrDeclareFree();
            var args = [_]llvm.ValueRef{cstr_ptr};
            _ = llvm.c.LLVMBuildCall2(
                self.builder.ref,
                llvm.c.LLVMGlobalGetValueType(free_fn),
                free_fn,
                &args,
                1,
                "",
            );
        }
        // For non-Rc types that need dropping (future: closures, custom destructors),
        // we would add additional cases here.
    }

    /// Emit drops for all scopes up to (and including) the current function scope.
    /// Used for return statements.
    fn emitDropsForReturn(self: *Emitter) void {
        // Drop all variables in all scopes (innermost first)
        var i: usize = self.scope_stack.items.len;
        while (i > 0) {
            i -= 1;
            const scope = self.scope_stack.items[i];
            self.emitDropsForVars(scope.droppables.items);
        }
    }

    /// Emit drops for all scopes until we reach a loop scope.
    /// Used for break/continue statements.
    fn emitDropsForLoopExit(self: *Emitter) void {
        var i: usize = self.scope_stack.items.len;
        while (i > 0) {
            i -= 1;
            const scope = self.scope_stack.items[i];
            self.emitDropsForVars(scope.droppables.items);
            if (scope.is_loop) {
                // Stop at the loop scope itself (its variables will be dropped
                // when the loop ends normally or when outer scope exits)
                break;
            }
        }
    }

    /// Register a variable in the current scope as needing dropping.
    fn registerDroppable(self: *Emitter, name: []const u8, alloca: llvm.ValueRef, inner_type: llvm.TypeRef, is_rc: bool, is_arc: bool) EmitError!void {
        if (self.scope_stack.items.len == 0) return;

        const scope = &self.scope_stack.items[self.scope_stack.items.len - 1];
        scope.droppables.append(self.allocator, .{
            .name = name,
            .alloca = alloca,
            .inner_type = inner_type,
            .is_rc = is_rc,
            .is_arc = is_arc,
        }) catch return EmitError.OutOfMemory;
    }

    /// Register a BufWriter variable in the current scope for automatic flushing on drop.
    fn registerBufWriterDroppable(self: *Emitter, name: []const u8, alloca: llvm.ValueRef) EmitError!void {
        if (self.scope_stack.items.len == 0) return;

        const scope = &self.scope_stack.items[self.scope_stack.items.len - 1];
        scope.droppables.append(self.allocator, .{
            .name = name,
            .alloca = alloca,
            .inner_type = llvm.Types.int32(self.ctx), // Placeholder, not used for BufWriter
            .is_rc = false,
            .is_buf_writer = true,
        }) catch return EmitError.OutOfMemory;
    }

    /// Register a CStrOwned variable in the current scope for automatic free on drop.
    fn registerCstrOwnedDroppable(self: *Emitter, name: []const u8, alloca: llvm.ValueRef) EmitError!void {
        if (self.scope_stack.items.len == 0) return;

        const scope = &self.scope_stack.items[self.scope_stack.items.len - 1];
        scope.droppables.append(self.allocator, .{
            .name = name,
            .alloca = alloca,
            .inner_type = llvm.Types.pointer(self.ctx), // CStrOwned is just a pointer
            .is_rc = false,
            .is_cstr_owned = true,
        }) catch return EmitError.OutOfMemory;
    }

    // =========================================================================
    // Sret (Struct Return) Helpers
    // =========================================================================

    /// Check if a Klar type requires sret (struct return) calling convention.
    /// Arrays always need sret. Large structs may need sret based on ABI.
    fn requiresSret(self: *Emitter, klar_type: types.Type) bool {
        return switch (klar_type) {
            // Arrays always need sret - they can't be returned in registers
            .array => true,
            // Structs need sret if too large for register return
            .struct_ => |s| {
                const size = self.getSizeOfKlarType(klar_type);
                return size > self.abi.maxRegisterReturnSize() or s.fields.len > 2;
            },
            // Applied types (generic instantiations) need to check the concrete type
            .applied => |a| {
                if (a.base == .struct_) {
                    const size = self.getSizeOfKlarType(klar_type);
                    return size > self.abi.maxRegisterReturnSize();
                }
                return false;
            },
            // Tuples with more than 2 elements or large size need sret
            .tuple => |t| {
                if (t.elements.len > 2) return true;
                const size = self.getSizeOfKlarType(klar_type);
                return size > self.abi.maxRegisterReturnSize();
            },
            // Other types can be returned in registers
            else => false,
        };
    }

    /// Get the size of a Klar type in bytes.
    fn getSizeOfKlarType(self: *Emitter, klar_type: types.Type) usize {
        return switch (klar_type) {
            .primitive => |prim| switch (prim) {
                .i8_, .u8_ => 1,
                .i16_, .u16_ => 2,
                .i32_, .u32_, .f32_, .char_ => 4,
                .i64_, .u64_, .f64_, .isize_, .usize_ => 8,
                .i128_, .u128_ => 16,
                .bool_ => 1,
                .string_ => 8, // pointer
            },
            .void_, .never, .unknown, .error_type => 0,
            .array => |arr| {
                const elem_size = self.getSizeOfKlarType(arr.element);
                return elem_size * arr.size;
            },
            .slice => 16, // ptr + len
            .tuple => |t| {
                var total: usize = 0;
                for (t.elements) |elem| {
                    total += self.getSizeOfKlarType(elem);
                }
                return total;
            },
            .optional => |opt| {
                // 1 byte tag + inner type (with alignment)
                const inner_size = self.getSizeOfKlarType(opt.*);
                return 8 + inner_size; // Simplified: assume 8-byte alignment for tag
            },
            .result => |res| {
                const ok_size = self.getSizeOfKlarType(res.ok_type);
                const err_size = self.getSizeOfKlarType(res.err_type);
                return 8 + ok_size + err_size; // tag + both variants
            },
            .function => 16, // closure struct: fn_ptr + env_ptr
            .reference => 8, // pointer
            .struct_ => |s| {
                var total: usize = 0;
                for (s.fields) |field| {
                    total += self.getSizeOfKlarType(field.type_);
                }
                return total;
            },
            .applied => |a| {
                // For applied types, try to get the size from the base
                if (a.base == .struct_) {
                    var total: usize = 0;
                    for (a.base.struct_.fields) |field| {
                        // Fields may reference type params, so this is approximate
                        total += self.getSizeOfKlarType(field.type_);
                    }
                    return total;
                }
                return 8; // Default to pointer size
            },
            .enum_ => 8, // tag + max variant size (simplified)
            .trait_ => 8, // pointer
            .type_var => 8, // generic - assume pointer
            .associated_type_ref => 8, // assume pointer
            .rc, .arc, .weak_rc, .weak_arc => 8, // pointer
            // Additional types - all use pointer or small fixed size
            .cell => 8, // pointer to value
            .range => 16, // start + end
            .context_error => 8, // pointer
            // Collection types have fixed struct layouts (NOT pointers)
            // List: { ptr, len: i32, cap: i32 } = 8 + 4 + 4 = 16 bytes
            .list => 16,
            // Map: { entries: ptr, len: i32, cap: i32, tombstones: i32 } = 8 + 4 + 4 + 4 = 20 bytes
            .map => 20,
            // Set: { entries: ptr, len: i32, cap: i32, tombstones: i32 } = 8 + 4 + 4 + 4 = 20 bytes
            .set => 20,
            .string_data => 8, // pointer to string data
            .file, .io_error, .stdout_handle, .stderr_handle, .stdin_handle => 8, // handles/pointers
            .buf_reader, .buf_writer => 8, // pointers to buffered I/O structures
            .extern_type => |ext| {
                // Extern types: sized types use their declared size, opaque types use pointer size
                if (ext.size) |size| {
                    return @intCast(size);
                } else {
                    return 8; // opaque types are always behind pointers
                }
            },
            // FFI pointer types are all just pointers (8 bytes on 64-bit)
            .cptr, .copt_ptr, .cstr, .cstr_owned => 8,
        };
    }

    /// Get or create the sret attribute kind ID.
    fn getSretAttrKind(self: *Emitter) c_uint {
        if (self.sret_attr_kind) |kind| {
            return kind;
        }
        const kind = llvm.getEnumAttributeKindForName("sret");
        self.sret_attr_kind = kind;
        return kind;
    }

    /// Get or create the noalias attribute kind ID.
    fn getNoaliasAttrKind(_: *Emitter) c_uint {
        return llvm.getEnumAttributeKindForName("noalias");
    }

    /// Check if an AST TypeExpr requires sret calling convention.
    /// This is used for non-generic functions where we have AST types instead of checker types.
    fn requiresSretForTypeExpr(_: *Emitter, type_expr: ast.TypeExpr) bool {
        return switch (type_expr) {
            // Arrays always need sret - they can't be returned in registers
            .array => true,
            // Tuple types with more than 2 elements likely need sret
            .tuple => |t| t.elements.len > 2,
            // Other types can generally be returned in registers
            else => false,
        };
    }

    // =========================================================================
    // Type Conversion from Checker Types
    // =========================================================================

    /// Convert a checker Type to an LLVM type.
    /// Used for monomorphization when we have concrete types from type inference.
    fn typeToLLVM(self: *Emitter, ty: types.Type) llvm.TypeRef {
        return switch (ty) {
            .primitive => |prim| switch (prim) {
                .i8_, .u8_ => llvm.Types.int8(self.ctx),
                .i16_, .u16_ => llvm.Types.int16(self.ctx),
                .i32_, .u32_ => llvm.Types.int32(self.ctx),
                .i64_, .u64_, .isize_, .usize_ => llvm.Types.int64(self.ctx),
                .i128_, .u128_ => llvm.Types.int128(self.ctx),
                .f32_ => llvm.Types.float32(self.ctx),
                .f64_ => llvm.Types.float64(self.ctx),
                .bool_ => llvm.Types.int1(self.ctx),
                .char_ => llvm.Types.int32(self.ctx), // Unicode codepoint
                .string_ => llvm.Types.pointer(self.ctx),
            },
            .void_ => llvm.Types.void_(self.ctx),
            .never, .unknown, .error_type => llvm.Types.void_(self.ctx),
            .array => |arr| {
                const elem_ty = self.typeToLLVM(arr.element);
                return llvm.Types.array(elem_ty, @intCast(arr.size));
            },
            .slice => {
                // Slice is {ptr, len}
                var fields = [_]llvm.TypeRef{
                    llvm.Types.pointer(self.ctx),
                    llvm.Types.int64(self.ctx),
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .tuple => |tup| {
                var elem_types = std.ArrayListUnmanaged(llvm.TypeRef){};
                defer elem_types.deinit(self.allocator);
                for (tup.elements) |elem| {
                    elem_types.append(self.allocator, self.typeToLLVM(elem)) catch {
                        return llvm.Types.int32(self.ctx);
                    };
                }
                return llvm.Types.struct_(self.ctx, elem_types.items, false);
            },
            .optional => |opt| {
                // Optional is {tag: i1, value}, opt is *Type
                const inner_ty = self.typeToLLVM(opt.*);
                var fields = [_]llvm.TypeRef{
                    llvm.Types.int1(self.ctx),
                    inner_ty,
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .result => |res| {
                // Result is {tag: i1, ok_value, err_value}
                const ok_ty = self.typeToLLVM(res.ok_type);
                const err_ty = self.typeToLLVM(res.err_type);
                var fields = [_]llvm.TypeRef{
                    llvm.Types.int1(self.ctx),
                    ok_ty,
                    err_ty,
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .function => {
                // Function types use closure representation
                return self.getClosureStructType();
            },
            .reference => llvm.Types.pointer(self.ctx),
            .struct_ => |s| {
                // Look up struct type in struct_types cache
                if (self.struct_types.get(s.name)) |struct_info| {
                    return struct_info.llvm_type;
                }
                // Fallback to pointer if not found
                return llvm.Types.pointer(self.ctx);
            },
            .applied => |a| {
                // For applied types (e.g., Pair[i32]), construct mangled name and look up
                var name_buf = std.ArrayListUnmanaged(u8){};
                defer name_buf.deinit(self.allocator);

                // Get base name
                if (a.base == .struct_) {
                    name_buf.appendSlice(self.allocator, a.base.struct_.name) catch {
                        return llvm.Types.pointer(self.ctx);
                    };
                    // Append type args
                    for (a.args) |arg| {
                        name_buf.append(self.allocator, '$') catch {
                            return llvm.Types.pointer(self.ctx);
                        };
                        self.appendCheckerTypeNameForMangling(&name_buf, arg) catch {
                            return llvm.Types.pointer(self.ctx);
                        };
                    }

                    // Look up the mangled struct type
                    if (self.struct_types.get(name_buf.items)) |struct_info| {
                        return struct_info.llvm_type;
                    }
                }
                // Fallback to pointer if not found
                return llvm.Types.pointer(self.ctx);
            },
            .enum_ => |e| {
                // Enums are registered as struct types (tag + payload).
                // Look up in struct_types cache to get the actual struct layout.
                if (self.struct_types.get(e.name)) |cached| {
                    return cached.llvm_type;
                }
                // For monomorphized enums, try with mangled name
                // Fallback to pointer only if not registered yet (during registration)
                return llvm.Types.pointer(self.ctx);
            },
            .trait_, .type_var => {
                // These truly are opaque/pointer types
                return llvm.Types.pointer(self.ctx);
            },
            .rc, .arc, .weak_rc, .weak_arc => {
                // Reference-counted types are pointers
                return llvm.Types.pointer(self.ctx);
            },
            .cell => llvm.Types.pointer(self.ctx),
            .context_error => |ce| {
                // ContextError LLVM layout: { message: ptr, cause: E, file: ptr, line: i32, column: i32 }
                // In debug mode, file/line/column are populated; in release, file=null, line=0, column=0
                const inner_ty = self.typeToLLVM(ce.inner_type);
                var fields = [_]llvm.TypeRef{
                    llvm.Types.pointer(self.ctx), // message (string pointer)
                    inner_ty, // cause (inner error type)
                    llvm.Types.pointer(self.ctx), // file (string pointer, null in release)
                    llvm.Types.int32(self.ctx), // line (0 in release)
                    llvm.Types.int32(self.ctx), // column (0 in release)
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .range => |r| {
                // Range LLVM layout: { start: T, end: T, current: T, inclusive: i1 }
                const elem_ty = self.typeToLLVM(r.element_type);
                var fields = [_]llvm.TypeRef{
                    elem_ty, // start
                    elem_ty, // end
                    elem_ty, // current
                    llvm.Types.int1(self.ctx), // inclusive
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .list => {
                // List LLVM layout: { ptr: *T, len: i32, capacity: i32 }
                var fields = [_]llvm.TypeRef{
                    llvm.Types.pointer(self.ctx), // ptr
                    llvm.Types.int32(self.ctx), // len
                    llvm.Types.int32(self.ctx), // capacity
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .map => {
                // Map LLVM layout: { entries: *Entry, len: i32, capacity: i32, tombstone_count: i32 }
                // Entry layout is handled separately
                var fields = [_]llvm.TypeRef{
                    llvm.Types.pointer(self.ctx), // entries ptr
                    llvm.Types.int32(self.ctx), // len
                    llvm.Types.int32(self.ctx), // capacity
                    llvm.Types.int32(self.ctx), // tombstone_count
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .set => {
                // Set LLVM layout: { entries: *Entry, len: i32, capacity: i32, tombstone_count: i32 }
                // Same layout as Map (entry is different but ptr is opaque here)
                var fields = [_]llvm.TypeRef{
                    llvm.Types.pointer(self.ctx), // entries ptr
                    llvm.Types.int32(self.ctx), // len
                    llvm.Types.int32(self.ctx), // capacity
                    llvm.Types.int32(self.ctx), // tombstone_count
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .string_data => {
                // String LLVM layout: { ptr: *u8, len: i32, capacity: i32 }
                // Same layout as List but fixed element type of u8
                var fields = [_]llvm.TypeRef{
                    llvm.Types.pointer(self.ctx), // ptr
                    llvm.Types.int32(self.ctx), // len
                    llvm.Types.int32(self.ctx), // capacity
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .file => {
                // File is an opaque FILE* handle
                return llvm.Types.pointer(self.ctx);
            },
            .io_error => {
                // IoError is a tagged union: { tag: i32, payload: ptr }
                // tag: 0=NotFound, 1=PermissionDenied, 2=AlreadyExists, 3=InvalidInput, 4=UnexpectedEof, 5=Other
                // payload is only used for Other (points to string)
                var fields = [_]llvm.TypeRef{
                    llvm.Types.int32(self.ctx), // tag
                    llvm.Types.pointer(self.ctx), // payload (string for Other variant)
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .stdout_handle => {
                // Stdout is an opaque marker type - store as FILE* pointer
                return llvm.Types.pointer(self.ctx);
            },
            .stderr_handle => {
                // Stderr is an opaque marker type - store as FILE* pointer
                return llvm.Types.pointer(self.ctx);
            },
            .stdin_handle => {
                // Stdin is an opaque marker type - store as FILE* pointer
                return llvm.Types.pointer(self.ctx);
            },
            .buf_reader => |br| {
                // BufReader LLVM layout: { inner: R, buffer: [8192]u8, pos: i32, cap: i32 }
                const inner_ty = self.typeToLLVM(br.inner);
                var fields = [_]llvm.TypeRef{
                    inner_ty, // inner reader
                    llvm.Types.array(llvm.Types.int8(self.ctx), 8192), // buffer
                    llvm.Types.int32(self.ctx), // pos
                    llvm.Types.int32(self.ctx), // cap
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .buf_writer => |bw| {
                // BufWriter LLVM layout: { inner: W, buffer: [8192]u8, len: i32 }
                const inner_ty = self.typeToLLVM(bw.inner);
                var fields = [_]llvm.TypeRef{
                    inner_ty, // inner writer
                    llvm.Types.array(llvm.Types.int8(self.ctx), 8192), // buffer
                    llvm.Types.int32(self.ctx), // len
                };
                return llvm.Types.struct_(self.ctx, &fields, false);
            },
            .associated_type_ref => {
                // Associated type refs should have been resolved during type checking.
                // If we get here, it's an unresolved associated type - use pointer as fallback.
                return llvm.Types.pointer(self.ctx);
            },
            .extern_type => |ext| {
                // External types for FFI:
                // - Opaque types (size == null): use pointer (can only be used behind pointers)
                // - Sized types (size != null): use byte array of specified size
                if (ext.size) |size| {
                    // Sized extern type: [N x i8]
                    return llvm.Types.array(llvm.Types.int8(self.ctx), @intCast(size));
                } else {
                    // Opaque extern type: use pointer
                    return llvm.Types.pointer(self.ctx);
                }
            },
            // FFI pointer types are all LLVM opaque pointers
            .cptr, .copt_ptr, .cstr, .cstr_owned => llvm.Types.pointer(self.ctx),
        };
    }

    /// Check if a checker Type is signed.
    fn isCheckerTypeSigned(_: *Emitter, ty: types.Type) bool {
        return switch (ty) {
            .primitive => |prim| switch (prim) {
                .u8_, .u16_, .u32_, .u64_, .u128_, .usize_ => false,
                else => true,
            },
            else => true, // Default to signed
        };
    }

    // =========================================================================
    // Monomorphized Struct Registration
    // =========================================================================

    /// Register all monomorphized struct types from the type checker.
    /// Must be called BEFORE emitModule so that struct literals can find the types.
    pub fn registerMonomorphizedStructs(self: *Emitter, type_checker: *const TypeChecker) EmitError!void {
        const monos = type_checker.getMonomorphizedStructs();

        for (monos) |mono| {
            try self.registerMonomorphizedStruct(mono);
        }
    }

    /// Register a single monomorphized struct type.
    fn registerMonomorphizedStruct(self: *Emitter, mono: TypeChecker.MonomorphizedStruct) EmitError!void {
        // Skip if already registered
        if (self.struct_types.contains(mono.mangled_name)) {
            return;
        }

        // Build LLVM field types from the concrete struct type
        var field_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer field_types.deinit(self.allocator);

        const field_count = mono.concrete_type.fields.len;
        var field_indices = self.allocator.alloc(u32, field_count) catch return EmitError.OutOfMemory;
        errdefer self.allocator.free(field_indices);

        var field_names = self.allocator.alloc([]const u8, field_count) catch return EmitError.OutOfMemory;
        errdefer self.allocator.free(field_names);

        for (mono.concrete_type.fields, 0..) |field, i| {
            const field_llvm_type = self.typeToLLVM(field.type_);
            field_types.append(self.allocator, field_llvm_type) catch return EmitError.OutOfMemory;
            field_indices[i] = @intCast(i);
            field_names[i] = field.name;
        }

        // Create LLVM struct type
        const struct_type = llvm.Types.struct_(self.ctx, field_types.items, false);

        // Cache the struct type info
        self.struct_types.put(mono.mangled_name, .{
            .llvm_type = struct_type,
            .field_indices = field_indices,
            .field_names = field_names,
        }) catch return EmitError.OutOfMemory;
    }

    // =========================================================================
    // Monomorphized Enum Registration
    // =========================================================================

    /// Register all monomorphized enum types from the type checker.
    /// This tracks concrete enum instantiations for future codegen support.
    pub fn registerMonomorphizedEnums(self: *Emitter, type_checker: *const TypeChecker) EmitError!void {
        const monos = type_checker.getMonomorphizedEnums();

        for (monos) |mono| {
            try self.registerMonomorphizedEnum(mono);
        }
    }

    /// Register a single monomorphized enum type.
    /// Enums are represented as tagged unions: {tag: i8, payload_union}
    fn registerMonomorphizedEnum(self: *Emitter, mono: TypeChecker.MonomorphizedEnum) EmitError!void {
        // Skip if already registered (uses struct_types map since enum codegen
        // will reuse struct infrastructure for tagged unions)
        if (self.struct_types.contains(mono.mangled_name)) {
            return;
        }

        // Calculate the maximum payload size across all variants
        var max_payload_size: usize = 0;
        for (mono.concrete_type.variants) |variant| {
            if (variant.payload) |payload| {
                const payload_size = switch (payload) {
                    .tuple => |tuple_types| blk: {
                        var size: usize = 0;
                        for (tuple_types) |t| {
                            size += self.getTypeSize(t);
                        }
                        break :blk size;
                    },
                    .struct_ => |struct_fields| blk: {
                        var size: usize = 0;
                        for (struct_fields) |f| {
                            size += self.getTypeSize(f.type_);
                        }
                        break :blk size;
                    },
                };
                if (payload_size > max_payload_size) {
                    max_payload_size = payload_size;
                }
            }
        }

        // Create LLVM type: {tag: i8, payload: [max_size x i8]}
        // This is a simple tagged union representation
        const variant_count = mono.concrete_type.variants.len;
        const tag_type = if (variant_count <= 256) llvm.Types.int8(self.ctx) else llvm.Types.int16(self.ctx);

        var field_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer field_types.deinit(self.allocator);

        // Tag field
        field_types.append(self.allocator, tag_type) catch return EmitError.OutOfMemory;

        // Payload field (if any variant has payload)
        if (max_payload_size > 0) {
            const payload_array = llvm.Types.array(llvm.Types.int8(self.ctx), @intCast(max_payload_size));
            field_types.append(self.allocator, payload_array) catch return EmitError.OutOfMemory;
        }

        // Create LLVM struct type for the enum
        const enum_type = llvm.Types.struct_(self.ctx, field_types.items, false);

        // Allocate field tracking data
        const field_count: usize = if (max_payload_size > 0) 2 else 1;
        const field_indices = self.allocator.alloc(u32, field_count) catch return EmitError.OutOfMemory;
        errdefer self.allocator.free(field_indices);

        const field_names = self.allocator.alloc([]const u8, field_count) catch return EmitError.OutOfMemory;
        errdefer self.allocator.free(field_names);

        field_indices[0] = 0;
        field_names[0] = "tag";
        if (max_payload_size > 0) {
            field_indices[1] = 1;
            field_names[1] = "payload";
        }

        // Cache the enum type info (reusing struct infrastructure)
        self.struct_types.put(mono.mangled_name, .{
            .llvm_type = enum_type,
            .field_indices = field_indices,
            .field_names = field_names,
        }) catch return EmitError.OutOfMemory;
    }

    /// Register all non-generic enum types from the type checker.
    /// Non-generic enums are those with no type parameters.
    pub fn registerNonGenericEnums(self: *Emitter, type_checker: *const TypeChecker) EmitError!void {
        const enum_types = type_checker.getEnumTypes();

        for (enum_types) |enum_type| {
            // Only register non-generic enums (those with no type parameters)
            if (enum_type.type_params.len == 0) {
                try self.registerNonGenericEnum(enum_type);
            }
        }
    }

    /// Register a single non-generic enum type.
    /// Regular enums are represented as tagged unions: {tag: i8, payload_union}
    /// Extern enums are represented as their repr integer type directly.
    fn registerNonGenericEnum(self: *Emitter, enum_type: *types.EnumType) EmitError!void {
        // Skip if already registered
        if (self.struct_types.contains(enum_type.name)) {
            return;
        }

        // For extern enums, the LLVM type is just the repr integer type
        if (enum_type.is_extern) {
            if (enum_type.repr_type) |repr| {
                const llvm_repr_type = self.typeToLLVM(repr);

                // For extern enums, we use the repr type directly (no struct wrapper)
                // Store with empty field info since it's not a struct
                const field_indices = self.allocator.alloc(u32, 0) catch return EmitError.OutOfMemory;
                const field_names = self.allocator.alloc([]const u8, 0) catch return EmitError.OutOfMemory;

                self.struct_types.put(enum_type.name, .{
                    .llvm_type = llvm_repr_type,
                    .field_indices = field_indices,
                    .field_names = field_names,
                }) catch return EmitError.OutOfMemory;
                return;
            }
        }

        // Calculate the maximum payload size across all variants
        var max_payload_size: usize = 0;
        for (enum_type.variants) |variant| {
            if (variant.payload) |payload| {
                const payload_size = switch (payload) {
                    .tuple => |tuple_types| blk: {
                        var size: usize = 0;
                        for (tuple_types) |t| {
                            size += self.getTypeSize(t);
                        }
                        break :blk size;
                    },
                    .struct_ => |struct_fields| blk: {
                        var size: usize = 0;
                        for (struct_fields) |f| {
                            size += self.getTypeSize(f.type_);
                        }
                        break :blk size;
                    },
                };
                if (payload_size > max_payload_size) {
                    max_payload_size = payload_size;
                }
            }
        }

        // Create LLVM type: {tag: i8, payload: [max_size x i8]}
        const variant_count = enum_type.variants.len;
        const tag_type = if (variant_count <= 256) llvm.Types.int8(self.ctx) else llvm.Types.int16(self.ctx);

        var field_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer field_types.deinit(self.allocator);

        // Tag field
        field_types.append(self.allocator, tag_type) catch return EmitError.OutOfMemory;

        // Payload field (if any variant has payload)
        if (max_payload_size > 0) {
            const payload_array = llvm.Types.array(llvm.Types.int8(self.ctx), @intCast(max_payload_size));
            field_types.append(self.allocator, payload_array) catch return EmitError.OutOfMemory;
        }

        // Create LLVM struct type for the enum
        const llvm_enum_type = llvm.Types.struct_(self.ctx, field_types.items, false);

        // Allocate field tracking data
        const field_count: usize = if (max_payload_size > 0) 2 else 1;
        const field_indices = self.allocator.alloc(u32, field_count) catch return EmitError.OutOfMemory;
        errdefer self.allocator.free(field_indices);

        const field_names = self.allocator.alloc([]const u8, field_count) catch return EmitError.OutOfMemory;
        errdefer self.allocator.free(field_names);

        field_indices[0] = 0;
        field_names[0] = "tag";
        if (max_payload_size > 0) {
            field_indices[1] = 1;
            field_names[1] = "payload";
        }

        // Cache the enum type info (reusing struct infrastructure)
        self.struct_types.put(enum_type.name, .{
            .llvm_type = llvm_enum_type,
            .field_indices = field_indices,
            .field_names = field_names,
        }) catch return EmitError.OutOfMemory;
    }

    /// Get the size in bytes for a type (simplified estimation for enum layout)
    fn getTypeSize(self: *Emitter, typ: types.Type) usize {
        return switch (typ) {
            .primitive => |p| switch (p) {
                .bool_ => 1,
                .i8_, .u8_, .char_ => 1,
                .i16_, .u16_ => 2,
                .i32_, .u32_, .f32_ => 4,
                .i64_, .u64_, .f64_, .isize_, .usize_ => 8,
                .i128_, .u128_ => 16,
                .string_ => 16, // Pointer + length
            },
            .void_ => 0,
            .optional => 16, // Conservative: has_value flag + payload pointer
            .struct_ => |s| blk: {
                var size: usize = 0;
                for (s.fields) |f| {
                    size += self.getTypeSize(f.type_);
                }
                break :blk if (size == 0) 8 else size;
            },
            // Collection types have fixed struct layouts:
            // List: { ptr, len: i32, cap: i32 } = 8 + 4 + 4 = 16 bytes
            .list => 16,
            // Map: { entries: ptr, len: i32, cap: i32, tombstones: i32 } = 8 + 4 + 4 + 4 = 20 bytes
            .map => 20,
            // Set: { entries: ptr, len: i32, cap: i32, tombstones: i32 } = 8 + 4 + 4 + 4 = 20 bytes
            .set => 20,
            else => 8, // Default pointer size for complex types
        };
    }

    // =========================================================================
    // Monomorphized Function Emission
    // =========================================================================

    /// Declare all monomorphized function signatures from the type checker.
    /// Must be called BEFORE emitModule so that call sites can find the functions.
    pub fn declareMonomorphizedFunctions(self: *Emitter, type_checker: *const TypeChecker) EmitError!void {
        const monos = type_checker.getMonomorphizedFunctions();

        for (monos) |mono| {
            // Skip if this function has no body (extern declaration)
            if (mono.original_decl.body == null) continue;

            // Declare the monomorphized function with its mangled name
            try self.declareMonomorphizedFunction(mono);
        }
    }

    /// Emit all monomorphized function bodies from the type checker.
    /// Must be called AFTER emitModule (or at least after declarations are done).
    pub fn emitMonomorphizedFunctions(self: *Emitter, type_checker: *const TypeChecker) EmitError!void {
        const monos = type_checker.getMonomorphizedFunctions();

        for (monos) |mono| {
            // Skip if this function has no body (extern declaration)
            if (mono.original_decl.body == null) continue;

            // Emit the function body
            try self.emitMonomorphizedFunction(mono);
        }
    }

    /// Declare a monomorphized function without emitting its body.
    fn declareMonomorphizedFunction(self: *Emitter, mono: TypeChecker.MonomorphizedFunction) EmitError!void {
        const func_type = mono.concrete_type.function;

        // Check if return type requires sret calling convention
        const needs_sret = self.requiresSret(func_type.return_type);
        const return_llvm_type = self.typeToLLVM(func_type.return_type);

        // Build parameter types from the concrete function type
        var param_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer param_types.deinit(self.allocator);

        // If sret is needed, add pointer parameter as first param
        if (needs_sret) {
            param_types.append(self.allocator, llvm.Types.pointer(self.ctx)) catch return EmitError.OutOfMemory;
        }

        for (func_type.params) |param_ty| {
            const llvm_param_ty = self.typeToLLVM(param_ty);
            param_types.append(self.allocator, llvm_param_ty) catch return EmitError.OutOfMemory;
        }

        // Get return type - void if using sret
        const return_type = if (needs_sret) llvm.Types.void_(self.ctx) else return_llvm_type;

        // Create LLVM function type
        const fn_type = llvm.Types.function(return_type, param_types.items, false);

        // Create function with mangled name
        const mangled_name = self.allocator.dupeZ(u8, mono.mangled_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(mangled_name);

        const llvm_func = llvm.addFunction(self.module, mangled_name, fn_type);

        // Add sret attribute to first parameter if needed
        if (needs_sret) {
            const sret_kind = self.getSretAttrKind();
            const sret_attr = llvm.createTypeAttribute(self.ctx, sret_kind, return_llvm_type);
            llvm.addAttributeAtIndex(llvm_func, 1, sret_attr); // Index 1 = first param

            // Register this function as using sret so call sites can handle it
            const name_copy = self.allocator.dupe(u8, mono.mangled_name) catch return EmitError.OutOfMemory;
            self.sret_functions.put(name_copy, return_llvm_type) catch return EmitError.OutOfMemory;
        }

        // Set the calling convention
        llvm.setFunctionCallConv(llvm_func, self.calling_convention.toLLVM());
    }

    /// Emit a monomorphized function body.
    fn emitMonomorphizedFunction(self: *Emitter, mono: TypeChecker.MonomorphizedFunction) EmitError!void {
        const func = mono.original_decl;
        const func_type = mono.concrete_type.function;

        // Get the declared function
        const mangled_name = self.allocator.dupeZ(u8, mono.mangled_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(mangled_name);

        const function = self.module.getNamedFunction(mangled_name) orelse return EmitError.InvalidAST;
        self.current_function = function;

        // Check if return type requires sret calling convention
        const needs_sret = self.requiresSret(func_type.return_type);

        // Set up return type info
        const return_llvm_type = self.typeToLLVM(func_type.return_type);
        const is_optional = func_type.return_type == .optional;
        const is_result = func_type.return_type == .result;
        self.current_return_type = .{
            .llvm_type = return_llvm_type,
            .is_optional = is_optional,
            .is_result = is_result,
            .inner_type = if (is_optional) self.typeToLLVM(func_type.return_type.optional.*) else null,
            .ok_type = if (is_result) self.typeToLLVM(func_type.return_type.result.ok_type) else null,
            .err_type = if (is_result) self.typeToLLVM(func_type.return_type.result.err_type) else null,
        };
        self.current_return_klar_type = func_type.return_type;
        defer self.current_return_type = null;
        defer self.current_return_klar_type = null;

        // Create entry block
        const entry = llvm.appendBasicBlock(self.ctx, function, "entry");
        self.builder.positionAtEnd(entry);
        self.has_terminator = false;

        // Clear named values
        self.named_values.clearRetainingCapacity();

        // Handle sret parameter if needed
        // First LLVM param is the sret pointer, user params start at index 1
        const param_offset: u32 = if (needs_sret) 1 else 0;
        if (needs_sret) {
            self.current_sret_ptr = llvm.getParam(function, 0);
        } else {
            self.current_sret_ptr = null;
        }
        defer self.current_sret_ptr = null;

        // Add parameters to named values with concrete types
        for (func.params, 0..) |param, i| {
            const param_value = llvm.getParam(function, @intCast(i + param_offset));
            const concrete_param_type = func_type.params[i];
            const param_ty = self.typeToLLVM(concrete_param_type);

            const param_name = self.allocator.dupeZ(u8, param.name) catch return EmitError.OutOfMemory;
            defer self.allocator.free(param_name);

            const alloca = self.builder.buildAlloca(param_ty, param_name);
            _ = self.builder.buildStore(param_value, alloca);

            // Check if this is a reference parameter
            const is_ref = concrete_param_type == .reference;
            const ref_inner_type: ?llvm.TypeRef = if (is_ref) blk: {
                break :blk self.typeToLLVM(concrete_param_type.reference.inner);
            } else null;

            // Get struct name for reference types and value-type struct parameters
            const param_struct_name: ?[]const u8 = if (is_ref) blk: {
                const inner = concrete_param_type.reference.inner;
                if (inner == .struct_) {
                    break :blk inner.struct_.name;
                }
                break :blk null;
            } else if (concrete_param_type == .struct_) blk: {
                break :blk concrete_param_type.struct_.name;
            } else null;

            const is_signed = self.isCheckerTypeSigned(concrete_param_type);
            self.named_values.put(param.name, .{
                .value = alloca,
                .is_alloca = true,
                .ty = param_ty,
                .is_signed = is_signed,
                .struct_type_name = param_struct_name,
                .is_reference = is_ref,
                .reference_inner_type = ref_inner_type,
            }) catch return EmitError.OutOfMemory;
        }

        // Emit function body
        if (func.body) |body| {
            try self.pushScope(false);

            const result = try self.emitBlock(body);

            // Handle return
            if (!self.has_terminator) {
                if (func.return_type == null) {
                    self.emitDropsForReturn();
                    _ = self.builder.buildRetVoid();
                } else if (result) |val| {
                    if (self.current_sret_ptr) |sret_ptr| {
                        // Store result to sret pointer and return void
                        self.emitDropsForReturn();
                        _ = self.builder.buildStore(val, sret_ptr);
                        _ = self.builder.buildRetVoid();
                    } else if (self.current_return_type) |rt_info| {
                        if (rt_info.is_optional) {
                            self.emitDropsForReturn();
                            const wrapped = self.emitSome(val, rt_info.inner_type.?);
                            _ = self.builder.buildRet(wrapped);
                        } else {
                            self.emitDropsForReturn();
                            _ = self.builder.buildRet(val);
                        }
                    } else {
                        self.emitDropsForReturn();
                        _ = self.builder.buildRet(val);
                    }
                } else {
                    self.emitDropsForReturn();
                    _ = self.builder.buildRetVoid();
                }
            }

            self.popScope();
        }

        self.current_function = null;
    }

    /// Declare all monomorphized methods from the type checker.
    /// Must be called BEFORE emitting method bodies.
    pub fn declareMonomorphizedMethods(self: *Emitter, type_checker: *const TypeChecker) EmitError!void {
        const monos = type_checker.monomorphized_methods.items;

        for (monos) |mono| {
            // Skip if this method has no body
            if (mono.original_decl.body == null) continue;

            try self.declareMonomorphizedMethod(mono);
        }
    }

    /// Emit all monomorphized method bodies from the type checker.
    /// Must be called AFTER declareMonomorphizedMethods.
    pub fn emitMonomorphizedMethods(self: *Emitter, type_checker: *const TypeChecker) EmitError!void {
        const monos = type_checker.monomorphized_methods.items;

        for (monos) |mono| {
            // Skip if this method has no body
            if (mono.original_decl.body == null) continue;

            try self.emitMonomorphizedMethod(mono);
        }
    }

    /// Declare a monomorphized method without emitting its body.
    fn declareMonomorphizedMethod(self: *Emitter, mono: TypeChecker.MonomorphizedMethod) EmitError!void {
        const func_type = mono.concrete_type.function;

        // Build parameter types from the concrete function type
        var param_types = std.ArrayListUnmanaged(llvm.TypeRef){};
        defer param_types.deinit(self.allocator);

        for (func_type.params) |param_ty| {
            const llvm_param_ty = self.typeToLLVM(param_ty);
            param_types.append(self.allocator, llvm_param_ty) catch return EmitError.OutOfMemory;
        }

        // Get return type
        const return_type = self.typeToLLVM(func_type.return_type);

        // Create LLVM function type
        const fn_type = llvm.Types.function(return_type, param_types.items, false);

        // Create function with mangled name
        const mangled_name = self.allocator.dupeZ(u8, mono.mangled_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(mangled_name);

        const llvm_func = llvm.addFunction(self.module, mangled_name, fn_type);

        // Set the calling convention
        llvm.setFunctionCallConv(llvm_func, self.calling_convention.toLLVM());
    }

    /// Emit a monomorphized method body.
    fn emitMonomorphizedMethod(self: *Emitter, mono: TypeChecker.MonomorphizedMethod) EmitError!void {
        const func = mono.original_decl;
        const func_type = mono.concrete_type.function;

        // Get the declared function
        const mangled_name = self.allocator.dupeZ(u8, mono.mangled_name) catch return EmitError.OutOfMemory;
        defer self.allocator.free(mangled_name);

        const function = self.module.getNamedFunction(mangled_name) orelse {
            return EmitError.InvalidAST;
        };
        self.current_function = function;

        // Set up return type info
        const return_llvm_type = self.typeToLLVM(func_type.return_type);
        const is_optional = func_type.return_type == .optional;
        const is_result = func_type.return_type == .result;
        self.current_return_type = .{
            .llvm_type = return_llvm_type,
            .is_optional = is_optional,
            .is_result = is_result,
            .inner_type = if (is_optional) self.typeToLLVM(func_type.return_type.optional.*) else null,
            .ok_type = if (is_result) self.typeToLLVM(func_type.return_type.result.ok_type) else null,
            .err_type = if (is_result) self.typeToLLVM(func_type.return_type.result.err_type) else null,
        };
        self.current_return_klar_type = func_type.return_type;
        defer self.current_return_type = null;
        defer self.current_return_klar_type = null;

        // Create entry block
        const entry = llvm.appendBasicBlock(self.ctx, function, "entry");
        self.builder.positionAtEnd(entry);
        self.has_terminator = false;

        // Clear named values
        self.named_values.clearRetainingCapacity();

        // Construct the mangled struct name for field resolution (e.g., "Pair$i32")
        var struct_name_buf = std.ArrayListUnmanaged(u8){};
        defer struct_name_buf.deinit(self.allocator);
        struct_name_buf.appendSlice(self.allocator, mono.struct_name) catch return EmitError.OutOfMemory;
        for (mono.type_args) |type_arg| {
            struct_name_buf.append(self.allocator, '$') catch return EmitError.OutOfMemory;
            self.appendCheckerTypeNameForMangling(&struct_name_buf, type_arg) catch return EmitError.OutOfMemory;
        }
        const mangled_struct_name = self.allocator.dupe(u8, struct_name_buf.items) catch return EmitError.OutOfMemory;

        // Add parameters to named values with concrete types
        for (func.params, 0..) |param, i| {
            const param_value = llvm.getParam(function, @intCast(i));
            const concrete_param_type = func_type.params[i];
            const param_ty = self.typeToLLVM(concrete_param_type);

            const param_name = self.allocator.dupeZ(u8, param.name) catch return EmitError.OutOfMemory;
            defer self.allocator.free(param_name);

            const alloca = self.builder.buildAlloca(param_ty, param_name);
            _ = self.builder.buildStore(param_value, alloca);

            // Check if this is a reference parameter
            const is_ref = concrete_param_type == .reference;
            const ref_inner_type: ?llvm.TypeRef = if (is_ref) blk: {
                break :blk self.typeToLLVM(concrete_param_type.reference.inner);
            } else null;

            // Check if this is a struct parameter (like 'self') that needs struct_type_name
            // For reference parameters, use the mangled struct name for 'self'
            const param_struct_name: ?[]const u8 = blk: {
                // If this is the first param named "self", use the mangled struct name
                // This works for both `self: Self` and `self: &Self` or `self: &mut Self`
                if (std.mem.eql(u8, param.name, "self")) {
                    break :blk mangled_struct_name;
                }
                break :blk null;
            };

            const is_signed = self.isCheckerTypeSigned(concrete_param_type);
            self.named_values.put(param.name, .{
                .value = alloca,
                .is_alloca = true,
                .ty = param_ty,
                .is_signed = is_signed,
                .struct_type_name = param_struct_name,
                .is_reference = is_ref,
                .reference_inner_type = ref_inner_type,
            }) catch return EmitError.OutOfMemory;
        }

        // Emit function body
        if (func.body) |body| {
            try self.pushScope(false);

            const result = try self.emitBlock(body);

            // Handle return
            if (!self.has_terminator) {
                if (func.return_type == null) {
                    self.emitDropsForReturn();
                    _ = self.builder.buildRetVoid();
                } else if (result) |val| {
                    if (self.current_return_type) |rt_info| {
                        if (rt_info.is_optional) {
                            self.emitDropsForReturn();
                            const wrapped = self.emitSome(val, rt_info.inner_type.?);
                            _ = self.builder.buildRet(wrapped);
                        } else {
                            self.emitDropsForReturn();
                            _ = self.builder.buildRet(val);
                        }
                    } else {
                        self.emitDropsForReturn();
                        _ = self.builder.buildRet(val);
                    }
                } else {
                    self.emitDropsForReturn();
                    _ = self.builder.buildRetVoid();
                }
            }

            self.popScope();
        }

        self.current_function = null;
    }
};
