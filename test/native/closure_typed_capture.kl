// Test closure capturing non-i32 types (Bug 7 fix)
// Expected exit code: 0 (all tests pass)

fn main() -> i32 {
    // Test 1: Capture i64
    let big: i64 = 12345678901234
    let f1: fn() -> i32 = || -> i32 {
        let trunc: i32 = big.as[i32]  // truncate to i32 for return
        return trunc
    }
    let r1: i32 = f1()
    if r1 == 0 {
        return 1  // unexpected zero
    }

    // Test 2: Capture f64
    let pi: f64 = 3.14159
    let f2: fn() -> i32 = || -> i32 {
        let int_part: i32 = pi.as[i32]
        return int_part
    }
    let r2: i32 = f2()
    if r2 != 3 {
        return 2
    }

    // Test 3: Capture bool
    let flag: bool = true
    let f3: fn() -> i32 = || -> i32 {
        if flag {
            return 1
        }
        return 0
    }
    let r3: i32 = f3()
    if r3 != 1 {
        return 3
    }

    // Test 4: Capture string
    let msg: string = "hello"
    let f4: fn() -> i32 = || -> i32 {
        return msg.len()
    }
    let r4: i32 = f4()
    if r4 != 5 {
        return 4
    }

    // Test 5: Mixed captures
    let a: i32 = 10
    let b: i64 = 20
    let c: f64 = 5.5
    let f5: fn() -> i32 = || -> i32 {
        // a + truncate(b) + truncate(c) = 10 + 20 + 5 = 35
        return a + b.as[i32] + c.as[i32]
    }
    let r5: i32 = f5()
    if r5 != 35 {
        return 5
    }

    return 0  // All tests passed
}
