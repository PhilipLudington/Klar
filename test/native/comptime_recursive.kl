// Test recursive comptime function calls

// Factorial at compile time
fn @factorial(n: i32) -> i32 {
    if n <= 1 {
        return 1
    }
    return n * @factorial(n - 1)
}

// Fibonacci at compile time
fn @fib(n: i32) -> i32 {
    if n <= 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    return @fib(n - 1) + @fib(n - 2)
}

fn main() {
    // Test factorial - use dbg to print values
    let fact5: i32 = dbg(@factorial(5))  // Expected: 120

    // Test factorial with smaller value
    let fact3: i32 = dbg(@factorial(3))  // Expected: 6

    // Test base case
    let fact1: i32 = dbg(@factorial(1))  // Expected: 1

    // Test fibonacci
    let fib6: i32 = dbg(@fib(6))  // Expected: 8 (0, 1, 1, 2, 3, 5, 8)

    // Test smaller fibonacci
    let fib4: i32 = dbg(@fib(4))  // Expected: 3 (0, 1, 1, 2, 3)

    // Prevent unused variable warnings
    let sum: i32 = fact5 + fact3 + fact1 + fib6 + fib4
    let _: i32 = sum

    print("done\n")
}
