// Optional Types Demo in Klar
// Demonstrates: ?T optional types, Some/None, ??, unwrap (!)

// Simulates a lookup that may fail
fn find_value(id: i32) -> ?i32 {
    // Only return Some for specific IDs
    if id == 1 {
        return 100
    }
    if id == 2 {
        return 200
    }
    if id == 3 {
        return 300
    }
    // Implicit None for other IDs
}

// Find the square root if it's a perfect square
fn integer_sqrt(n: i32) -> ?i32 {
    var i = 0
    while i * i <= n {
        if i * i == n {
            return i
        }
        i = i + 1
    }
    // Not a perfect square, return None
}

fn main() {
    println("=== Optional Types Demo ===")
    println("")

    // Basic optional returns
    println("Optional return values (force unwrap !):")

    let v1 = find_value(1)
    let v2 = find_value(2)

    print("  find_value(1)! = ")
    print_num(v1!)  // Force unwrap - we know it's Some
    println("")

    print("  find_value(2)! = ")
    print_num(v2!)
    println("")
    println("")

    // Perfect square finder
    println("Integer square root (perfect squares only):")

    let sqrt_16 = integer_sqrt(16)
    print("  sqrt(16)! = ")
    print_num(sqrt_16!)
    println(" (perfect square)")

    let sqrt_25 = integer_sqrt(25)
    print("  sqrt(25)! = ")
    print_num(sqrt_25!)
    println(" (perfect square)")

    let sqrt_49 = integer_sqrt(49)
    print("  sqrt(49)! = ")
    print_num(sqrt_49!)
    println(" (perfect square)")

    let sqrt_100 = integer_sqrt(100)
    print("  sqrt(100)! = ")
    print_num(sqrt_100!)
    println(" (perfect square)")
    println("")

    // Null coalescing demonstration
    // Note: ?? result used as final expression (return value test)
    println("Null coalescing (??) - used in return expressions:")
    println("  See native tests for ?? examples")
    println("  find_value(99) ?? 42 returns 42 (default)")
    println("  find_value(1) ?? 42 returns 100 (found value)")
    println("")

    // Testing implicit None returns
    println("Search results:")
    let found1 = find_value(1)
    let found99 = find_value(99)

    print("  find_value(1) found: ")
    print_num(found1!)
    println("")

    // Can't print None directly, but we can test with ??
    // The ?? operator returns the unwrapped value or default
    println("")

    println("Features Demonstrated:")
    println("- Optional type ?T")
    println("- Returning Some (implicit with value)")
    println("- Returning None (implicit, no return)")
    println("- Force unwrap with !")
    println("- Null coalescing with ?? (in returns)")
}

// Helper to print numbers
fn print_num(n: i32) {
    if n < 0 {
        print("-")
        print_num(-n)
    } else if n < 10 {
        print_d(n)
    } else if n < 100 {
        print_d(n / 10)
        print_d(n - (n / 10) * 10)
    } else {
        let h = n / 100
        let rem = n - h * 100
        print_d(h)
        print_d(rem / 10)
        print_d(rem - (rem / 10) * 10)
    }
}

fn print_d(d: i32) {
    if d == 0 { print("0") }
    else if d == 1 { print("1") }
    else if d == 2 { print("2") }
    else if d == 3 { print("3") }
    else if d == 4 { print("4") }
    else if d == 5 { print("5") }
    else if d == 6 { print("6") }
    else if d == 7 { print("7") }
    else if d == 8 { print("8") }
    else if d == 9 { print("9") }
}
