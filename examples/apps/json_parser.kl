// JSON Parser in Klar
// Demonstrates: Recursive enums, generics, error handling, string manipulation
//
// A JSON parser implementation showcasing Klar's core features:
// - Recursive enum type (JsonValue with nested arrays/objects)
// - Generic collection types (List[T], Map[K,V])
// - Result type for error handling
// - Character-level string processing
// - Pattern matching

// ============================================================================
// JSON Value Type
// ============================================================================

enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    Str(string),
    Array(List[JsonValue]),
    Object(Map[string, JsonValue]),
}

// ============================================================================
// JSON Error Type
// ============================================================================

enum JsonError {
    UnexpectedEnd,
    UnexpectedChar,
    InvalidNumber,
    InvalidEscape,
    ExpectedColon,
    ExpectedComma,
    ExpectedValue,
    TrailingContent,
}

// ============================================================================
// ASCII Reference
// ============================================================================
// Tab=9  LF=10  CR=13  Space=32  "=34  +=43  ,=44  -=45  .=46  /=47
// 0=48  9=57  :=58  E=69  [=91  \=92  ]=93
// a=97  b=98  e=101  f=102  l=108  n=110  r=114  s=115  t=116  u=117
// {=123  }=125

// ============================================================================
// Helper Functions
// ============================================================================

fn is_whitespace(code: i32) -> bool {
    return code == 32 or code == 9 or code == 10 or code == 13  // space, tab, LF, CR
}

fn is_digit(code: i32) -> bool {
    return code >= 48 and code <= 57  // '0'..'9'
}

fn skip_ws(chars: [char], pos: i32, len: i32) -> i32 {
    var i: i32 = pos
    while i < len {
        if not is_whitespace(chars[i].as[i32]) {
            break
        }
        i = i + 1
    }
    return i
}

// ============================================================================
// Main Parse Entry Point
// ============================================================================

fn parse_json(input: string) -> Result[JsonValue, JsonError] {
    let chars: [char] = input.chars()
    let len: i32 = input.len()
    var pos: i32 = 0
    
    pos = skip_ws(chars, pos, len)
    let result: (JsonValue, i32) = parse_value(chars, pos, len)?
    pos = result.1
    pos = skip_ws(chars, pos, len)
    
    if pos < len {
        return Err(JsonError::TrailingContent)
    }
    
    return Ok(result.0)
}

// ============================================================================
// Value Parsing
// ============================================================================

fn parse_value(chars: [char], pos: i32, len: i32) -> Result[(JsonValue, i32), JsonError] {
    var p: i32 = skip_ws(chars, pos, len)
    
    if p >= len {
        return Err(JsonError::UnexpectedEnd)
    }
    
    let code: i32 = chars[p].as[i32]

    if code == 110 {            // 'n' -> null
        return parse_null(chars, p, len)
    }
    if code == 116 {            // 't' -> true
        return parse_true(chars, p, len)
    }
    if code == 102 {            // 'f' -> false
        return parse_false(chars, p, len)
    }
    if code == 34 {             // '"' -> string
        return parse_string(chars, p, len)
    }
    if code == 91 {             // '[' -> array
        return parse_array(chars, p, len)
    }
    if code == 123 {            // '{' -> object
        return parse_object(chars, p, len)
    }
    if code == 45 or is_digit(code) {  // '-' or digit -> number
        return parse_number(chars, p, len)
    }
    
    return Err(JsonError::ExpectedValue)
}

// Parse 'null'
fn parse_null(chars: [char], pos: i32, len: i32) -> Result[(JsonValue, i32), JsonError] {
    if pos + 4 > len {
        return Err(JsonError::UnexpectedEnd)
    }
    // n=110, u=117, l=108
    if chars[pos].as[i32] == 110 and chars[pos+1].as[i32] == 117 and
       chars[pos+2].as[i32] == 108 and chars[pos+3].as[i32] == 108 {
        return Ok((JsonValue::Null, pos + 4))
    }
    return Err(JsonError::ExpectedValue)
}

// Parse 'true'
fn parse_true(chars: [char], pos: i32, len: i32) -> Result[(JsonValue, i32), JsonError] {
    if pos + 4 > len {
        return Err(JsonError::UnexpectedEnd)
    }
    // t=116, r=114, u=117, e=101
    if chars[pos].as[i32] == 116 and chars[pos+1].as[i32] == 114 and
       chars[pos+2].as[i32] == 117 and chars[pos+3].as[i32] == 101 {
        return Ok((JsonValue::Bool(true), pos + 4))
    }
    return Err(JsonError::ExpectedValue)
}

// Parse 'false'
fn parse_false(chars: [char], pos: i32, len: i32) -> Result[(JsonValue, i32), JsonError] {
    if pos + 5 > len {
        return Err(JsonError::UnexpectedEnd)
    }
    // f=102, a=97, l=108, s=115, e=101
    if chars[pos].as[i32] == 102 and chars[pos+1].as[i32] == 97 and
       chars[pos+2].as[i32] == 108 and chars[pos+3].as[i32] == 115 and
       chars[pos+4].as[i32] == 101 {
        return Ok((JsonValue::Bool(false), pos + 5))
    }
    return Err(JsonError::ExpectedValue)
}

// Parse a JSON string
fn parse_string(chars: [char], pos: i32, len: i32) -> Result[(JsonValue, i32), JsonError] {
    let result: (string, i32) = parse_string_raw(chars, pos, len)?
    return Ok((JsonValue::Str(result.0), result.1))
}

// Parse raw string value (for keys and values)
fn parse_string_raw(chars: [char], pos: i32, len: i32) -> Result[(string, i32), JsonError] {
    var p: i32 = pos + 1  // Skip opening "
    var result: String = String.new()
    
    while p < len {
        let code: i32 = chars[p].as[i32]
        
        if code == 34 {             // '"' end of string
            return Ok((result.as_str(), p + 1))
        }

        if code == 92 {             // '\' escape sequence
            p = p + 1
            if p >= len {
                return Err(JsonError::UnexpectedEnd)
            }
            let esc: i32 = chars[p].as[i32]
            // Note: \uXXXX unicode escapes are not supported
            if esc == 34 { result.push('"') }           // \"
            else if esc == 92 { result.push(92.as[char]) }  // \\
            else if esc == 47 { result.push('/') }       // \/
            else if esc == 98 { result.push(8.as[char]) }   // \b -> backspace
            else if esc == 102 { result.push(12.as[char]) } // \f -> form feed
            else if esc == 110 { result.push(10.as[char]) } // \n -> newline
            else if esc == 114 { result.push(13.as[char]) } // \r -> carriage return
            else if esc == 116 { result.push(9.as[char]) }  // \t -> tab
            else { return Err(JsonError::InvalidEscape) }
            p = p + 1
        } else {
            result.push(chars[p])
            p = p + 1
        }
    }
    
    return Err(JsonError::UnexpectedEnd)
}

// Parse a JSON number
fn parse_number(chars: [char], pos: i32, len: i32) -> Result[(JsonValue, i32), JsonError] {
    var p: i32 = pos
    var negative: bool = false
    
    if p < len and chars[p].as[i32] == 45 {  // '-'
        negative = true
        p = p + 1
    }
    
    // Parse integer part
    var int_part: f64 = 0.0
    var has_digits: bool = false
    while p < len and is_digit(chars[p].as[i32]) {
        int_part = int_part * 10.0 + (chars[p].as[i32] - 48).as[f64]
        p = p + 1
        has_digits = true
    }
    
    if not has_digits {
        return Err(JsonError::InvalidNumber)
    }
    
    var result: f64 = int_part
    
    // Parse decimal part
    if p < len and chars[p].as[i32] == 46 {  // '.'
        p = p + 1
        var decimal: f64 = 0.1
        var has_frac: bool = false
        while p < len and is_digit(chars[p].as[i32]) {
            result = result + (chars[p].as[i32] - 48).as[f64] * decimal
            decimal = decimal * 0.1
            p = p + 1
            has_frac = true
        }
        if not has_frac {
            return Err(JsonError::InvalidNumber)
        }
    }
    
    // Parse exponent
    if p < len {
        let exp_char: i32 = chars[p].as[i32]
        if exp_char == 101 or exp_char == 69 {  // 'e' or 'E'
            p = p + 1
            var exp_neg: bool = false
            if p < len {
                let sign: i32 = chars[p].as[i32]
                if sign == 45 {  // '-'
                    exp_neg = true
                    p = p + 1
                } else if sign == 43 {  // '+'
                    p = p + 1
                }
            }
            var exp: i32 = 0
            var has_exp: bool = false
            while p < len and is_digit(chars[p].as[i32]) {
                exp = exp * 10 + (chars[p].as[i32] - 48)
                p = p + 1
                has_exp = true
            }
            if not has_exp {
                return Err(JsonError::InvalidNumber)
            }
            var mul: f64 = 1.0
            var i: i32 = 0
            while i < exp {
                mul = mul * 10.0
                i = i + 1
            }
            if exp_neg {
                result = result / mul
            } else {
                result = result * mul
            }
        }
    }
    
    if negative {
        result = 0.0 - result
    }
    
    return Ok((JsonValue::Number(result), p))
}

// Parse a JSON array
fn parse_array(chars: [char], pos: i32, len: i32) -> Result[(JsonValue, i32), JsonError] {
    var p: i32 = pos + 1  // Skip '['
    var elements: List[JsonValue] = List.new[JsonValue]()
    
    p = skip_ws(chars, p, len)
    
    if p < len and chars[p].as[i32] == 93 {  // ']'
        return Ok((JsonValue::Array(elements), p + 1))
    }

    // Parse first element
    let first: (JsonValue, i32) = parse_value(chars, p, len)?
    elements.push(first.0)
    p = first.1
    p = skip_ws(chars, p, len)

    // Parse remaining elements
    while p < len {
        let c: i32 = chars[p].as[i32]
        if c == 93 {            // ']'
            return Ok((JsonValue::Array(elements), p + 1))
        }
        if c != 44 {            // ','
            return Err(JsonError::ExpectedComma)
        }
        p = p + 1
        p = skip_ws(chars, p, len)
        let elem: (JsonValue, i32) = parse_value(chars, p, len)?
        elements.push(elem.0)
        p = elem.1
        p = skip_ws(chars, p, len)
    }
    
    return Err(JsonError::UnexpectedEnd)
}

// Parse a JSON object
fn parse_object(chars: [char], pos: i32, len: i32) -> Result[(JsonValue, i32), JsonError] {
    var p: i32 = pos + 1  // Skip '{'
    var entries: Map[string, JsonValue] = Map.new[string, JsonValue]()
    
    p = skip_ws(chars, p, len)
    
    if p < len and chars[p].as[i32] == 125 {  // '}'
        return Ok((JsonValue::Object(entries), p + 1))
    }

    var first: bool = true
    while p < len {
        if not first {
            if chars[p].as[i32] != 44 {  // ','
                return Err(JsonError::ExpectedComma)
            }
            p = p + 1
            p = skip_ws(chars, p, len)
        }
        first = false

        let key: (string, i32) = parse_string_raw(chars, p, len)?
        p = key.1
        p = skip_ws(chars, p, len)
        if p >= len or chars[p].as[i32] != 58 {  // ':'
            return Err(JsonError::ExpectedColon)
        }
        p = p + 1
        p = skip_ws(chars, p, len)
        let val: (JsonValue, i32) = parse_value(chars, p, len)?
        entries.insert(key.0, val.0)
        p = val.1
        p = skip_ws(chars, p, len)

        if p < len and chars[p].as[i32] == 125 {  // '}'
            return Ok((JsonValue::Object(entries), p + 1))
        }
    }

    return Err(JsonError::UnexpectedEnd)
}

// ============================================================================
// Display Helpers
// ============================================================================

fn value_kind(value: JsonValue) -> string {
    var desc: string = ""
    match value {
        JsonValue.Null => { desc = "null" }
        JsonValue.Bool(b) => {
            if b {
                desc = "bool(true)"
            } else {
                desc = "bool(false)"
            }
        }
        JsonValue.Number(_) => { desc = "number" }
        JsonValue.Str(s) => { desc = "string(\"" + s + "\")" }
        JsonValue.Array(_) => { desc = "array" }
        JsonValue.Object(_) => { desc = "object" }
    }
    return desc
}

// ============================================================================
// Demo and Tests
// ============================================================================

fn main() -> i32 {
    println("=== Klar JSON Parser Demo ===")
    println("")
    
    // Test 1: Primitives
    println("1. Parsing primitives:")
    test_parse("null")
    test_parse("true")
    test_parse("false")
    test_parse("42")
    test_parse("-3.14")
    test_parse("\"hello\"")
    println("")
    
    // Test 2: Arrays
    println("2. Parsing arrays:")
    test_parse("[]")
    test_parse("[1, 2, 3]")
    test_parse("[true, null, \"x\"]")
    println("")
    
    // Test 3: Objects
    println("3. Parsing objects:")
    test_parse("{}")
    test_parse("{\"a\": 1}")
    test_parse("{\"name\": \"Klar\", \"version\": 1}")
    println("")
    
    // Test 4: Nested
    println("4. Nested structures:")
    test_parse("{\"arr\": [1, 2]}")
    println("")

    // Test 5: Error cases
    println("5. Error handling:")
    test_parse("")
    test_parse("[1,")
    test_parse("{\"a\"}")
    test_parse("nope")
    test_parse("123abc")
    println("")

    println("=== Features Demonstrated ===")
    println("- Recursive enum (JsonValue)")  
    println("- Generic collections (List[T], Map[K,V])")
    println("- Result type error handling")
    println("- ? operator for error propagation")
    println("- Pattern matching")
    println("- String manipulation")
    
    return 0
}

fn error_name(err: JsonError) -> string {
    var name: string = ""
    match err {
        JsonError.UnexpectedEnd => { name = "UnexpectedEnd" }
        JsonError.UnexpectedChar => { name = "UnexpectedChar" }
        JsonError.InvalidNumber => { name = "InvalidNumber" }
        JsonError.InvalidEscape => { name = "InvalidEscape" }
        JsonError.ExpectedColon => { name = "ExpectedColon" }
        JsonError.ExpectedComma => { name = "ExpectedComma" }
        JsonError.ExpectedValue => { name = "ExpectedValue" }
        JsonError.TrailingContent => { name = "TrailingContent" }
    }
    return name
}

fn test_parse(input: string) {
    let result: Result[JsonValue, JsonError] = parse_json(input)
    match result {
        Ok(v) => {
            let desc: string = value_kind(v)
            print("  '")
            print(input)
            print("' -> ")
            println(desc)
        }
        Err(e) => {
            print("  '")
            print(input)
            print("' -> ERROR: ")
            println(error_name(e))
        }
    }
}
